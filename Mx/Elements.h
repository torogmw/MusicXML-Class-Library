#pragma once
#include "ElementInterface.h"
#include "Enums.h"
#include "Strings.h"
#include "FontSize.h"
#include "Integers.h"
#include "Decimals.h"
#include "NumberOrNormal.h"
#include "PositiveIntegerOrEmpty.h"
#include "Color.h"
#include "Date.h"
#include "YesNoNumber.h"
#include <memory>

namespace mx
{
    namespace e
    {
        struct DynamicsAttributes;
        using DynamicsAttributesPtr = std::shared_ptr<DynamicsAttributes>;
        
        struct DynamicsAttributes : public AttributesInterface
        {
        public:
            DynamicsAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            t::AboveBelow placement;
            t::NumberOfLines underline;
            t::NumberOfLines overline;
            t::NumberOfLines lineThrough;
            t::EnclosureShape enclosure;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
            bool hasPlacement;
            bool hasUnderline;
            bool hasOverline;
            bool hasLineThrough;
            bool hasEnclosure;
        };
        
        class Dynamics;
        using DynamicsPtr = std::shared_ptr<Dynamics>;
        using DynamicsUPtr = std::unique_ptr<Dynamics>;
        using DynamicsSet = std::vector<DynamicsPtr>;
        using DynamicsSetIter = DynamicsSet::iterator;
        using DynamicsSetIterConst = DynamicsSet::const_iterator;
        inline DynamicsPtr makeDynamics() { return std::make_shared<Dynamics>(); }
		inline DynamicsPtr makeDynamics( const t::DynamicsValue& value ) { return std::make_shared<Dynamics>( value ); }
		inline DynamicsPtr makeDynamics( t::DynamicsValue&& value ) { return std::make_shared<Dynamics>( std::move( value ) ); }
        // inline DynamicsPtr makeDynamics( Dynamics&& value ) { return std::make_shared<Dynamics>( std::move( value ) ); }
        // inline DynamicsPtr makeDynamics( const Dynamics& value ) { return std::make_shared<Dynamics>( ( value ) ); }
        class Dynamics : public ElementInterface
        {
        public:
            Dynamics( const t::DynamicsValue& value );
            Dynamics();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DynamicsAttributesPtr getAttributes() const;
            void setAttributes( const DynamicsAttributes& attributes );
            t::DynamicsValue getValue() const;
            void setValue( const t::DynamicsValue& value );
            
        private:
            t::DynamicsValue myValue;
            DynamicsAttributesPtr myAttributes;
        };
        
        /**************** AccidentalText ****************
         2520, 5117
         <xs:element name="accidental-text" type="accidental-text"/>
         <xs:complexType name="accidental-text">
         <xs:annotation>
         <xs:documentation>The accidental-text type represents an element with an accidental value and text-formatting attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="accidental-value">
         <xs:attributeGroup ref="text-formatting"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="accidental-value">
         <xs:annotation>
         <xs:documentation>The accidental-value type represents notated accidentals supported by MusicXML. In the MusicXML 2.0 DTD this was a string with values that could be included. The XSD strengthens the data typing to an enumerated list. The quarter- and three-quarters- accidentals are Tartini-style quarter-tone accidentals. The -down and -up accidentals are quarter-tone accidentals that include arrows pointing down or up. The slash- accidentals are used in Turkish classical music. The numbered sharp and flat accidentals are superscripted versions of the accidental signs, used in Turkish folk music. The sori and koron accidentals are microtonal sharp and flat accidentals used in Iranian and Persian music.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="sharp"/>
         <xs:enumeration value="natural"/>
         <xs:enumeration value="flat"/>
         <xs:enumeration value="double-sharp"/>
         <xs:enumeration value="sharp-sharp"/>
         <xs:enumeration value="flat-flat"/>
         <xs:enumeration value="natural-sharp"/>
         <xs:enumeration value="natural-flat"/>
         <xs:enumeration value="quarter-flat"/>
         <xs:enumeration value="quarter-sharp"/>
         <xs:enumeration value="three-quarters-flat"/>
         <xs:enumeration value="three-quarters-sharp"/>
         <xs:enumeration value="sharp-down"/>
         <xs:enumeration value="sharp-up"/>
         <xs:enumeration value="natural-down"/>
         <xs:enumeration value="natural-up"/>
         <xs:enumeration value="flat-down"/>
         <xs:enumeration value="flat-up"/>
         <xs:enumeration value="triple-sharp"/>
         <xs:enumeration value="triple-flat"/>
         <xs:enumeration value="slash-quarter-sharp"/>
         <xs:enumeration value="slash-sharp"/>
         <xs:enumeration value="slash-flat"/>
         <xs:enumeration value="double-slash-flat"/>
         <xs:enumeration value="sharp-1"/>
         <xs:enumeration value="sharp-2"/>
         <xs:enumeration value="sharp-3"/>
         <xs:enumeration value="sharp-5"/>
         <xs:enumeration value="flat-1"/>
         <xs:enumeration value="flat-2"/>
         <xs:enumeration value="flat-3"/>
         <xs:enumeration value="flat-4"/>
         <xs:enumeration value="sori"/>
         <xs:enumeration value="koron"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct AccidentalTextAttributes;
        using AccidentalTextAttributesPtr = std::shared_ptr<AccidentalTextAttributes>;
        
        struct AccidentalTextAttributes : public AttributesInterface
        {
        public:
            AccidentalTextAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::LeftCenterRight justify;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            t::NumberOfLines underline;
            t::NumberOfLines overline;
            t::NumberOfLines lineThrough;
            t::RotationDegrees rotation;
            t::NumberOrNormal letterSpacing;
            t::NumberOrNormal lineHeight;
            t::XmlLang lang;
            t::XmlSpace space;
            t::EnclosureShape enclosure;
            bool hasJustify;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
            bool hasUnderline;
            bool hasOverline;
            bool hasLineThrough;
            bool hasRotation;
            bool hasLetterSpacing;
            bool hasLineHeight;
            bool hasLang;
            bool hasSpace;
            bool hasEnclosure;
        };
        
        class AccidentalText;
        using AccidentalTextPtr = std::shared_ptr<AccidentalText>;
        using AccidentalTextUPtr = std::unique_ptr<AccidentalText>;
        using AccidentalTextSet = std::vector<AccidentalTextPtr>;
        using AccidentalTextSetIter = AccidentalTextSet::iterator;
        using AccidentalTextSetIterConst = AccidentalTextSet::const_iterator;
        inline AccidentalTextPtr makeAccidentalText() { return std::make_shared<AccidentalText>(); }
		inline AccidentalTextPtr makeAccidentalText( const t::AccidentalValue& value ) { return std::make_shared<AccidentalText>( value ); }
		inline AccidentalTextPtr makeAccidentalText( t::AccidentalValue&& value ) { return std::make_shared<AccidentalText>( std::move( value ) ); }
        class AccidentalText : public ElementInterface
        {
        public:
            AccidentalText();
            AccidentalText( const t::AccidentalValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            AccidentalTextAttributesPtr getAttributes() const;
            void setAttributes( const AccidentalTextAttributesPtr& attributes );
            t::AccidentalValue getValue() const;
            void setValue( const t::AccidentalValue& value );
        private:
            t::AccidentalValue myValue;
            AccidentalTextAttributesPtr myAttributes;
        };
        
        /**************** DisplayText ****************
         2517, 5114
         <xs:element name="display-text" type="formatted-text"/>
         <xs:complexType name="formatted-text">
         <xs:annotation>
         <xs:documentation>The formatted-text type represents a text element with text-formatting attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="text-formatting"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct DisplayTextAttributes;
        using DisplayTextAttributesPtr = std::shared_ptr<DisplayTextAttributes>;
        
        struct DisplayTextAttributes : public AttributesInterface
        {
        public:
            DisplayTextAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::LeftCenterRight justify;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            t::NumberOfLines underline;
            t::NumberOfLines overline;
            t::NumberOfLines lineThrough;
            t::RotationDegrees rotation;
            t::NumberOrNormal letterSpacing;
            t::NumberOrNormal lineHeight;
            t::XmlLang lang;
            t::XmlSpace space;
            t::EnclosureShape enclosure;
            bool hasJustify;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
            bool hasUnderline;
            bool hasOverline;
            bool hasLineThrough;
            bool hasRotation;
            bool hasLetterSpacing;
            bool hasLineHeight;
            bool hasLang;
            bool hasSpace;
            bool hasEnclosure;
        };
        
        class DisplayText;
        using DisplayTextPtr = std::shared_ptr<DisplayText>;
        using DisplayTextUPtr = std::unique_ptr<DisplayText>;
        using DisplayTextSet = std::vector<DisplayTextPtr>;
        using DisplayTextSetIter = DisplayTextSet::iterator;
        using DisplayTextSetIterConst = DisplayTextSet::const_iterator;
        inline DisplayTextPtr makeDisplayText() { return std::make_shared<DisplayText>(); }
		inline DisplayTextPtr makeDisplayText( const t::XsString& value ) { return std::make_shared<DisplayText>( value ); }
		inline DisplayTextPtr makeDisplayText( t::XsString&& value ) { return std::make_shared<DisplayText>( std::move( value ) ); }
        class DisplayText : public ElementInterface
        {
        public:
            DisplayText();
            DisplayText( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DisplayTextAttributesPtr getAttributes() const;
            void setAttributes( const DisplayTextAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            DisplayTextAttributesPtr myAttributes;
        };
        
        
        
        /**************** DisplayText ****************
         2517, 5114
         <xs:element name="display-text" type="formatted-text"/>
         <xs:complexType name="formatted-text">
         <xs:annotation>
         <xs:documentation>The formatted-text type represents a text element with text-formatting attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="text-formatting"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct DisplayTextAttributes;
        using DisplayTextAttributesPtr = std::shared_ptr<DisplayTextAttributes>;
        
        
        
        
        /**************** OtherPlay ****************
         2555
         <xs:element name="other-play" type="other-play"/>
         <xs:complexType name="other-play">
         <xs:annotation>
         <xs:documentation>The other-play element represents other types of playback. The required type attribute indicates the type of playback to which the element content applies.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="xs:token" use="required"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct OtherPlayAttributes;
        using OtherPlayAttributesPtr = std::shared_ptr<OtherPlayAttributes>;
        
        struct OtherPlayAttributes : public AttributesInterface
        {
        public:
            OtherPlayAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken type;
            const   bool hasType;
        };
        
        class OtherPlay;
        using OtherPlayPtr = std::shared_ptr<OtherPlay>;
        using OtherPlayUPtr = std::unique_ptr<OtherPlay>;
        using OtherPlaySet = std::vector<OtherPlayPtr>;
        using OtherPlaySetIter = OtherPlaySet::iterator;
        using OtherPlaySetIterConst = OtherPlaySet::const_iterator;
        inline OtherPlayPtr makeOtherPlay() { return std::make_shared<OtherPlay>(); }
		inline OtherPlayPtr makeOtherPlay( const t::XsString& value ) { return std::make_shared<OtherPlay>( value ); }
		inline OtherPlayPtr makeOtherPlay( t::XsString&& value ) { return std::make_shared<OtherPlay>( std::move( value ) ); }
        class OtherPlay : public ElementInterface
        {
        public:
            OtherPlay();
            OtherPlay( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            OtherPlayAttributesPtr getAttributes() const;
            void setAttributes( const OtherPlayAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            OtherPlayAttributesPtr myAttributes;
        };
        
        
        /**************** PartSymbol ****************
         2634
         <xs:element name="part-symbol" type="part-symbol" minOccurs="0">   <xs:annotation>     <xs:documentation>The part-symbol element indicates how a symbol for a multi-staff part is indicated in the score.</xs:documentation>   </xs:annotation></xs:element>
         <xs:complexType name="part-symbol">
         <xs:annotation>
         <xs:documentation>The part-symbol type indicates how a symbol for a multi-staff part is indicated in the score; brace is the default value. The top-staff and bottom-staff elements are used when the brace does not extend across the entire part. For example, in a 3-staff organ part, the top-staff will typically be 1 for the right hand, while the bottom-staff will typically be 2 for the left hand. Staff 3 for the pedals is usually outside the brace.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="group-symbol-value">
         <xs:attribute name="top-staff" type="staff-number"/>
         <xs:attribute name="bottom-staff" type="staff-number"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="color"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="group-symbol-value">
         <xs:annotation>
         <xs:documentation>The group-symbol-value type indicates how the symbol for a group is indicated in the score. The default value is none.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="none"/>
         <xs:enumeration value="brace"/>
         <xs:enumeration value="line"/>
         <xs:enumeration value="bracket"/>
         <xs:enumeration value="square"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct PartSymbolAttributes;
        using PartSymbolAttributesPtr = std::shared_ptr<PartSymbolAttributes>;
        
        struct PartSymbolAttributes : public AttributesInterface
        {
        public:
            PartSymbolAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StaffNumber topStaff;
            t::StaffNumber bottomStaff;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            bool hasTopStaff;
            bool hasBottomStaff;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
        };
        
        class PartSymbol;
        using PartSymbolPtr = std::shared_ptr<PartSymbol>;
        using PartSymbolUPtr = std::unique_ptr<PartSymbol>;
        using PartSymbolSet = std::vector<PartSymbolPtr>;
        using PartSymbolSetIter = PartSymbolSet::iterator;
        using PartSymbolSetIterConst = PartSymbolSet::const_iterator;
        inline PartSymbolPtr makePartSymbol() { return std::make_shared<PartSymbol>(); }
		inline PartSymbolPtr makePartSymbol( const t::GroupSymbolValue& value ) { return std::make_shared<PartSymbol>( value ); }
		inline PartSymbolPtr makePartSymbol( t::GroupSymbolValue&& value ) { return std::make_shared<PartSymbol>( std::move( value ) ); }
        class PartSymbol : public ElementInterface
        {
        public:
            PartSymbol();
            PartSymbol( const t::GroupSymbolValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PartSymbolAttributesPtr getAttributes() const;
            void setAttributes( const PartSymbolAttributesPtr& attributes );
            t::GroupSymbolValue getValue() const;
            void setValue( const t::GroupSymbolValue& value );
        private:
            t::GroupSymbolValue myValue;
            PartSymbolAttributesPtr myAttributes;
        };
        
        
        /**************** KeyOctave ****************
         2783
         <xs:element name="key-octave" type="key-octave" minOccurs="0" maxOccurs="unbounded">   <xs:annotation>     <xs:documentation>The optional list of key-octave elements is used to specify in which octave each element of the key signature appears.</xs:documentation> </xs:annotation></xs:element>
         <xs:complexType name="key-octave">
         <xs:annotation>
         <xs:documentation>The key-octave element specifies in which octave an element of a key signature appears. The content specifies the octave value using the same values as the display-octave element. The number attribute is a positive integer that refers to the key signature element in left-to-right order. If the cancel attribute is set to yes, then this number refers to an element specified by the cancel element. It is no by default.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="octave">
         <xs:attribute name="number" type="xs:positiveInteger" use="required"/>
         <xs:attribute name="cancel" type="yes-no"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="octave">
         <xs:annotation>
         <xs:documentation>Octaves are represented by the numbers 0 to 9, where 4 indicates the octave started by middle C.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer">
         <xs:minInclusive value="0"/>
         <xs:maxInclusive value="9"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct KeyOctaveAttributes;
        using KeyOctaveAttributesPtr = std::shared_ptr<KeyOctaveAttributes>;
        
        struct KeyOctaveAttributes : public AttributesInterface
        {
        public:
            KeyOctaveAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::PositiveInteger number;
            t::YesNo cancel;
            const   bool hasNumber;
            bool hasCancel;
        };
        
        class KeyOctave;
        using KeyOctavePtr = std::shared_ptr<KeyOctave>;
        using KeyOctaveUPtr = std::unique_ptr<KeyOctave>;
        using KeyOctaveSet = std::vector<KeyOctavePtr>;
        using KeyOctaveSetIter = KeyOctaveSet::iterator;
        using KeyOctaveSetIterConst = KeyOctaveSet::const_iterator;
        inline KeyOctavePtr makeKeyOctave() { return std::make_shared<KeyOctave>(); }
		inline KeyOctavePtr makeKeyOctave( const t::OctaveValue& value ) { return std::make_shared<KeyOctave>( value ); }
		inline KeyOctavePtr makeKeyOctave( t::OctaveValue&& value ) { return std::make_shared<KeyOctave>( std::move( value ) ); }
        class KeyOctave : public ElementInterface
        {
        public:
            KeyOctave();
            KeyOctave( const t::OctaveValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            KeyOctaveAttributesPtr getAttributes() const;
            void setAttributes( const KeyOctaveAttributesPtr& attributes );
            t::OctaveValue getValue() const;
            void setValue( const t::OctaveValue& value );
        private:
            t::OctaveValue myValue;
            KeyOctaveAttributesPtr myAttributes;
        };
        
        
        /**************** MultipleRest ****************
         2830
         <xs:element name="multiple-rest" type="multiple-rest"/>
         <xs:complexType name="multiple-rest">
         <xs:annotation>
         <xs:documentation>The text of the multiple-rest type indicates the number of measures in the multiple rest. Multiple rests may use the 1-bar / 2-bar / 4-bar rest symbols, or a single shape. The use-symbols attribute indicates which to use; it is no if not specified. The element text is ignored when the type is stop.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="positive-integer-or-empty">
         <xs:attribute name="use-symbols" type="yes-no"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="positive-integer-or-empty">
         <xs:annotation>
         <xs:documentation>The positive-integer-or-empty values can be either a positive integer or an empty string.</xs:documentation>
         </xs:annotation>
         <xs:union memberTypes="xs:positiveInteger">
         <xs:simpleType>
         <xs:restriction base="xs:string">
         <xs:enumeration value=""/>
         </xs:restriction>
         </xs:simpleType>
         </xs:union>
         </xs:simpleType>
         */
        struct MultipleRestAttributes;
        using MultipleRestAttributesPtr = std::shared_ptr<MultipleRestAttributes>;
        
        struct MultipleRestAttributes : public AttributesInterface
        {
        public:
            MultipleRestAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo useSymbols;
            bool hasUseSymbols;
        };
        
        class MultipleRest;
        using MultipleRestPtr = std::shared_ptr<MultipleRest>;
        using MultipleRestUPtr = std::unique_ptr<MultipleRest>;
        using MultipleRestSet = std::vector<MultipleRestPtr>;
        using MultipleRestSetIter = MultipleRestSet::iterator;
        using MultipleRestSetIterConst = MultipleRestSet::const_iterator;
        inline MultipleRestPtr makeMultipleRest() { return std::make_shared<MultipleRest>(); }
		inline MultipleRestPtr makeMultipleRest( const t::PositiveIntegerOrEmpty& value ) { return std::make_shared<MultipleRest>( value ); }
		inline MultipleRestPtr makeMultipleRest( t::PositiveIntegerOrEmpty&& value ) { return std::make_shared<MultipleRest>( std::move( value ) ); }
        class MultipleRest : public ElementInterface
        {
        public:
            MultipleRest();
            MultipleRest( const t::PositiveIntegerOrEmpty& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MultipleRestAttributesPtr getAttributes() const;
            void setAttributes( const MultipleRestAttributesPtr& attributes );
            t::PositiveIntegerOrEmpty getValue() const;
            void setValue( const t::PositiveIntegerOrEmpty& value );
        private:
            t::PositiveIntegerOrEmpty myValue;
            MultipleRestAttributesPtr myAttributes;
        };
        
        
        /**************** MeasureRepeat ****************
         2833
         <xs:element name="measure-repeat" type="measure-repeat"/>
         <xs:complexType name="measure-repeat">
         <xs:annotation>
         <xs:documentation>The measure-repeat type is used for both single and multiple measure repeats. The text of the element indicates the number of measures to be repeated in a single pattern. The slashes attribute specifies the number of slashes to use in the repeat sign. It is 1 if not specified. Both the start and the stop of the measure-repeat must be specified. The text of the element is ignored when the type is stop.
         
         The measure-repeat element specifies a notation style for repetitions. The actual music being repeated needs to be repeated within the MusicXML file. This element specifies the notation that indicates the repeat.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="positive-integer-or-empty">
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="slashes" type="xs:positiveInteger"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="positive-integer-or-empty">
         <xs:annotation>
         <xs:documentation>The positive-integer-or-empty values can be either a positive integer or an empty string.</xs:documentation>
         </xs:annotation>
         <xs:union memberTypes="xs:positiveInteger">
         <xs:simpleType>
         <xs:restriction base="xs:string">
         <xs:enumeration value=""/>
         </xs:restriction>
         </xs:simpleType>
         </xs:union>
         </xs:simpleType>
         */
        struct MeasureRepeatAttributes;
        using MeasureRepeatAttributesPtr = std::shared_ptr<MeasureRepeatAttributes>;
        
        struct MeasureRepeatAttributes : public AttributesInterface
        {
        public:
            MeasureRepeatAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            t::PositiveInteger slashes;
            const   bool hasType;
            bool hasSlashes;
        };
        
        class MeasureRepeat;
        using MeasureRepeatPtr = std::shared_ptr<MeasureRepeat>;
        using MeasureRepeatUPtr = std::unique_ptr<MeasureRepeat>;
        using MeasureRepeatSet = std::vector<MeasureRepeatPtr>;
        using MeasureRepeatSetIter = MeasureRepeatSet::iterator;
        using MeasureRepeatSetIterConst = MeasureRepeatSet::const_iterator;
        inline MeasureRepeatPtr makeMeasureRepeat() { return std::make_shared<MeasureRepeat>(); }
		inline MeasureRepeatPtr makeMeasureRepeat( const t::PositiveIntegerOrEmpty& value ) { return std::make_shared<MeasureRepeat>( value ); }
		inline MeasureRepeatPtr makeMeasureRepeat( t::PositiveIntegerOrEmpty&& value ) { return std::make_shared<MeasureRepeat>( std::move( value ) ); }
        class MeasureRepeat : public ElementInterface
        {
        public:
            MeasureRepeat();
            MeasureRepeat( const t::PositiveIntegerOrEmpty& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MeasureRepeatAttributesPtr getAttributes() const;
            void setAttributes( const MeasureRepeatAttributesPtr& attributes );
            t::PositiveIntegerOrEmpty getValue() const;
            void setValue( const t::PositiveIntegerOrEmpty& value );
        private:
            t::PositiveIntegerOrEmpty myValue;
            MeasureRepeatAttributesPtr myAttributes;
        };
        
        
        /**************** BarStyle ****************
         3020
         <xs:element name="bar-style" type="bar-style-color" minOccurs="0"/>
         <xs:complexType name="bar-style-color">
         <xs:annotation>
         <xs:documentation>The bar-style-color type contains barline style and color information.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="bar-style">
         <xs:attributeGroup ref="color"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="bar-style">
         <xs:annotation>
         <xs:documentation>The bar-style type represents barline style information. Choices are regular, dotted, dashed, heavy, light-light, light-heavy, heavy-light, heavy-heavy, tick (a short stroke through the top line), short (a partial barline between the 2nd and 4th lines), and none.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="regular"/>
         <xs:enumeration value="dotted"/>
         <xs:enumeration value="dashed"/>
         <xs:enumeration value="heavy"/>
         <xs:enumeration value="light-light"/>
         <xs:enumeration value="light-heavy"/>
         <xs:enumeration value="heavy-light"/>
         <xs:enumeration value="heavy-heavy"/>
         <xs:enumeration value="tick"/>
         <xs:enumeration value="short"/>
         <xs:enumeration value="none"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct BarStyleAttributes;
        using BarStyleAttributesPtr = std::shared_ptr<BarStyleAttributes>;
        
        struct BarStyleAttributes : public AttributesInterface
        {
        public:
            BarStyleAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::Color color;
            bool hasColor;
        };
        
        class BarStyle;
        using BarStylePtr = std::shared_ptr<BarStyle>;
        using BarStyleUPtr = std::unique_ptr<BarStyle>;
        using BarStyleSet = std::vector<BarStylePtr>;
        using BarStyleSetIter = BarStyleSet::iterator;
        using BarStyleSetIterConst = BarStyleSet::const_iterator;
        inline BarStylePtr makeBarStyle() { return std::make_shared<BarStyle>(); }
		inline BarStylePtr makeBarStyle( const t::BarStyleEnum& value ) { return std::make_shared<BarStyle>( value ); }
		inline BarStylePtr makeBarStyle( t::BarStyleEnum&& value ) { return std::make_shared<BarStyle>( std::move( value ) ); }
        class BarStyle : public ElementInterface
        {
        public:
            BarStyle();
            BarStyle( const t::BarStyleEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BarStyleAttributesPtr getAttributes() const;
            void setAttributes( const BarStyleAttributesPtr& attributes );
            t::BarStyleEnum getValue() const;
            void setValue( const t::BarStyleEnum& value );
        private:
            t::BarStyleEnum myValue;
            BarStyleAttributesPtr myAttributes;
        };
        
        
        /**************** Fermata ****************
         3038, 4941
         <xs:element name="fermata" type="fermata" minOccurs="0" maxOccurs="2"/>
         <xs:complexType name="fermata">
         <xs:annotation>
         <xs:documentation>The fermata text content represents the shape of the fermata sign. An empty fermata element represents a normal fermata. The fermata type is upright if not specified.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="fermata-shape">
         <xs:attribute name="type" type="upright-inverted"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="fermata-shape">
         <xs:annotation>
         <xs:documentation>The fermata-shape type represents the shape of the fermata sign. The empty value is equivalent to the normal value.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="normal"/>
         <xs:enumeration value="angled"/>
         <xs:enumeration value="square"/>
         <xs:enumeration value=""/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct FermataAttributes;
        using FermataAttributesPtr = std::shared_ptr<FermataAttributes>;
        
        struct FermataAttributes : public AttributesInterface
        {
        public:
            FermataAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::UprightInverted type;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasType;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class Fermata;
        using FermataPtr = std::shared_ptr<Fermata>;
        using FermataUPtr = std::unique_ptr<Fermata>;
        using FermataSet = std::vector<FermataPtr>;
        using FermataSetIter = FermataSet::iterator;
        using FermataSetIterConst = FermataSet::const_iterator;
        inline FermataPtr makeFermata() { return std::make_shared<Fermata>(); }
		inline FermataPtr makeFermata( const t::FermataShape& value ) { return std::make_shared<Fermata>( value ); }
		inline FermataPtr makeFermata( t::FermataShape&& value ) { return std::make_shared<Fermata>( std::move( value ) ); }
        class Fermata : public ElementInterface
        {
        public:
            Fermata();
            Fermata( const t::FermataShape& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            FermataAttributesPtr getAttributes() const;
            void setAttributes( const FermataAttributesPtr& attributes );
            t::FermataShape getValue() const;
            void setValue( const t::FermataShape& value );
        private:
            t::FermataShape myValue;
            FermataAttributesPtr myAttributes;
        };
        
        
        /**************** Ending ****************
         3043
         <xs:element name="ending" type="ending" minOccurs="0"/>
         <xs:complexType name="ending">
         <xs:annotation>
         <xs:documentation>The ending type represents multiple (e.g. first and second) endings. Typically, the start type is associated with the left barline of the first measure in an ending. The stop and discontinue types are associated with the right barline of the last measure in an ending. Stop is used when the ending mark concludes with a downward jog, as is typical for first endings. Discontinue is used when there is no downward jog, as is typical for second endings that do not conclude a piece. The length of the jog can be specified using the end-length attribute. The text-x and text-y attributes are offsets that specify where the baseline of the start of the ending text appears, relative to the start of the ending line.
         
         The number attribute reflects the numeric values of what is under the ending line. Single endings such as "1" or comma-separated multiple endings such as "1,2" may be used. The ending element text is used when the text displayed in the ending is different than what appears in the number attribute. The print-object element is used to indicate when an ending is present but not printed, as is often the case for many parts in a full score.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="number" type="ending-number" use="required"/>
         <xs:attribute name="type" type="start-stop-discontinue" use="required"/>
         <xs:attributeGroup ref="print-object"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attribute name="end-length" type="tenths"/>
         <xs:attribute name="text-x" type="tenths"/>
         <xs:attribute name="text-y" type="tenths"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct EndingAttributes;
        using EndingAttributesPtr = std::shared_ptr<EndingAttributes>;
        
        struct EndingAttributes : public AttributesInterface
        {
        public:
            EndingAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::EndingNumber number;
            t::StartStopDiscontinue type;
            t::YesNo printObject;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::TenthsValue endLength;
            t::TenthsValue textX;
            t::TenthsValue textY;
            const   bool hasNumber;
            const   bool hasType;
            bool hasPrintObject;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasEndLength;
            bool hasTextX;
            bool hasTextY;
        };
        
        class Ending;
        using EndingPtr = std::shared_ptr<Ending>;
        using EndingUPtr = std::unique_ptr<Ending>;
        using EndingSet = std::vector<EndingPtr>;
        using EndingSetIter = EndingSet::iterator;
        using EndingSetIterConst = EndingSet::const_iterator;
        inline EndingPtr makeEnding() { return std::make_shared<Ending>(); }
		inline EndingPtr makeEnding( const t::XsString& value ) { return std::make_shared<Ending>( value ); }
		inline EndingPtr makeEnding( t::XsString&& value ) { return std::make_shared<Ending>( std::move( value ) ); }
        class Ending : public ElementInterface
        {
        public:
            Ending();
            Ending( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EndingAttributesPtr getAttributes() const;
            void setAttributes( const EndingAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            EndingAttributesPtr myAttributes;
        };
        
        
        /**************** BassStep ****************
         3155
         <xs:element name="bass-step" type="bass-step"/>
         <xs:complexType name="bass-step">
         <xs:annotation>
         <xs:documentation>The bass-step type represents the pitch step of the bass of the current chord within the harmony element. The text attribute indicates how the bass should appear in a score if not using the element contents.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="step">
         <xs:attribute name="text" type="xs:token"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct BassStepAttributes;
        using BassStepAttributesPtr = std::shared_ptr<BassStepAttributes>;
        
        struct BassStepAttributes : public AttributesInterface
        {
        public:
            BassStepAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken text;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasText;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class BassStep;
        using BassStepPtr = std::shared_ptr<BassStep>;
        using BassStepUPtr = std::unique_ptr<BassStep>;
        using BassStepSet = std::vector<BassStepPtr>;
        using BassStepSetIter = BassStepSet::iterator;
        using BassStepSetIterConst = BassStepSet::const_iterator;
        inline BassStepPtr makeBassStep() { return std::make_shared<BassStep>(); }
		inline BassStepPtr makeBassStep( const t::StepEnum& value ) { return std::make_shared<BassStep>( value ); }
		inline BassStepPtr makeBassStep( t::StepEnum&& value ) { return std::make_shared<BassStep>( std::move( value ) ); }
        class BassStep : public ElementInterface
        {
        public:
            BassStep();
            BassStep( const t::StepEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BassStepAttributesPtr getAttributes() const;
            void setAttributes( const BassStepAttributesPtr& attributes );
            t::StepEnum getValue() const;
            void setValue( const t::StepEnum& value );
        private:
            t::StepEnum myValue;
            BassStepAttributesPtr myAttributes;
        };
        
        
        /**************** BassAlter ****************
         3158
         <xs:element name="bass-alter" type="bass-alter" minOccurs="0"/>
         <xs:complexType name="bass-alter">
         <xs:annotation>
         <xs:documentation>The bass-alter type represents the chromatic alteration of the bass of the current chord within the harmony element. In some chord styles, the text for the bass-step element may include bass-alter information. In that case, the print-object attribute of the bass-alter element can be set to no. The location attribute indicates whether the alteration should appear to the left or the right of the bass-step; it is right by default.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="semitones">
         <xs:attributeGroup ref="print-object"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attribute name="location" type="left-right"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        struct BassAlterAttributes;
        using BassAlterAttributesPtr = std::shared_ptr<BassAlterAttributes>;
        
        struct BassAlterAttributes : public AttributesInterface
        {
        public:
            BassAlterAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo printObject;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftRight location;
            bool hasPrintObject;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasLocation;
        };
        
        class BassAlter;
        using BassAlterPtr = std::shared_ptr<BassAlter>;
        using BassAlterUPtr = std::unique_ptr<BassAlter>;
        using BassAlterSet = std::vector<BassAlterPtr>;
        using BassAlterSetIter = BassAlterSet::iterator;
        using BassAlterSetIterConst = BassAlterSet::const_iterator;
        inline BassAlterPtr makeBassAlter() { return std::make_shared<BassAlter>(); }
		inline BassAlterPtr makeBassAlter( const t::Semitones& value ) { return std::make_shared<BassAlter>( value ); }
		inline BassAlterPtr makeBassAlter( t::Semitones&& value ) { return std::make_shared<BassAlter>( std::move( value ) ); }
        class BassAlter : public ElementInterface
        {
        public:
            BassAlter();
            BassAlter( const t::Semitones& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BassAlterAttributesPtr getAttributes() const;
            void setAttributes( const BassAlterAttributesPtr& attributes );
            t::Semitones getValue() const;
            void setValue( const t::Semitones& value );
        private:
            t::Semitones myValue;
            BassAlterAttributesPtr myAttributes;
        };
        
        
        /**************** DegreeValue ****************
         3246
         <xs:element name="degree-value" type="degree-value"/>
         <xs:complexType name="degree-value">
         <xs:annotation>
         <xs:documentation>The content of the degree-value type is a number indicating the degree of the chord (1 for the root, 3 for third, etc). The text attribute specifies how the type of the degree should be displayed in a score. The degree-value symbol attribute indicates that a symbol should be used in specifying the degree. If the symbol attribute is present, the value of the text attribute follows the symbol.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:positiveInteger">
         <xs:attribute name="symbol" type="degree-symbol-value"/>
         <xs:attribute name="text" type="xs:token"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:positiveInteger"/>
         */
        struct DegreeValueAttributes;
        using DegreeValueAttributesPtr = std::shared_ptr<DegreeValueAttributes>;
        
        struct DegreeValueAttributes : public AttributesInterface
        {
        public:
            DegreeValueAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::DegreeSymbolValue symbol;
            t::XsToken text;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasSymbol;
            bool hasText;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class DegreeValue;
        using DegreeValuePtr = std::shared_ptr<DegreeValue>;
        using DegreeValueUPtr = std::unique_ptr<DegreeValue>;
        using DegreeValueSet = std::vector<DegreeValuePtr>;
        using DegreeValueSetIter = DegreeValueSet::iterator;
        using DegreeValueSetIterConst = DegreeValueSet::const_iterator;
        inline DegreeValuePtr makeDegreeValue() { return std::make_shared<DegreeValue>(); }
		inline DegreeValuePtr makeDegreeValue( const t::PositiveInteger& value ) { return std::make_shared<DegreeValue>( value ); }
		inline DegreeValuePtr makeDegreeValue( t::PositiveInteger&& value ) { return std::make_shared<DegreeValue>( std::move( value ) ); }
        class DegreeValue : public ElementInterface
        {
        public:
            DegreeValue();
            DegreeValue( const t::PositiveInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DegreeValueAttributesPtr getAttributes() const;
            void setAttributes( const DegreeValueAttributesPtr& attributes );
            t::PositiveInteger getValue() const;
            void setValue( const t::PositiveInteger& value );
        private:
            t::PositiveInteger myValue;
            DegreeValueAttributesPtr myAttributes;
        };
        
        
        /**************** DegreeAlter ****************
         3249
         <xs:element name="degree-alter" type="degree-alter"/>
         <xs:complexType name="degree-alter">
         <xs:annotation>
         <xs:documentation>The degree-alter type represents the chromatic alteration for the current degree. If the degree-type value is alter or subtract, the degree-alter value is relative to the degree already in the chord based on its kind element. If the degree-type value is add, the degree-alter is relative to a dominant chord (major and perfect intervals except for a minor seventh). The plus-minus attribute is used to indicate if plus and minus symbols should be used instead of sharp and flat symbols to display the degree alteration; it is no by default.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="semitones">
         <xs:attributeGroup ref="print-style"/>
         <xs:attribute name="plus-minus" type="yes-no"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        struct DegreeAlterAttributes;
        using DegreeAlterAttributesPtr = std::shared_ptr<DegreeAlterAttributes>;
        
        struct DegreeAlterAttributes : public AttributesInterface
        {
        public:
            DegreeAlterAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::YesNo plusMinus;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlusMinus;
        };
        
        class DegreeAlter;
        using DegreeAlterPtr = std::shared_ptr<DegreeAlter>;
        using DegreeAlterUPtr = std::unique_ptr<DegreeAlter>;
        using DegreeAlterSet = std::vector<DegreeAlterPtr>;
        using DegreeAlterSetIter = DegreeAlterSet::iterator;
        using DegreeAlterSetIterConst = DegreeAlterSet::const_iterator;
        inline DegreeAlterPtr makeDegreeAlter() { return std::make_shared<DegreeAlter>(); }
		inline DegreeAlterPtr makeDegreeAlter( const t::Semitones& value ) { return std::make_shared<DegreeAlter>( value ); }
		inline DegreeAlterPtr makeDegreeAlter( t::Semitones&& value ) { return std::make_shared<DegreeAlter>( std::move( value ) ); }
        class DegreeAlter : public ElementInterface
        {
        public:
            DegreeAlter();
            DegreeAlter( const t::Semitones& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DegreeAlterAttributesPtr getAttributes() const;
            void setAttributes( const DegreeAlterAttributesPtr& attributes );
            t::Semitones getValue() const;
            void setValue( const t::Semitones& value );
        private:
            t::Semitones myValue;
            DegreeAlterAttributesPtr myAttributes;
        };
        
        
        /**************** DegreeType ****************
         3252
         <xs:element name="degree-type" type="degree-type"/>
         <xs:complexType name="degree-type">
         <xs:annotation>
         <xs:documentation>The degree-type type indicates if this degree is an addition, alteration, or subtraction relative to the kind of the current chord. The value of the degree-type element affects the interpretation of the value of the degree-alter element. The text attribute specifies how the type of the degree should be displayed in a score.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="degree-type-value">
         <xs:attribute name="text" type="xs:token"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="degree-type-value">
         <xs:annotation>
         <xs:documentation>The degree-type-value type indicates whether the current degree element is an addition, alteration, or subtraction to the kind of the current chord in the harmony element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="add"/>
         <xs:enumeration value="alter"/>
         <xs:enumeration value="subtract"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct DegreeTypeAttributes;
        using DegreeTypeAttributesPtr = std::shared_ptr<DegreeTypeAttributes>;
        
        struct DegreeTypeAttributes : public AttributesInterface
        {
        public:
            DegreeTypeAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken text;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasText;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class DegreeType;
        using DegreeTypePtr = std::shared_ptr<DegreeType>;
        using DegreeTypeUPtr = std::unique_ptr<DegreeType>;
        using DegreeTypeSet = std::vector<DegreeTypePtr>;
        using DegreeTypeSetIter = DegreeTypeSet::iterator;
        using DegreeTypeSetIterConst = DegreeTypeSet::const_iterator;
        inline DegreeTypePtr makeDegreeType() { return std::make_shared<DegreeType>(); }
		inline DegreeTypePtr makeDegreeType( const t::DegreeTypeValue& value ) { return std::make_shared<DegreeType>( value ); }
		inline DegreeTypePtr makeDegreeType( t::DegreeTypeValue&& value ) { return std::make_shared<DegreeType>( std::move( value ) ); }
        class DegreeType : public ElementInterface
        {
        public:
            DegreeType();
            DegreeType( const t::DegreeTypeValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DegreeTypeAttributesPtr getAttributes() const;
            void setAttributes( const DegreeTypeAttributesPtr& attributes );
            t::DegreeTypeValue getValue() const;
            void setValue( const t::DegreeTypeValue& value );
        private:
            t::DegreeTypeValue myValue;
            DegreeTypeAttributesPtr myAttributes;
        };
        
        
        /**************** Offset ****************
         3305, 3528, 3934
         <xs:element name="offset" type="offset" minOccurs="0"/>
         <xs:complexType name="offset">
         <xs:annotation>
         <xs:documentation>An offset is represented in terms of divisions, and indicates where the direction will appear relative to the current musical location. This affects the visual appearance of the direction. If the sound attribute is "yes", then the offset affects playback too. If the sound attribute is "no", then any sound associated with the direction takes effect at the current location. The sound attribute is "no" by default for compatibility with earlier versions of the MusicXML format. If an element within a direction includes a default-x attribute, the offset value will be ignored when determining the appearance of that element.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="divisions">
         <xs:attribute name="sound" type="yes-no"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="divisions">
         <xs:annotation>
         <xs:documentation>The divisions type is used to express values in terms of the musical divisions defined by the divisions element. It is preferred that these be integer values both for MIDI interoperability and to avoid roundoff errors.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        struct OffsetAttributes;
        using OffsetAttributesPtr = std::shared_ptr<OffsetAttributes>;
        
        struct OffsetAttributes : public AttributesInterface
        {
        public:
            OffsetAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo sound;
            bool hasSound;
        };
        
        class Offset;
        using OffsetPtr = std::shared_ptr<Offset>;
        using OffsetUPtr = std::unique_ptr<Offset>;
        using OffsetSet = std::vector<OffsetPtr>;
        using OffsetSetIter = OffsetSet::iterator;
        using OffsetSetIterConst = OffsetSet::const_iterator;
        inline OffsetPtr makeOffset() { return std::make_shared<Offset>(); }
		inline OffsetPtr makeOffset( const t::DivisionsValue& value ) { return std::make_shared<Offset>( value ); }
		inline OffsetPtr makeOffset( t::DivisionsValue&& value ) { return std::make_shared<Offset>( std::move( value ) ); }
        class Offset : public ElementInterface
        {
        public:
            Offset();
            Offset( const t::DivisionsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            OffsetAttributesPtr getAttributes() const;
            void setAttributes( const OffsetAttributesPtr& attributes );
            t::DivisionsValue getValue() const;
            void setValue( const t::DivisionsValue& value );
        private:
            t::DivisionsValue myValue;
            OffsetAttributesPtr myAttributes;
        };
        
        
        /**************** Rehearsal ****************
         3327
         <xs:element name="rehearsal" type="formatted-text" maxOccurs="unbounded">  <xs:annotation>     <xs:documentation>The rehearsal type specifies a rehearsal mark. Language is Italian ("it") by default. Enclosure is square by default. Left justification is assumed if not specified.</xs:documentation>  </xs:annotation></xs:element>
         <xs:complexType name="formatted-text">
         <xs:annotation>
         <xs:documentation>The formatted-text type represents a text element with text-formatting attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="text-formatting"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct RehearsalAttributes;
        using RehearsalAttributesPtr = std::shared_ptr<RehearsalAttributes>;
        
        struct RehearsalAttributes : public AttributesInterface
        {
        public:
            RehearsalAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::LeftCenterRight justify;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            t::NumberOfLines underline;
            t::NumberOfLines overline;
            t::NumberOfLines lineThrough;
            t::RotationDegrees rotation;
            t::NumberOrNormal letterSpacing;
            t::NumberOrNormal lineHeight;
            t::XmlLang lang;
            t::XmlSpace space;
            t::EnclosureShape enclosure;
            bool hasJustify;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
            bool hasUnderline;
            bool hasOverline;
            bool hasLineThrough;
            bool hasRotation;
            bool hasLetterSpacing;
            bool hasLineHeight;
            bool hasLang;
            bool hasSpace;
            bool hasEnclosure;
        };
        
        class Rehearsal;
        using RehearsalPtr = std::shared_ptr<Rehearsal>;
        using RehearsalUPtr = std::unique_ptr<Rehearsal>;
        using RehearsalSet = std::vector<RehearsalPtr>;
        using RehearsalSetIter = RehearsalSet::iterator;
        using RehearsalSetIterConst = RehearsalSet::const_iterator;
        inline RehearsalPtr makeRehearsal() { return std::make_shared<Rehearsal>(); }
		inline RehearsalPtr makeRehearsal( const t::XsString& value ) { return std::make_shared<Rehearsal>( value ); }
		inline RehearsalPtr makeRehearsal( t::XsString&& value ) { return std::make_shared<Rehearsal>( std::move( value ) ); }
        class Rehearsal : public ElementInterface
        {
        public:
            Rehearsal();
            Rehearsal( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            RehearsalAttributesPtr getAttributes() const;
            void setAttributes( const RehearsalAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            RehearsalAttributesPtr myAttributes;
        };
        
        
        /**************** Words ****************
         3339
         <xs:element name="words" type="formatted-text" maxOccurs="unbounded">  <xs:annotation>     <xs:documentation>The words element specifies a standard text direction. Left justification is assumed if not specified. Language is Italian ("it") by default. Enclosure is none by default.</xs:documentation>    </xs:annotation></xs:element>
         <xs:complexType name="formatted-text">
         <xs:annotation>
         <xs:documentation>The formatted-text type represents a text element with text-formatting attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="text-formatting"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct WordsAttributes;
        using WordsAttributesPtr = std::shared_ptr<WordsAttributes>;
        
        struct WordsAttributes : public AttributesInterface
        {
        public:
            WordsAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::LeftCenterRight justify;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            t::NumberOfLines underline;
            t::NumberOfLines overline;
            t::NumberOfLines lineThrough;
            t::RotationDegrees rotation;
            t::NumberOrNormal letterSpacing;
            t::NumberOrNormal lineHeight;
            t::XmlLang lang;
            t::XmlSpace space;
            t::EnclosureShape enclosure;
            bool hasJustify;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
            bool hasUnderline;
            bool hasOverline;
            bool hasLineThrough;
            bool hasRotation;
            bool hasLetterSpacing;
            bool hasLineHeight;
            bool hasLang;
            bool hasSpace;
            bool hasEnclosure;
        };
        
        class Words;
        using WordsPtr = std::shared_ptr<Words>;
        using WordsUPtr = std::unique_ptr<Words>;
        using WordsSet = std::vector<WordsPtr>;
        using WordsSetIter = WordsSet::iterator;
        using WordsSetIterConst = WordsSet::const_iterator;
        inline WordsPtr makeWords() { return std::make_shared<Words>(); }
		inline WordsPtr makeWords( const t::XsString& value ) { return std::make_shared<Words>( value ); }
		inline WordsPtr makeWords( t::XsString&& value ) { return std::make_shared<Words>( std::move( value ) ); }
        class Words : public ElementInterface
        {
        public:
            Words();
            Words( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            WordsAttributesPtr getAttributes() const;
            void setAttributes( const WordsAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            WordsAttributesPtr myAttributes;
        };
        
        
        /**************** PrincipalVoice ****************
         3400
         <xs:element name="principal-voice" type="principal-voice"/>
         <xs:complexType name="principal-voice">
         <xs:annotation>
         <xs:documentation>The principal-voice element represents principal and secondary voices in a score, either for analysis or for square bracket symbols that appear in a score. The symbol attribute indicates the type of symbol used at the start of the principal-voice. The content of the principal-voice element is used for analysis and may be any text value. When used for analysis separate from any printed score markings, the symbol attribute should be set to "none".</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="symbol" type="principal-voice-symbol" use="required"/>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct PrincipalVoiceAttributes;
        using PrincipalVoiceAttributesPtr = std::shared_ptr<PrincipalVoiceAttributes>;
        
        struct PrincipalVoiceAttributes : public AttributesInterface
        {
        public:
            PrincipalVoiceAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            t::PrincipalVoiceSymbol symbol;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            const   bool hasType;
            const   bool hasSymbol;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
        };
        
        class PrincipalVoice;
        using PrincipalVoicePtr = std::shared_ptr<PrincipalVoice>;
        using PrincipalVoiceUPtr = std::unique_ptr<PrincipalVoice>;
        using PrincipalVoiceSet = std::vector<PrincipalVoicePtr>;
        using PrincipalVoiceSetIter = PrincipalVoiceSet::iterator;
        using PrincipalVoiceSetIterConst = PrincipalVoiceSet::const_iterator;
        inline PrincipalVoicePtr makePrincipalVoice() { return std::make_shared<PrincipalVoice>(); }
		inline PrincipalVoicePtr makePrincipalVoice( const t::XsString& value ) { return std::make_shared<PrincipalVoice>( value ); }
		inline PrincipalVoicePtr makePrincipalVoice( t::XsString&& value ) { return std::make_shared<PrincipalVoice>( std::move( value ) ); }
        class PrincipalVoice : public ElementInterface
        {
        public:
            PrincipalVoice();
            PrincipalVoice( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PrincipalVoiceAttributesPtr getAttributes() const;
            void setAttributes( const PrincipalVoiceAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            PrincipalVoiceAttributesPtr myAttributes;
        };
        
        
        /**************** OtherDirection ****************
         3410
         <xs:element name="other-direction" type="other-direction"/>
         <xs:complexType name="other-direction">
         <xs:annotation>
         <xs:documentation>The other-direction type is used to define any direction symbols not yet in the current version of the MusicXML format. This allows extended representation, though without application interoperability.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-object"/>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct OtherDirectionAttributes;
        using OtherDirectionAttributesPtr = std::shared_ptr<OtherDirectionAttributes>;
        
        struct OtherDirectionAttributes : public AttributesInterface
        {
        public:
            OtherDirectionAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo printObject;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            bool hasPrintObject;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
        };
        
        class OtherDirection;
        using OtherDirectionPtr = std::shared_ptr<OtherDirection>;
        using OtherDirectionUPtr = std::unique_ptr<OtherDirection>;
        using OtherDirectionSet = std::vector<OtherDirectionPtr>;
        using OtherDirectionSetIter = OtherDirectionSet::iterator;
        using OtherDirectionSetIterConst = OtherDirectionSet::const_iterator;
        inline OtherDirectionPtr makeOtherDirection() { return std::make_shared<OtherDirection>(); }
		inline OtherDirectionPtr makeOtherDirection( const t::XsString& value ) { return std::make_shared<OtherDirection>( value ); }
		inline OtherDirectionPtr makeOtherDirection( t::XsString&& value ) { return std::make_shared<OtherDirection>( std::move( value ) ); }
        class OtherDirection : public ElementInterface
        {
        public:
            OtherDirection();
            OtherDirection( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            OtherDirectionAttributesPtr getAttributes() const;
            void setAttributes( const OtherDirectionAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            OtherDirectionAttributesPtr myAttributes;
        };
        
        
        /**************** FirstFret ****************
         3451
         <xs:element name="first-fret" type="first-fret" minOccurs="0"/>
         <xs:complexType name="first-fret">
         <xs:annotation>
         <xs:documentation>The first-fret type indicates which fret is shown in the top space of the frame; it is fret 1 if the element is not present. The optional text attribute indicates how this is represented in the fret diagram, while the location attribute indicates whether the text appears to the left or right of the frame.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:positiveInteger">
         <xs:attribute name="text" type="xs:token"/>
         <xs:attribute name="location" type="left-right"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:positiveInteger"/>
         */
        struct FirstFretAttributes;
        using FirstFretAttributesPtr = std::shared_ptr<FirstFretAttributes>;
        
        struct FirstFretAttributes : public AttributesInterface
        {
        public:
            FirstFretAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken text;
            t::LeftRight location;
            bool hasText;
            bool hasLocation;
        };
        
        class FirstFret;
        using FirstFretPtr = std::shared_ptr<FirstFret>;
        using FirstFretUPtr = std::unique_ptr<FirstFret>;
        using FirstFretSet = std::vector<FirstFretPtr>;
        using FirstFretSetIter = FirstFretSet::iterator;
        using FirstFretSetIterConst = FirstFretSet::const_iterator;
        inline FirstFretPtr makeFirstFret() { return std::make_shared<FirstFret>(); }
		inline FirstFretPtr makeFirstFret( const t::PositiveInteger& value ) { return std::make_shared<FirstFret>( value ); }
		inline FirstFretPtr makeFirstFret( t::PositiveInteger&& value ) { return std::make_shared<FirstFret>( std::move( value ) ); }
        class FirstFret : public ElementInterface
        {
        public:
            FirstFret();
            FirstFret( const t::PositiveInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            FirstFretAttributesPtr getAttributes() const;
            void setAttributes( const FirstFretAttributesPtr& attributes );
            t::PositiveInteger getValue() const;
            void setValue( const t::PositiveInteger& value );
        private:
            t::PositiveInteger myValue;
            FirstFretAttributesPtr myAttributes;
        };
        
        
        /**************** Fret ****************
         3484, 5390
         <xs:element name="fret" type="fret"/>
         <xs:complexType name="fret">
         <xs:annotation>
         <xs:documentation>The fret element is used with tablature notation and chord diagrams. Fret numbers start with 0 for an open string and 1 for the first fret.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:nonNegativeInteger">
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         */
        struct FretAttributes;
        using FretAttributesPtr = std::shared_ptr<FretAttributes>;
        
        struct FretAttributes : public AttributesInterface
        {
        public:
            FretAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class Fret;
        using FretPtr = std::shared_ptr<Fret>;
        using FretUPtr = std::unique_ptr<Fret>;
        using FretSet = std::vector<FretPtr>;
        using FretSetIter = FretSet::iterator;
        using FretSetIterConst = FretSet::const_iterator;
        inline FretPtr makeFret() { return std::make_shared<Fret>(); }
		inline FretPtr makeFret( const t::NonNegativeInteger& value ) { return std::make_shared<Fret>( value ); }
		inline FretPtr makeFret( t::NonNegativeInteger&& value ) { return std::make_shared<Fret>( std::move( value ) ); }
        class Fret : public ElementInterface
        {
        public:
            Fret();
            Fret( const t::NonNegativeInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            FretAttributesPtr getAttributes() const;
            void setAttributes( const FretAttributesPtr& attributes );
            t::NonNegativeInteger getValue() const;
            void setValue( const t::NonNegativeInteger& value );
        private:
            t::NonNegativeInteger myValue;
            FretAttributesPtr myAttributes;
        };
        
        
        /**************** Fingering ****************
         3487, 5362
         <xs:element name="fingering" type="fingering" minOccurs="0"/>
         <xs:complexType name="fingering">
         <xs:annotation>
         <xs:documentation>Fingering is typically indicated 1,2,3,4,5. Multiple fingerings may be given, typically to substitute fingerings in the middle of a note. The substitution and alternate values are "no" if the attribute is not present. For guitar and other fretted instruments, the fingering element represents the fretting finger; the pluck element represents the plucking finger.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="substitution" type="yes-no"/>
         <xs:attribute name="alternate" type="yes-no"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct FingeringAttributes;
        using FingeringAttributesPtr = std::shared_ptr<FingeringAttributes>;
        
        struct FingeringAttributes : public AttributesInterface
        {
        public:
            FingeringAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo substitution;
            t::YesNo alternate;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasSubstitution;
            bool hasAlternate;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class Fingering;
        using FingeringPtr = std::shared_ptr<Fingering>;
        using FingeringUPtr = std::unique_ptr<Fingering>;
        using FingeringSet = std::vector<FingeringPtr>;
        using FingeringSetIter = FingeringSet::iterator;
        using FingeringSetIterConst = FingeringSet::const_iterator;
        inline FingeringPtr makeFingering() { return std::make_shared<Fingering>(); }
		inline FingeringPtr makeFingering( const t::XsString& value ) { return std::make_shared<Fingering>( value ); }
		inline FingeringPtr makeFingering( t::XsString&& value ) { return std::make_shared<Fingering>( std::move( value ) ); }
        class Fingering : public ElementInterface
        {
        public:
            Fingering();
            Fingering( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            FingeringAttributesPtr getAttributes() const;
            void setAttributes( const FingeringAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            FingeringAttributesPtr myAttributes;
        };
        
        
        /**************** Feature ****************
         3500
         <xs:element name="feature" type="feature" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="feature">
         <xs:annotation>
         <xs:documentation>The feature type is a part of the grouping element used for musical analysis. The type attribute represents the type of the feature and the element content represents its value. This type is flexible to allow for different analyses.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="xs:token"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct FeatureAttributes;
        using FeatureAttributesPtr = std::shared_ptr<FeatureAttributes>;
        
        struct FeatureAttributes : public AttributesInterface
        {
        public:
            FeatureAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken type;
            bool hasType;
        };
        
        class Feature;
        using FeaturePtr = std::shared_ptr<Feature>;
        using FeatureUPtr = std::unique_ptr<Feature>;
        using FeatureSet = std::vector<FeaturePtr>;
        using FeatureSetIter = FeatureSet::iterator;
        using FeatureSetIterConst = FeatureSet::const_iterator;
        inline FeaturePtr makeFeature() { return std::make_shared<Feature>(); }
		inline FeaturePtr makeFeature( const t::XsString& value ) { return std::make_shared<Feature>( value ); }
		inline FeaturePtr makeFeature( t::XsString&& value ) { return std::make_shared<Feature>( std::move( value ) ); }
        class Feature : public ElementInterface
        {
        public:
            Feature();
            Feature( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            FeatureAttributesPtr getAttributes() const;
            void setAttributes( const FeatureAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            FeatureAttributesPtr myAttributes;
        };
        
        
        /**************** Offset ****************
         3305, 3528, 3934
         <xs:element name="offset" type="offset" minOccurs="0"/>
         <xs:complexType name="offset">
         <xs:annotation>
         <xs:documentation>An offset is represented in terms of divisions, and indicates where the direction will appear relative to the current musical location. This affects the visual appearance of the direction. If the sound attribute is "yes", then the offset affects playback too. If the sound attribute is "no", then any sound associated with the direction takes effect at the current location. The sound attribute is "no" by default for compatibility with earlier versions of the MusicXML format. If an element within a direction includes a default-x attribute, the offset value will be ignored when determining the appearance of that element.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="divisions">
         <xs:attribute name="sound" type="yes-no"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="divisions">
         <xs:annotation>
         <xs:documentation>The divisions type is used to express values in terms of the musical divisions defined by the divisions element. It is preferred that these be integer values both for MIDI interoperability and to avoid roundoff errors.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        
        
        
        /**************** PerMinute ****************
         3621
         <xs:element name="per-minute" type="per-minute"/>
         <xs:complexType name="per-minute">
         <xs:annotation>
         <xs:documentation>The per-minute type can be a number, or a text description including numbers. If a font is specified, it overrides the font specified for the overall metronome element. This allows separate specification of a music font for the beat-unit and a text font for the numeric value, in cases where a single metronome font is not used.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="font"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct PerMinuteAttributes;
        using PerMinuteAttributesPtr = std::shared_ptr<PerMinuteAttributes>;
        
        struct PerMinuteAttributes : public AttributesInterface
        {
        public:
            PerMinuteAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class PerMinute;
        using PerMinutePtr = std::shared_ptr<PerMinute>;
        using PerMinuteUPtr = std::unique_ptr<PerMinute>;
        using PerMinuteSet = std::vector<PerMinutePtr>;
        using PerMinuteSetIter = PerMinuteSet::iterator;
        using PerMinuteSetIterConst = PerMinuteSet::const_iterator;
        inline PerMinutePtr makePerMinute() { return std::make_shared<PerMinute>(); }
		inline PerMinutePtr makePerMinute( const t::XsString& value ) { return std::make_shared<PerMinute>( value ); }
		inline PerMinutePtr makePerMinute( t::XsString&& value ) { return std::make_shared<PerMinute>( std::move( value ) ); }
        class PerMinute : public ElementInterface
        {
        public:
            PerMinute();
            PerMinute( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PerMinuteAttributesPtr getAttributes() const;
            void setAttributes( const PerMinuteAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            PerMinuteAttributesPtr myAttributes;
        };
        
        
        /**************** MetronomeBeam ****************
         3677
         <xs:element name="metronome-beam" type="metronome-beam" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="metronome-beam">
         <xs:annotation>
         <xs:documentation>The metronome-beam type works like the beam type in defining metric relationships, but does not include all the attributes available in the beam type.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="beam-value">
         <xs:attribute name="number" type="beam-level" default="1"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="beam-value">
         <xs:annotation>
         <xs:documentation>The beam-value type represents the type of beam associated with each of 8 beam levels (up to 1024th notes) available for each note.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="begin"/>
         <xs:enumeration value="continue"/>
         <xs:enumeration value="end"/>
         <xs:enumeration value="forward hook"/>
         <xs:enumeration value="backward hook"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct MetronomeBeamAttributes;
        using MetronomeBeamAttributesPtr = std::shared_ptr<MetronomeBeamAttributes>;
        
        struct MetronomeBeamAttributes : public AttributesInterface
        {
        public:
            MetronomeBeamAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::BeamLevel number;
            bool hasNumber;
        };
        
        class MetronomeBeam;
        using MetronomeBeamPtr = std::shared_ptr<MetronomeBeam>;
        using MetronomeBeamUPtr = std::unique_ptr<MetronomeBeam>;
        using MetronomeBeamSet = std::vector<MetronomeBeamPtr>;
        using MetronomeBeamSetIter = MetronomeBeamSet::iterator;
        using MetronomeBeamSetIterConst = MetronomeBeamSet::const_iterator;
        inline MetronomeBeamPtr makeMetronomeBeam() { return std::make_shared<MetronomeBeam>(); }
		inline MetronomeBeamPtr makeMetronomeBeam( const t::BeamValue& value ) { return std::make_shared<MetronomeBeam>( value ); }
		inline MetronomeBeamPtr makeMetronomeBeam( t::BeamValue&& value ) { return std::make_shared<MetronomeBeam>( std::move( value ) ); }
        class MetronomeBeam : public ElementInterface
        {
        public:
            MetronomeBeam();
            MetronomeBeam( const t::BeamValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MetronomeBeamAttributesPtr getAttributes() const;
            void setAttributes( const MetronomeBeamAttributesPtr& attributes );
            t::BeamValue getValue() const;
            void setValue( const t::BeamValue& value );
        private:
            t::BeamValue myValue;
            MetronomeBeamAttributesPtr myAttributes;
        };
        
        
        /**************** Beater ****************
         3809
         <xs:element name="beater" type="beater"/>
         <xs:complexType name="beater">
         <xs:annotation>
         <xs:documentation>The beater type represents pictograms for beaters, mallets, and sticks that do not have different materials represented in the pictogram.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="beater-value">
         <xs:attribute name="tip" type="tip-direction"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="beater-value">
         <xs:annotation>
         <xs:documentation>The beater-value type represents pictograms for beaters, mallets, and sticks that do not have different materials represented in the pictogram. The finger and hammer values are in addition to Stone's list.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="bow"/>
         <xs:enumeration value="chime hammer"/>
         <xs:enumeration value="coin"/>
         <xs:enumeration value="finger"/>
         <xs:enumeration value="fingernail"/>
         <xs:enumeration value="fist"/>
         <xs:enumeration value="guiro scraper"/>
         <xs:enumeration value="hammer"/>
         <xs:enumeration value="hand"/>
         <xs:enumeration value="jazz stick"/>
         <xs:enumeration value="knitting needle"/>
         <xs:enumeration value="metal hammer"/>
         <xs:enumeration value="snare stick"/>
         <xs:enumeration value="spoon mallet"/>
         <xs:enumeration value="triangle beater"/>
         <xs:enumeration value="triangle beater plain"/>
         <xs:enumeration value="wire brush"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct BeaterAttributes;
        using BeaterAttributesPtr = std::shared_ptr<BeaterAttributes>;
        
        struct BeaterAttributes : public AttributesInterface
        {
        public:
            BeaterAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TipDirection tip;
            bool hasTip;
        };
        
        class Beater;
        using BeaterPtr = std::shared_ptr<Beater>;
        using BeaterUPtr = std::unique_ptr<Beater>;
        using BeaterSet = std::vector<BeaterPtr>;
        using BeaterSetIter = BeaterSet::iterator;
        using BeaterSetIterConst = BeaterSet::const_iterator;
        inline BeaterPtr makeBeater() { return std::make_shared<Beater>(); }
		inline BeaterPtr makeBeater( const t::BeaterValue& value ) { return std::make_shared<Beater>( value ); }
		inline BeaterPtr makeBeater( t::BeaterValue&& value ) { return std::make_shared<Beater>( std::move( value ) ); }
        class Beater : public ElementInterface
        {
        public:
            Beater();
            Beater( const t::BeaterValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BeaterAttributesPtr getAttributes() const;
            void setAttributes( const BeaterAttributesPtr& attributes );
            t::BeaterValue getValue() const;
            void setValue( const t::BeaterValue& value );
        private:
            t::BeaterValue myValue;
            BeaterAttributesPtr myAttributes;
        };
        
        
        /**************** MeasureNumbering ****************
         3853
         <xs:element name="measure-numbering" type="measure-numbering" minOccurs="0"/>
         <xs:complexType name="measure-numbering">
         <xs:annotation>
         <xs:documentation>The measure-numbering type describes how frequently measure numbers are displayed on this part. The number attribute from the measure element is used for printing. Measures with an implicit attribute set to "yes" never display a measure number, regardless of the measure-numbering setting.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="measure-numbering-value">
         <xs:attributeGroup ref="print-style-align"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="measure-numbering-value">
         <xs:annotation>
         <xs:documentation>The measure-numbering-value type describes how measure numbers are displayed on this part: no numbers, numbers every measure, or numbers every system.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="none"/>
         <xs:enumeration value="measure"/>
         <xs:enumeration value="system"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct MeasureNumberingAttributes;
        using MeasureNumberingAttributesPtr = std::shared_ptr<MeasureNumberingAttributes>;
        
        struct MeasureNumberingAttributes : public AttributesInterface
        {
        public:
            MeasureNumberingAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
        };
        
        class MeasureNumbering;
        using MeasureNumberingPtr = std::shared_ptr<MeasureNumbering>;
        using MeasureNumberingUPtr = std::unique_ptr<MeasureNumbering>;
        using MeasureNumberingSet = std::vector<MeasureNumberingPtr>;
        using MeasureNumberingSetIter = MeasureNumberingSet::iterator;
        using MeasureNumberingSetIterConst = MeasureNumberingSet::const_iterator;
        inline MeasureNumberingPtr makeMeasureNumbering() { return std::make_shared<MeasureNumbering>(); }
		inline MeasureNumberingPtr makeMeasureNumbering( const t::MeasureNumberingValue& value ) { return std::make_shared<MeasureNumbering>( value ); }
		inline MeasureNumberingPtr makeMeasureNumbering( t::MeasureNumberingValue&& value ) { return std::make_shared<MeasureNumbering>( std::move( value ) ); }
        class MeasureNumbering : public ElementInterface
        {
        public:
            MeasureNumbering();
            MeasureNumbering( const t::MeasureNumberingValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MeasureNumberingAttributesPtr getAttributes() const;
            void setAttributes( const MeasureNumberingAttributesPtr& attributes );
            t::MeasureNumberingValue getValue() const;
            void setValue( const t::MeasureNumberingValue& value );
        private:
            t::MeasureNumberingValue myValue;
            MeasureNumberingAttributesPtr myAttributes;
        };
        
        
        /**************** RootStep ****************
         3872
         <xs:element name="root-step" type="root-step"/>
         <xs:complexType name="root-step">
         <xs:annotation>
         <xs:documentation>The root-step type represents the pitch step of the root of the current chord within the harmony element. The text attribute indicates how the root should appear in a score if not using the element contents.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="step">
         <xs:attribute name="text" type="xs:token"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct RootStepAttributes;
        using RootStepAttributesPtr = std::shared_ptr<RootStepAttributes>;
        
        struct RootStepAttributes : public AttributesInterface
        {
        public:
            RootStepAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken text;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasText;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class RootStep;
        using RootStepPtr = std::shared_ptr<RootStep>;
        using RootStepUPtr = std::unique_ptr<RootStep>;
        using RootStepSet = std::vector<RootStepPtr>;
        using RootStepSetIter = RootStepSet::iterator;
        using RootStepSetIterConst = RootStepSet::const_iterator;
        inline RootStepPtr makeRootStep() { return std::make_shared<RootStep>(); }
		inline RootStepPtr makeRootStep( const t::StepEnum& value ) { return std::make_shared<RootStep>( value ); }
		inline RootStepPtr makeRootStep( t::StepEnum&& value ) { return std::make_shared<RootStep>( std::move( value ) ); }
        class RootStep : public ElementInterface
        {
        public:
            RootStep();
            RootStep( const t::StepEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            RootStepAttributesPtr getAttributes() const;
            void setAttributes( const RootStepAttributesPtr& attributes );
            t::StepEnum getValue() const;
            void setValue( const t::StepEnum& value );
        private:
            t::StepEnum myValue;
            RootStepAttributesPtr myAttributes;
        };
        
        
        /**************** RootAlter ****************
         3875
         <xs:element name="root-alter" type="root-alter" minOccurs="0"/>
         <xs:complexType name="root-alter">
         <xs:annotation>
         <xs:documentation>The root-alter type represents the chromatic alteration of the root of the current chord within the harmony element. In some chord styles, the text for the root-step element may include root-alter information. In that case, the print-object attribute of the root-alter element can be set to no. The location attribute indicates whether the alteration should appear to the left or the right of the root-step; it is right by default.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="semitones">
         <xs:attributeGroup ref="print-object"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attribute name="location" type="left-right"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        struct RootAlterAttributes;
        using RootAlterAttributesPtr = std::shared_ptr<RootAlterAttributes>;
        
        struct RootAlterAttributes : public AttributesInterface
        {
        public:
            RootAlterAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo printObject;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftRight location;
            bool hasPrintObject;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasLocation;
        };
        
        class RootAlter;
        using RootAlterPtr = std::shared_ptr<RootAlter>;
        using RootAlterUPtr = std::unique_ptr<RootAlter>;
        using RootAlterSet = std::vector<RootAlterPtr>;
        using RootAlterSetIter = RootAlterSet::iterator;
        using RootAlterSetIterConst = RootAlterSet::const_iterator;
        inline RootAlterPtr makeRootAlter() { return std::make_shared<RootAlter>(); }
		inline RootAlterPtr makeRootAlter( const t::Semitones& value ) { return std::make_shared<RootAlter>( value ); }
		inline RootAlterPtr makeRootAlter( t::Semitones&& value ) { return std::make_shared<RootAlter>( std::move( value ) ); }
        class RootAlter : public ElementInterface
        {
        public:
            RootAlter();
            RootAlter( const t::Semitones& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            RootAlterAttributesPtr getAttributes() const;
            void setAttributes( const RootAlterAttributesPtr& attributes );
            t::Semitones getValue() const;
            void setValue( const t::Semitones& value );
        private:
            t::Semitones myValue;
            RootAlterAttributesPtr myAttributes;
        };
        
        
        /**************** MidiDevice ****************
         3922, 5955
         <xs:element name="midi-device" type="midi-device" minOccurs="0"/>
         <xs:complexType name="midi-device">
         <xs:annotation>
         <xs:documentation>The midi-device type corresponds to the DeviceName meta event in Standard MIDI Files. The optional port attribute is a number from 1 to 16 that can be used with the unofficial MIDI port (or cable) meta event. Unlike the DeviceName meta event, there can be multiple midi-device elements per MusicXML part starting in MusicXML 3.0. The optional id attribute refers to the score-instrument assigned to this device. If missing, the device assignment affects all score-instrument elements in the score-part.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="port" type="midi-16"/>
         <xs:attribute name="id" type="xs:IDREF"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct MidiDeviceAttributes;
        using MidiDeviceAttributesPtr = std::shared_ptr<MidiDeviceAttributes>;
        
        struct MidiDeviceAttributes : public AttributesInterface
        {
        public:
            MidiDeviceAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::Midi16 port;
            t::XsIDREF id;
            bool hasPort;
            bool hasId;
        };
        
        class MidiDevice;
        using MidiDevicePtr = std::shared_ptr<MidiDevice>;
        using MidiDeviceUPtr = std::unique_ptr<MidiDevice>;
        using MidiDeviceSet = std::vector<MidiDevicePtr>;
        using MidiDeviceSetIter = MidiDeviceSet::iterator;
        using MidiDeviceSetIterConst = MidiDeviceSet::const_iterator;
        inline MidiDevicePtr makeMidiDevice() { return std::make_shared<MidiDevice>(); }
		inline MidiDevicePtr makeMidiDevice( const t::XsString& value ) { return std::make_shared<MidiDevice>( value ); }
		inline MidiDevicePtr makeMidiDevice( t::XsString&& value ) { return std::make_shared<MidiDevice>( std::move( value ) ); }
        class MidiDevice : public ElementInterface
        {
        public:
            MidiDevice();
            MidiDevice( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MidiDeviceAttributesPtr getAttributes() const;
            void setAttributes( const MidiDeviceAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            MidiDeviceAttributesPtr myAttributes;
        };
        
        
        /**************** Offset ****************
         3305, 3528, 3934
         <xs:element name="offset" type="offset" minOccurs="0"/>
         <xs:complexType name="offset">
         <xs:annotation>
         <xs:documentation>An offset is represented in terms of divisions, and indicates where the direction will appear relative to the current musical location. This affects the visual appearance of the direction. If the sound attribute is "yes", then the offset affects playback too. If the sound attribute is "no", then any sound associated with the direction takes effect at the current location. The sound attribute is "no" by default for compatibility with earlier versions of the MusicXML format. If an element within a direction includes a default-x attribute, the offset value will be ignored when determining the appearance of that element.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="divisions">
         <xs:attribute name="sound" type="yes-no"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="divisions">
         <xs:annotation>
         <xs:documentation>The divisions type is used to express values in terms of the musical divisions defined by the divisions element. It is preferred that these be integer values both for MIDI interoperability and to avoid roundoff errors.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        
        /**************** Encoder ****************
         4048
         <xs:element name="encoder" type="typed-text"/>
         <xs:complexType name="typed-text">
         <xs:annotation>
         <xs:documentation>The typed-text type represents a text element with a type attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="xs:token"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct EncoderAttributes;
        using EncoderAttributesPtr = std::shared_ptr<EncoderAttributes>;
        
        struct EncoderAttributes : public AttributesInterface
        {
        public:
            EncoderAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken type;
            bool hasType;
        };
        
        class Encoder;
        using EncoderPtr = std::shared_ptr<Encoder>;
        using EncoderUPtr = std::unique_ptr<Encoder>;
        using EncoderSet = std::vector<EncoderPtr>;
        using EncoderSetIter = EncoderSet::iterator;
        using EncoderSetIterConst = EncoderSet::const_iterator;
        inline EncoderPtr makeEncoder() { return std::make_shared<Encoder>(); }
		inline EncoderPtr makeEncoder( const t::XsString& value ) { return std::make_shared<Encoder>( value ); }
		inline EncoderPtr makeEncoder( t::XsString&& value ) { return std::make_shared<Encoder>( std::move( value ) ); }
        class Encoder : public ElementInterface
        {
        public:
            Encoder();
            Encoder( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EncoderAttributesPtr getAttributes() const;
            void setAttributes( const EncoderAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            EncoderAttributesPtr myAttributes;
        };
        
        
        /**************** Creator ****************
         4065
         <xs:element name="creator" type="typed-text" minOccurs="0" maxOccurs="unbounded">  <xs:annotation>     <xs:documentation>The creator element is borrowed from Dublin Core. It is used for the creators of the score. The type attribute is used to distinguish different creative contributions. Thus there can be multiple creators within an identification. Standard type values are composer lyricist and arranger. Other type values may be used for different types of creative roles. The type attribute should usually be used even if there is just a single creator element. The MusicXML format does not use the creator / contributor distinction from Dublin Core.</xs:documentation> </xs:annotation></xs:element>
         <xs:complexType name="typed-text">
         <xs:annotation>
         <xs:documentation>The typed-text type represents a text element with a type attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="xs:token"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct CreatorAttributes;
        using CreatorAttributesPtr = std::shared_ptr<CreatorAttributes>;
        
        struct CreatorAttributes : public AttributesInterface
        {
        public:
            CreatorAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken type;
            bool hasType;
        };
        
        class Creator;
        using CreatorPtr = std::shared_ptr<Creator>;
        using CreatorUPtr = std::unique_ptr<Creator>;
        using CreatorSet = std::vector<CreatorPtr>;
        using CreatorSetIter = CreatorSet::iterator;
        using CreatorSetIterConst = CreatorSet::const_iterator;
        inline CreatorPtr makeCreator() { return std::make_shared<Creator>(); }
		inline CreatorPtr makeCreator( const t::XsString& value ) { return std::make_shared<Creator>( value ); }
		inline CreatorPtr makeCreator( t::XsString&& value ) { return std::make_shared<Creator>( std::move( value ) ); }
        class Creator : public ElementInterface
        {
        public:
            Creator();
            Creator( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            CreatorAttributesPtr getAttributes() const;
            void setAttributes( const CreatorAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            CreatorAttributesPtr myAttributes;
        };
        
        
        /**************** Rights ****************
         4072
         <xs:element name="rights" type="typed-text" minOccurs="0" maxOccurs="unbounded">   <xs:annotation>     <xs:documentation>The rights element is borrowed from Dublin Core. It contains copyright and other intellectual property notices. Words music and derivatives can have different types so multiple rights tags with different type attributes are supported. Standard type values are music words and arrangement but other types may be used. The type attribute is only needed when there are multiple rights elements.</xs:documentation>    </xs:annotation></xs:element>
         <xs:complexType name="typed-text">
         <xs:annotation>
         <xs:documentation>The typed-text type represents a text element with a type attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="xs:token"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct RightsAttributes;
        using RightsAttributesPtr = std::shared_ptr<RightsAttributes>;
        
        struct RightsAttributes : public AttributesInterface
        {
        public:
            RightsAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken type;
            bool hasType;
        };
        
        class Rights;
        using RightsPtr = std::shared_ptr<Rights>;
        using RightsUPtr = std::unique_ptr<Rights>;
        using RightsSet = std::vector<RightsPtr>;
        using RightsSetIter = RightsSet::iterator;
        using RightsSetIterConst = RightsSet::const_iterator;
        inline RightsPtr makeRights() { return std::make_shared<Rights>(); }
		inline RightsPtr makeRights( const t::XsString& value ) { return std::make_shared<Rights>( value ); }
		inline RightsPtr makeRights( t::XsString&& value ) { return std::make_shared<Rights>( std::move( value ) ); }
        class Rights : public ElementInterface
        {
        public:
            Rights();
            Rights( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            RightsAttributesPtr getAttributes() const;
            void setAttributes( const RightsAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            RightsAttributesPtr myAttributes;
        };
        
        
        /**************** Relation ****************
         4089
         <xs:element name="relation" type="typed-text" minOccurs="0" maxOccurs="unbounded"> <xs:annotation>     <xs:documentation>A related resource for the music that is encoded. This is similar to the Dublin Core relation element. Standard type values are music words and arrangement but other types may be used.</xs:documentation>   </xs:annotation></xs:element>
         <xs:complexType name="typed-text">
         <xs:annotation>
         <xs:documentation>The typed-text type represents a text element with a type attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="xs:token"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct RelationAttributes;
        using RelationAttributesPtr = std::shared_ptr<RelationAttributes>;
        
        struct RelationAttributes : public AttributesInterface
        {
        public:
            RelationAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken type;
            bool hasType;
        };
        
        class Relation;
        using RelationPtr = std::shared_ptr<Relation>;
        using RelationUPtr = std::unique_ptr<Relation>;
        using RelationSet = std::vector<RelationPtr>;
        using RelationSetIter = RelationSet::iterator;
        using RelationSetIterConst = RelationSet::const_iterator;
        inline RelationPtr makeRelation() { return std::make_shared<Relation>(); }
		inline RelationPtr makeRelation( const t::XsString& value ) { return std::make_shared<Relation>( value ); }
		inline RelationPtr makeRelation( t::XsString&& value ) { return std::make_shared<Relation>( std::move( value ) ); }
        class Relation : public ElementInterface
        {
        public:
            Relation();
            Relation( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            RelationAttributesPtr getAttributes() const;
            void setAttributes( const RelationAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            RelationAttributesPtr myAttributes;
        };
        
        
        /**************** MiscellaneousField ****************
         4105
         <xs:element name="miscellaneous-field" type="miscellaneous-field" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="miscellaneous-field">
         <xs:annotation>
         <xs:documentation>If a program has other metadata not yet supported in the MusicXML format, each type of metadata can go in a miscellaneous-field element. The required name attribute indicates the type of metadata the element content represents.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="name" type="xs:token" use="required"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct MiscellaneousFieldAttributes;
        using MiscellaneousFieldAttributesPtr = std::shared_ptr<MiscellaneousFieldAttributes>;
        
        struct MiscellaneousFieldAttributes : public AttributesInterface
        {
        public:
            MiscellaneousFieldAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken name;
            const   bool hasName;
        };
        
        class MiscellaneousField;
        using MiscellaneousFieldPtr = std::shared_ptr<MiscellaneousField>;
        using MiscellaneousFieldUPtr = std::unique_ptr<MiscellaneousField>;
        using MiscellaneousFieldSet = std::vector<MiscellaneousFieldPtr>;
        using MiscellaneousFieldSetIter = MiscellaneousFieldSet::iterator;
        using MiscellaneousFieldSetIterConst = MiscellaneousFieldSet::const_iterator;
        inline MiscellaneousFieldPtr makeMiscellaneousField() { return std::make_shared<MiscellaneousField>(); }
		inline MiscellaneousFieldPtr makeMiscellaneousField( const t::XsString& value ) { return std::make_shared<MiscellaneousField>( value ); }
		inline MiscellaneousFieldPtr makeMiscellaneousField( t::XsString&& value ) { return std::make_shared<MiscellaneousField>( std::move( value ) ); }
        class MiscellaneousField : public ElementInterface
        {
        public:
            MiscellaneousField();
            MiscellaneousField( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MiscellaneousFieldAttributesPtr getAttributes() const;
            void setAttributes( const MiscellaneousFieldAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            MiscellaneousFieldAttributesPtr myAttributes;
        };
        
        
        /**************** LineWidth ****************
         4144
         <xs:element name="line-width" type="line-width" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="line-width">
         <xs:annotation>
         <xs:documentation>The line-width type indicates the width of a line type in tenths. The type attribute defines what type of line is being defined. Values include beam, bracket, dashes, enclosure, ending, extend, heavy barline, leger, light barline, octave shift, pedal, slur middle, slur tip, staff, stem, tie middle, tie tip, tuplet bracket, and wedge. The text content is expressed in tenths.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="tenths">
         <xs:attribute name="type" type="line-width-type" use="required"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        struct LineWidthAttributes;
        using LineWidthAttributesPtr = std::shared_ptr<LineWidthAttributes>;
        
        struct LineWidthAttributes : public AttributesInterface
        {
        public:
            LineWidthAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::LineWidthType type;
            const bool hasType;
        };
        
        class LineWidth;
        using LineWidthPtr = std::shared_ptr<LineWidth>;
        using LineWidthUPtr = std::unique_ptr<LineWidth>;
        using LineWidthSet = std::vector<LineWidthPtr>;
        using LineWidthSetIter = LineWidthSet::iterator;
        using LineWidthSetIterConst = LineWidthSet::const_iterator;
        inline LineWidthPtr makeLineWidth() { return std::make_shared<LineWidth>(); }
		inline LineWidthPtr makeLineWidth( const t::TenthsValue& value ) { return std::make_shared<LineWidth>( value ); }
		inline LineWidthPtr makeLineWidth( t::TenthsValue&& value ) { return std::make_shared<LineWidth>( std::move( value ) ); }
        class LineWidth : public ElementInterface
        {
        public:
            LineWidth();
            LineWidth( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            LineWidthAttributesPtr getAttributes() const;
            void setAttributes( const LineWidthAttributesPtr& attributes );
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
            LineWidthAttributesPtr myAttributes;
        };
        
        
        /**************** NoteSize ****************
         4149
         <xs:element name="note-size" type="note-size" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="note-size">
         <xs:annotation>
         <xs:documentation>The note-size type indicates the percentage of the regular note size to use for notes with a cue and large size as defined in the type element. The grace type is used for notes of cue size that that include a grace element. The cue type is used for all other notes with cue size, whether defined explicitly or implicitly via a cue element. The large type is used for notes of large size. The text content represent the numeric percentage. A value of 100 would be identical to the size of a regular note as defined by the music font.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="non-negative-decimal">
         <xs:attribute name="type" type="note-size-type" use="required"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="non-negative-decimal">
         <xs:annotation>
         <xs:documentation>The non-negative-decimal type specifies a non-negative decimal value.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal">
         <xs:minInclusive value="0"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct NoteSizeAttributes;
        using NoteSizeAttributesPtr = std::shared_ptr<NoteSizeAttributes>;
        
        struct NoteSizeAttributes : public AttributesInterface
        {
        public:
            NoteSizeAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::NoteSizeType type;
            const   bool hasType;
        };
        
        class NoteSize;
        using NoteSizePtr = std::shared_ptr<NoteSize>;
        using NoteSizeUPtr = std::unique_ptr<NoteSize>;
        using NoteSizeSet = std::vector<NoteSizePtr>;
        using NoteSizeSetIter = NoteSizeSet::iterator;
        using NoteSizeSetIterConst = NoteSizeSet::const_iterator;
        inline NoteSizePtr makeNoteSize() { return std::make_shared<NoteSize>(); }
		inline NoteSizePtr makeNoteSize( const t::NonNegativeDecimal& value ) { return std::make_shared<NoteSize>( value ); }
		inline NoteSizePtr makeNoteSize( t::NonNegativeDecimal&& value ) { return std::make_shared<NoteSize>( std::move( value ) ); }
        class NoteSize : public ElementInterface
        {
        public:
            NoteSize();
            NoteSize( const t::NonNegativeDecimal& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            NoteSizeAttributesPtr getAttributes() const;
            void setAttributes( const NoteSizeAttributesPtr& attributes );
            t::NonNegativeDecimal getValue() const;
            void setValue( const t::NonNegativeDecimal& value );
        private:
            t::NonNegativeDecimal myValue;
            NoteSizeAttributesPtr myAttributes;
        };
        
        
        /**************** Distance ****************
         4154
         <xs:element name="distance" type="distance" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="distance">
         <xs:annotation>
         <xs:documentation>The distance element represents standard distances between notation elements in tenths. The type attribute defines what type of distance is being defined. Valid values include hyphen (for hyphens in lyrics) and beam.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="tenths">
         <xs:attribute name="type" type="distance-type" use="required"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        struct DistanceAttributes;
        using DistanceAttributesPtr = std::shared_ptr<DistanceAttributes>;
        
        struct DistanceAttributes : public AttributesInterface
        {
        public:
            DistanceAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::DistanceType type;
            const   bool hasType;
        };
        
        class Distance;
        using DistancePtr = std::shared_ptr<Distance>;
        using DistanceUPtr = std::unique_ptr<Distance>;
        using DistanceSet = std::vector<DistancePtr>;
        using DistanceSetIter = DistanceSet::iterator;
        using DistanceSetIterConst = DistanceSet::const_iterator;
        inline DistancePtr makeDistance() { return std::make_shared<Distance>(); }
		inline DistancePtr makeDistance( const t::TenthsValue& value ) { return std::make_shared<Distance>( value ); }
		inline DistancePtr makeDistance( t::TenthsValue&& value ) { return std::make_shared<Distance>( std::move( value ) ); }
        class Distance : public ElementInterface
        {
        public:
            Distance();
            Distance( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DistanceAttributesPtr getAttributes() const;
            void setAttributes( const DistanceAttributesPtr& attributes );
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
            DistanceAttributesPtr myAttributes;
        };
        
        
        /**************** OtherAppearance ****************
         4159
         <xs:element name="other-appearance" type="other-appearance" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="other-appearance">
         <xs:annotation>
         <xs:documentation>The other-appearance type is used to define any graphical settings not yet in the current version of the MusicXML format. This allows extended representation, though without application interoperability.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="xs:token" use="required"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct OtherAppearanceAttributes;
        using OtherAppearanceAttributesPtr = std::shared_ptr<OtherAppearanceAttributes>;
        
        struct OtherAppearanceAttributes : public AttributesInterface
        {
        public:
            OtherAppearanceAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken type;
            const   bool hasType;
        };
        
        class OtherAppearance;
        using OtherAppearancePtr = std::shared_ptr<OtherAppearance>;
        using OtherAppearanceUPtr = std::unique_ptr<OtherAppearance>;
        using OtherAppearanceSet = std::vector<OtherAppearancePtr>;
        using OtherAppearanceSetIter = OtherAppearanceSet::iterator;
        using OtherAppearanceSetIterConst = OtherAppearanceSet::const_iterator;
        inline OtherAppearancePtr makeOtherAppearance() { return std::make_shared<OtherAppearance>(); }
		inline OtherAppearancePtr makeOtherAppearance( const t::XsString& value ) { return std::make_shared<OtherAppearance>( value ); }
		inline OtherAppearancePtr makeOtherAppearance( t::XsString&& value ) { return std::make_shared<OtherAppearance>( std::move( value ) ); }
        class OtherAppearance : public ElementInterface
        {
        public:
            OtherAppearance();
            OtherAppearance( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            OtherAppearanceAttributesPtr getAttributes() const;
            void setAttributes( const OtherAppearanceAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            OtherAppearanceAttributesPtr myAttributes;
        };
        
        
        /**************** BreathMark ****************
         4439
         <xs:element name="breath-mark" type="breath-mark"/>
         <xs:complexType name="breath-mark">
         <xs:annotation>
         <xs:documentation>The breath-mark element indicates a place to take a breath.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="breath-mark-value">
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="breath-mark-value">
         <xs:annotation>
         <xs:documentation>The breath-mark-value type represents the symbol used for a breath mark.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value=""/>
         <xs:enumeration value="comma"/>
         <xs:enumeration value="tick"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct BreathMarkAttributes;
        using BreathMarkAttributesPtr = std::shared_ptr<BreathMarkAttributes>;
        
        struct BreathMarkAttributes : public AttributesInterface
        {
        public:
            BreathMarkAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class BreathMark;
        using BreathMarkPtr = std::shared_ptr<BreathMark>;
        using BreathMarkUPtr = std::unique_ptr<BreathMark>;
        using BreathMarkSet = std::vector<BreathMarkPtr>;
        using BreathMarkSetIter = BreathMarkSet::iterator;
        using BreathMarkSetIterConst = BreathMarkSet::const_iterator;
        inline BreathMarkPtr makeBreathMark() { return std::make_shared<BreathMark>(); }
		inline BreathMarkPtr makeBreathMark( const t::BreathMarkValue& value ) { return std::make_shared<BreathMark>( value ); }
		inline BreathMarkPtr makeBreathMark( t::BreathMarkValue&& value ) { return std::make_shared<BreathMark>( std::move( value ) ); }
        class BreathMark : public ElementInterface
        {
        public:
            BreathMark();
            BreathMark( const t::BreathMarkValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BreathMarkAttributesPtr getAttributes() const;
            void setAttributes( const BreathMarkAttributesPtr& attributes );
            t::BreathMarkValue getValue() const;
            void setValue( const t::BreathMarkValue& value );
        private:
            t::BreathMarkValue myValue;
            BreathMarkAttributesPtr myAttributes;
        };
        
        
        /**************** OtherArticulation ****************
         4457
         <xs:element name="other-articulation" type="placement-text">   <xs:annotation>     <xs:documentation>The other-articulation element is used to define any articulations not yet in the MusicXML format. This allows extended representation though without application interoperability.</xs:documentation>    </xs:annotation></xs:element>
         <xs:complexType name="placement-text">
         <xs:annotation>
         <xs:documentation>The placement-text type represents a text element with print-style and placement attribute groups.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct OtherArticulationAttributes;
        using OtherArticulationAttributesPtr = std::shared_ptr<OtherArticulationAttributes>;
        
        struct OtherArticulationAttributes : public AttributesInterface
        {
        public:
            OtherArticulationAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class OtherArticulation;
        using OtherArticulationPtr = std::shared_ptr<OtherArticulation>;
        using OtherArticulationUPtr = std::unique_ptr<OtherArticulation>;
        using OtherArticulationSet = std::vector<OtherArticulationPtr>;
        using OtherArticulationSetIter = OtherArticulationSet::iterator;
        using OtherArticulationSetIterConst = OtherArticulationSet::const_iterator;
        inline OtherArticulationPtr makeOtherArticulation() { return std::make_shared<OtherArticulation>(); }
		inline OtherArticulationPtr makeOtherArticulation( const t::XsString& value ) { return std::make_shared<OtherArticulation>( value ); }
		inline OtherArticulationPtr makeOtherArticulation( t::XsString&& value ) { return std::make_shared<OtherArticulation>( std::move( value ) ); }
        class OtherArticulation : public ElementInterface
        {
        public:
            OtherArticulation();
            OtherArticulation( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            OtherArticulationAttributesPtr getAttributes() const;
            void setAttributes( const OtherArticulationAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            OtherArticulationAttributesPtr myAttributes;
        };
        
        
        /**************** WithBar ****************
         4532
         <xs:element name="with-bar" type="placement-text" minOccurs="0">   <xs:annotation>     <xs:documentation>The with-bar element indicates that the bend is to be done at the bridge with a whammy or vibrato bar. The content of the element indicates how this should be notated.</xs:documentation>    </xs:annotation></xs:element>
         <xs:complexType name="placement-text">
         <xs:annotation>
         <xs:documentation>The placement-text type represents a text element with print-style and placement attribute groups.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct WithBarAttributes;
        using WithBarAttributesPtr = std::shared_ptr<WithBarAttributes>;
        
        struct WithBarAttributes : public AttributesInterface
        {
        public:
            WithBarAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class WithBar;
        using WithBarPtr = std::shared_ptr<WithBar>;
        using WithBarUPtr = std::unique_ptr<WithBar>;
        using WithBarSet = std::vector<WithBarPtr>;
        using WithBarSetIter = WithBarSet::iterator;
        using WithBarSetIterConst = WithBarSet::const_iterator;
        inline WithBarPtr makeWithBar() { return std::make_shared<WithBar>(); }
		inline WithBarPtr makeWithBar( const t::XsString& value ) { return std::make_shared<WithBar>( value ); }
		inline WithBarPtr makeWithBar( t::XsString&& value ) { return std::make_shared<WithBar>( std::move( value ) ); }
        class WithBar : public ElementInterface
        {
        public:
            WithBar();
            WithBar( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            WithBarAttributesPtr getAttributes() const;
            void setAttributes( const WithBarAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            WithBarAttributesPtr myAttributes;
        };
        
        
        /**************** Prefix ****************
         4581
         <xs:element name="prefix" type="style-text" minOccurs="0"> <xs:annotation>     <xs:documentation>Values for the prefix element include the accidental values sharp flat natural double-sharp flat-flat and sharp-sharp. The prefix element may contain additional values for symbols specific to particular figured bass styles.</xs:documentation>    </xs:annotation></xs:element>
         <xs:complexType name="style-text">
         <xs:annotation>
         <xs:documentation>The style-text type represents a text element with a print-style attribute group.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct PrefixAttributes;
        using PrefixAttributesPtr = std::shared_ptr<PrefixAttributes>;
        
        struct PrefixAttributes : public AttributesInterface
        {
        public:
            PrefixAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class Prefix;
        using PrefixPtr = std::shared_ptr<Prefix>;
        using PrefixUPtr = std::unique_ptr<Prefix>;
        using PrefixSet = std::vector<PrefixPtr>;
        using PrefixSetIter = PrefixSet::iterator;
        using PrefixSetIterConst = PrefixSet::const_iterator;
        inline PrefixPtr makePrefix() { return std::make_shared<Prefix>(); }
		inline PrefixPtr makePrefix( const t::XsString& value ) { return std::make_shared<Prefix>( value ); }
		inline PrefixPtr makePrefix( t::XsString&& value ) { return std::make_shared<Prefix>( std::move( value ) ); }
        class Prefix : public ElementInterface
        {
        public:
            Prefix();
            Prefix( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PrefixAttributesPtr getAttributes() const;
            void setAttributes( const PrefixAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            PrefixAttributesPtr myAttributes;
        };
        
        
        /**************** FigureNumber ****************
         4587
         <xs:element name="figure-number" type="style-text" minOccurs="0">  <xs:annotation>     <xs:documentation>A figure-number is a number. Overstrikes of the figure number are represented in the suffix element.</xs:documentation>   </xs:annotation></xs:element>
         <xs:complexType name="style-text">
         <xs:annotation>
         <xs:documentation>The style-text type represents a text element with a print-style attribute group.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct FigureNumberAttributes;
        using FigureNumberAttributesPtr = std::shared_ptr<FigureNumberAttributes>;
        
        struct FigureNumberAttributes : public AttributesInterface
        {
        public:
            FigureNumberAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class FigureNumber;
        using FigureNumberPtr = std::shared_ptr<FigureNumber>;
        using FigureNumberUPtr = std::unique_ptr<FigureNumber>;
        using FigureNumberSet = std::vector<FigureNumberPtr>;
        using FigureNumberSetIter = FigureNumberSet::iterator;
        using FigureNumberSetIterConst = FigureNumberSet::const_iterator;
        inline FigureNumberPtr makeFigureNumber() { return std::make_shared<FigureNumber>(); }
		inline FigureNumberPtr makeFigureNumber( const t::XsString& value ) { return std::make_shared<FigureNumber>( value ); }
		inline FigureNumberPtr makeFigureNumber( t::XsString&& value ) { return std::make_shared<FigureNumber>( std::move( value ) ); }
        class FigureNumber : public ElementInterface
        {
        public:
            FigureNumber();
            FigureNumber( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            FigureNumberAttributesPtr getAttributes() const;
            void setAttributes( const FigureNumberAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            FigureNumberAttributesPtr myAttributes;
        };
        
        
        /**************** Suffix ****************
         4593
         <xs:element name="suffix" type="style-text" minOccurs="0"> <xs:annotation>     <xs:documentation>Values for the suffix element include the accidental values sharp flat natural double-sharp flat-flat and sharp-sharp. Suffixes include both symbols that come after the figure number and those that overstrike the figure number. The suffix value slash is used for slashed numbers indicating chromatic alteration. The orientation and display of the slash usually depends on the figure number. The suffix element may contain additional values for symbols specific to particular figured bass styles.</xs:documentation>    </xs:annotation></xs:element>
         <xs:complexType name="style-text">
         <xs:annotation>
         <xs:documentation>The style-text type represents a text element with a print-style attribute group.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct SuffixAttributes;
        using SuffixAttributesPtr = std::shared_ptr<SuffixAttributes>;
        
        struct SuffixAttributes : public AttributesInterface
        {
        public:
            SuffixAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class Suffix;
        using SuffixPtr = std::shared_ptr<Suffix>;
        using SuffixUPtr = std::unique_ptr<Suffix>;
        using SuffixSet = std::vector<SuffixPtr>;
        using SuffixSetIter = SuffixSet::iterator;
        using SuffixSetIterConst = SuffixSet::const_iterator;
        inline SuffixPtr makeSuffix() { return std::make_shared<Suffix>(); }
		inline SuffixPtr makeSuffix( const t::XsString& value ) { return std::make_shared<Suffix>( value ); }
		inline SuffixPtr makeSuffix( t::XsString&& value ) { return std::make_shared<Suffix>( std::move( value ) ); }
        class Suffix : public ElementInterface
        {
        public:
            Suffix();
            Suffix( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            SuffixAttributesPtr getAttributes() const;
            void setAttributes( const SuffixAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            SuffixAttributesPtr myAttributes;
        };
        
        
        /**************** HoleClosed ****************
         4764
         <xs:element name="hole-closed" type="hole-closed"/>
         <xs:complexType name="hole-closed">
         <xs:annotation>
         <xs:documentation>The hole-closed type represents whether the hole is closed, open, or half-open. The optional location attribute indicates which portion of the hole is filled in when the element value is half.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="hole-closed-value">
         <xs:attribute name="location" type="hole-closed-location"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="hole-closed-value">
         <xs:annotation>
         <xs:documentation>The hole-closed-value type represents whether the hole is closed, open, or half-open.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="yes"/>
         <xs:enumeration value="no"/>
         <xs:enumeration value="half"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct HoleClosedAttributes;
        using HoleClosedAttributesPtr = std::shared_ptr<HoleClosedAttributes>;
        
        struct HoleClosedAttributes : public AttributesInterface
        {
        public:
            HoleClosedAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::HoleClosedLocation location;
            bool hasLocation;
        };
        
        class HoleClosed;
        using HoleClosedPtr = std::shared_ptr<HoleClosed>;
        using HoleClosedUPtr = std::unique_ptr<HoleClosed>;
        using HoleClosedSet = std::vector<HoleClosedPtr>;
        using HoleClosedSetIter = HoleClosedSet::iterator;
        using HoleClosedSetIterConst = HoleClosedSet::const_iterator;
        inline HoleClosedPtr makeHoleClosed() { return std::make_shared<HoleClosed>(); }
		inline HoleClosedPtr makeHoleClosed( const t::HoleClosedValue& value ) { return std::make_shared<HoleClosed>( value ); }
		inline HoleClosedPtr makeHoleClosed( t::HoleClosedValue&& value ) { return std::make_shared<HoleClosed>( std::move( value ) ); }
        class HoleClosed : public ElementInterface
        {
        public:
            HoleClosed();
            HoleClosed( const t::HoleClosedValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            HoleClosedAttributesPtr getAttributes() const;
            void setAttributes( const HoleClosedAttributesPtr& attributes );
            t::HoleClosedValue getValue() const;
            void setValue( const t::HoleClosedValue& value );
        private:
            t::HoleClosedValue myValue;
            HoleClosedAttributesPtr myAttributes;
        };
        
        
        /**************** Text ****************
         4806, 4821
         <xs:element name="text" type="text-element-data"/>
         <xs:complexType name="text-element-data">
         <xs:annotation>
         <xs:documentation>The text-element-data type represents a syllable or portion of a syllable for lyric text underlay. A hyphen in the string content should only be used for an actual hyphenated word. Language names for text elements come from ISO 639, with optional country subcodes from ISO 3166.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         <xs:attributeGroup ref="text-decoration"/>
         <xs:attributeGroup ref="text-rotation"/>
         <xs:attributeGroup ref="letter-spacing"/>
         <xs:attribute ref="xml:lang"/>
         <xs:attributeGroup ref="text-direction"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct TextAttributes;
        using TextAttributesPtr = std::shared_ptr<TextAttributes>;
        
        struct TextAttributes : public AttributesInterface
        {
        public:
            TextAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::NumberOfLines underline;
            t::NumberOfLines overline;
            t::NumberOfLines lineThrough;
            t::RotationDegrees rotation;
            t::NumberOrNormal letterSpacing;
            t::XmlLang lang;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasUnderline;
            bool hasOverline;
            bool hasLineThrough;
            bool hasRotation;
            bool hasLetterSpacing;
            bool hasLang;
        };
        
        class Text;
        using TextPtr = std::shared_ptr<Text>;
        using TextUPtr = std::unique_ptr<Text>;
        using TextSet = std::vector<TextPtr>;
        using TextSetIter = TextSet::iterator;
        using TextSetIterConst = TextSet::const_iterator;
        inline TextPtr makeText() { return std::make_shared<Text>(); }
		inline TextPtr makeText( const t::XsString& value ) { return std::make_shared<Text>( value ); }
		inline TextPtr makeText( t::XsString&& value ) { return std::make_shared<Text>( std::move( value ) ); }
        class Text : public ElementInterface
        {
        public:
            Text();
            Text( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TextAttributesPtr getAttributes() const;
            void setAttributes( const TextAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            TextAttributesPtr myAttributes;
        };
        
        
        /**************** Elision ****************
         4814
         <xs:element name="elision" type="text-font-color"/>
         <xs:complexType name="text-font-color">
         <xs:annotation>
         <xs:documentation>The text-font-color type represents text with optional font and color information. It is used for the elision element.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         <xs:attributeGroup ref="text-decoration"/>
         <xs:attributeGroup ref="text-rotation"/>
         <xs:attributeGroup ref="letter-spacing"/>
         <xs:attribute ref="xml:lang"/>
         <xs:attributeGroup ref="text-direction"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct ElisionAttributes;
        using ElisionAttributesPtr = std::shared_ptr<ElisionAttributes>;
        
        struct ElisionAttributes : public AttributesInterface
        {
        public:
            ElisionAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::NumberOfLines underline;
            t::NumberOfLines overline;
            t::NumberOfLines lineThrough;
            t::RotationDegrees rotation;
            t::NumberOrNormal letterSpacing;
            t::XmlLang lang;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasUnderline;
            bool hasOverline;
            bool hasLineThrough;
            bool hasRotation;
            bool hasLetterSpacing;
            bool hasLang;
        };
        
        class Elision;
        using ElisionPtr = std::shared_ptr<Elision>;
        using ElisionUPtr = std::unique_ptr<Elision>;
        using ElisionSet = std::vector<ElisionPtr>;
        using ElisionSetIter = ElisionSet::iterator;
        using ElisionSetIterConst = ElisionSet::const_iterator;
        inline ElisionPtr makeElision() { return std::make_shared<Elision>(); }
		inline ElisionPtr makeElision( const t::XsString& value ) { return std::make_shared<Elision>( value ); }
		inline ElisionPtr makeElision( t::XsString&& value ) { return std::make_shared<Elision>( std::move( value ) ); }
        class Elision : public ElementInterface
        {
        public:
            Elision();
            Elision( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            ElisionAttributesPtr getAttributes() const;
            void setAttributes( const ElisionAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            ElisionAttributesPtr myAttributes;
        };
        
        
        /**************** Text ****************
         4806, 4821
         <xs:element name="text" type="text-element-data"/>
         <xs:complexType name="text-element-data">
         <xs:annotation>
         <xs:documentation>The text-element-data type represents a syllable or portion of a syllable for lyric text underlay. A hyphen in the string content should only be used for an actual hyphenated word. Language names for text elements come from ISO 639, with optional country subcodes from ISO 3166.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         <xs:attributeGroup ref="text-decoration"/>
         <xs:attributeGroup ref="text-rotation"/>
         <xs:attributeGroup ref="letter-spacing"/>
         <xs:attribute ref="xml:lang"/>
         <xs:attributeGroup ref="text-direction"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        
        
        
        /**************** Glissando ****************
         4923
         <xs:element name="glissando" type="glissando"/>
         <xs:complexType name="glissando">
         <xs:annotation>
         <xs:documentation>Glissando and slide types both indicate rapidly moving from one pitch to the other so that individual notes are not discerned. The distinction is similar to that between NIFF's glissando and portamento elements. A glissando sounds the half notes in between the slide and defaults to a wavy line. The optional text is printed alongside the line.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="number" type="number-level" default="1"/>
         <xs:attributeGroup ref="line-type"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct GlissandoAttributes;
        using GlissandoAttributesPtr = std::shared_ptr<GlissandoAttributes>;
        
        struct GlissandoAttributes : public AttributesInterface
        {
        public:
            GlissandoAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            t::NumberLevel number;
            t::TenthsValue dashLength;
            t::TenthsValue spaceLength;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            const   bool hasType;
            bool hasNumber;
            bool hasDashLength;
            bool hasSpaceLength;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class Glissando;
        using GlissandoPtr = std::shared_ptr<Glissando>;
        using GlissandoUPtr = std::unique_ptr<Glissando>;
        using GlissandoSet = std::vector<GlissandoPtr>;
        using GlissandoSetIter = GlissandoSet::iterator;
        using GlissandoSetIterConst = GlissandoSet::const_iterator;
        inline GlissandoPtr makeGlissando() { return std::make_shared<Glissando>(); }
		inline GlissandoPtr makeGlissando( const t::XsString& value ) { return std::make_shared<Glissando>( value ); }
		inline GlissandoPtr makeGlissando( t::XsString&& value ) { return std::make_shared<Glissando>( std::move( value ) ); }
        class Glissando : public ElementInterface
        {
        public:
            Glissando();
            Glissando( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            GlissandoAttributesPtr getAttributes() const;
            void setAttributes( const GlissandoAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            GlissandoAttributesPtr myAttributes;
        };
        
        
        /**************** Slide ****************
         4926
         <xs:element name="slide" type="slide"/>
         <xs:complexType name="slide">
         <xs:annotation>
         <xs:documentation>Glissando and slide types both indicate rapidly moving from one pitch to the other so that individual notes are not discerned. The distinction is similar to that between NIFF's glissando and portamento elements. A slide is continuous between two notes and defaults to a solid line. The optional text for a is printed alongside the line.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="number" type="number-level" default="1"/>
         <xs:attributeGroup ref="line-type"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="bend-sound"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct SlideAttributes;
        using SlideAttributesPtr = std::shared_ptr<SlideAttributes>;
        
        struct SlideAttributes : public AttributesInterface
        {
        public:
            SlideAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            t::NumberLevel number;
            t::TenthsValue dashLength;
            t::TenthsValue spaceLength;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::YesNo accelerate;
            t::TrillBeats beats;
            t::Percent firstBeat;
            t::Percent lastBeat;
            const   bool hasType;
            bool hasNumber;
            bool hasDashLength;
            bool hasSpaceLength;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasAccelerate;
            bool hasBeats;
            bool hasFirstBeat;
            bool hasLastBeat;
        };
        
        class Slide;
        using SlidePtr = std::shared_ptr<Slide>;
        using SlideUPtr = std::unique_ptr<Slide>;
        using SlideSet = std::vector<SlidePtr>;
        using SlideSetIter = SlideSet::iterator;
        using SlideSetIterConst = SlideSet::const_iterator;
        inline SlidePtr makeSlide() { return std::make_shared<Slide>(); }
		inline SlidePtr makeSlide( const t::XsString& value ) { return std::make_shared<Slide>( value ); }
		inline SlidePtr makeSlide( t::XsString&& value ) { return std::make_shared<Slide>( std::move( value ) ); }
        class Slide : public ElementInterface
        {
        public:
            Slide();
            Slide( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            SlideAttributesPtr getAttributes() const;
            void setAttributes( const SlideAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            SlideAttributesPtr myAttributes;
        };
        
        
        /**************** Fermata ****************
         3038, 4941
         <xs:element name="fermata" type="fermata"/>
         <xs:complexType name="fermata">
         <xs:annotation>
         <xs:documentation>The fermata text content represents the shape of the fermata sign. An empty fermata element represents a normal fermata. The fermata type is upright if not specified.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="fermata-shape">
         <xs:attribute name="type" type="upright-inverted"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="fermata-shape">
         <xs:annotation>
         <xs:documentation>The fermata-shape type represents the shape of the fermata sign. The empty value is equivalent to the normal value.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="normal"/>
         <xs:enumeration value="angled"/>
         <xs:enumeration value="square"/>
         <xs:enumeration value=""/>
         </xs:restriction>
         </xs:simpleType>
         */
        
        
        /**************** AccidentalMark ****************
         4950, 5189
         <xs:element name="accidental-mark" type="accidental-mark"/>
         <xs:complexType name="accidental-mark">
         <xs:annotation>
         <xs:documentation>An accidental-mark can be used as a separate notation or as part of an ornament. When used in an ornament, position and placement are relative to the ornament, not relative to the note.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="accidental-value">
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="accidental-value">
         <xs:annotation>
         <xs:documentation>The accidental-value type represents notated accidentals supported by MusicXML. In the MusicXML 2.0 DTD this was a string with values that could be included. The XSD strengthens the data typing to an enumerated list. The quarter- and three-quarters- accidentals are Tartini-style quarter-tone accidentals. The -down and -up accidentals are quarter-tone accidentals that include arrows pointing down or up. The slash- accidentals are used in Turkish classical music. The numbered sharp and flat accidentals are superscripted versions of the accidental signs, used in Turkish folk music. The sori and koron accidentals are microtonal sharp and flat accidentals used in Iranian and Persian music.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="sharp"/>
         <xs:enumeration value="natural"/>
         <xs:enumeration value="flat"/>
         <xs:enumeration value="double-sharp"/>
         <xs:enumeration value="sharp-sharp"/>
         <xs:enumeration value="flat-flat"/>
         <xs:enumeration value="natural-sharp"/>
         <xs:enumeration value="natural-flat"/>
         <xs:enumeration value="quarter-flat"/>
         <xs:enumeration value="quarter-sharp"/>
         <xs:enumeration value="three-quarters-flat"/>
         <xs:enumeration value="three-quarters-sharp"/>
         <xs:enumeration value="sharp-down"/>
         <xs:enumeration value="sharp-up"/>
         <xs:enumeration value="natural-down"/>
         <xs:enumeration value="natural-up"/>
         <xs:enumeration value="flat-down"/>
         <xs:enumeration value="flat-up"/>
         <xs:enumeration value="triple-sharp"/>
         <xs:enumeration value="triple-flat"/>
         <xs:enumeration value="slash-quarter-sharp"/>
         <xs:enumeration value="slash-sharp"/>
         <xs:enumeration value="slash-flat"/>
         <xs:enumeration value="double-slash-flat"/>
         <xs:enumeration value="sharp-1"/>
         <xs:enumeration value="sharp-2"/>
         <xs:enumeration value="sharp-3"/>
         <xs:enumeration value="sharp-5"/>
         <xs:enumeration value="flat-1"/>
         <xs:enumeration value="flat-2"/>
         <xs:enumeration value="flat-3"/>
         <xs:enumeration value="flat-4"/>
         <xs:enumeration value="sori"/>
         <xs:enumeration value="koron"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct AccidentalMarkAttributes;
        using AccidentalMarkAttributesPtr = std::shared_ptr<AccidentalMarkAttributes>;
        
        struct AccidentalMarkAttributes : public AttributesInterface
        {
        public:
            AccidentalMarkAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class AccidentalMark;
        using AccidentalMarkPtr = std::shared_ptr<AccidentalMark>;
        using AccidentalMarkUPtr = std::unique_ptr<AccidentalMark>;
        using AccidentalMarkSet = std::vector<AccidentalMarkPtr>;
        using AccidentalMarkSetIter = AccidentalMarkSet::iterator;
        using AccidentalMarkSetIterConst = AccidentalMarkSet::const_iterator;
        inline AccidentalMarkPtr makeAccidentalMark() { return std::make_shared<AccidentalMark>(); }
		inline AccidentalMarkPtr makeAccidentalMark( const t::AccidentalValue& value ) { return std::make_shared<AccidentalMark>( value ); }
		inline AccidentalMarkPtr makeAccidentalMark( t::AccidentalValue&& value ) { return std::make_shared<AccidentalMark>( std::move( value ) ); }
        class AccidentalMark : public ElementInterface
        {
        public:
            AccidentalMark();
            AccidentalMark( const t::AccidentalValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            AccidentalMarkAttributesPtr getAttributes() const;
            void setAttributes( const AccidentalMarkAttributesPtr& attributes );
            t::AccidentalValue getValue() const;
            void setValue( const t::AccidentalValue& value );
        private:
            t::AccidentalValue myValue;
            AccidentalMarkAttributesPtr myAttributes;
        };
        
        
        /**************** OtherNotation ****************
         4953
         <xs:element name="other-notation" type="other-notation"/>
         <xs:complexType name="other-notation">
         <xs:annotation>
         <xs:documentation>The other-notation type is used to define any notations not yet in the MusicXML format. This allows extended representation, though without application interoperability. It handles notations where more specific extension elements such as other-dynamics and other-technical are not appropriate.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="start-stop-single" use="required"/>
         <xs:attribute name="number" type="number-level" default="1"/>
         <xs:attributeGroup ref="print-object"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct OtherNotationAttributes;
        using OtherNotationAttributesPtr = std::shared_ptr<OtherNotationAttributes>;
        
        struct OtherNotationAttributes : public AttributesInterface
        {
        public:
            OtherNotationAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStopSingle type;
            t::NumberLevel number;
            t::YesNo printObject;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            const   bool hasType;
            bool hasNumber;
            bool hasPrintObject;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class OtherNotation;
        using OtherNotationPtr = std::shared_ptr<OtherNotation>;
        using OtherNotationUPtr = std::unique_ptr<OtherNotation>;
        using OtherNotationSet = std::vector<OtherNotationPtr>;
        using OtherNotationSetIter = OtherNotationSet::iterator;
        using OtherNotationSetIterConst = OtherNotationSet::const_iterator;
        inline OtherNotationPtr makeOtherNotation() { return std::make_shared<OtherNotation>(); }
		inline OtherNotationPtr makeOtherNotation( const t::XsString& value ) { return std::make_shared<OtherNotation>( value ); }
		inline OtherNotationPtr makeOtherNotation( t::XsString&& value ) { return std::make_shared<OtherNotation>( std::move( value ) ); }
        class OtherNotation : public ElementInterface
        {
        public:
            OtherNotation();
            OtherNotation( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            OtherNotationAttributesPtr getAttributes() const;
            void setAttributes( const OtherNotationAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            OtherNotationAttributesPtr myAttributes;
        };
        
        
        /**************** Type ****************
         5001
         <xs:element name="type" type="note-type" minOccurs="0"/>
         <xs:complexType name="note-type">
         <xs:annotation>
         <xs:documentation>The note-type type indicates the graphic note type. Values range from 256th to long. The size attribute indicates full, cue, or large size, with full the default for regular notes and cue the default for cue and grace notes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="note-type-value">
         <xs:attribute name="size" type="symbol-size"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="note-type-value">
         <xs:annotation>
         <xs:documentation>The note-type type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="1024th"/>
         <xs:enumeration value="512th"/>
         <xs:enumeration value="256th"/>
         <xs:enumeration value="128th"/>
         <xs:enumeration value="64th"/>
         <xs:enumeration value="32nd"/>
         <xs:enumeration value="16th"/>
         <xs:enumeration value="eighth"/>
         <xs:enumeration value="quarter"/>
         <xs:enumeration value="half"/>
         <xs:enumeration value="whole"/>
         <xs:enumeration value="breve"/>
         <xs:enumeration value="long"/>
         <xs:enumeration value="maxima"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct TypeAttributes;
        using TypeAttributesPtr = std::shared_ptr<TypeAttributes>;
        
        struct TypeAttributes : public AttributesInterface
        {
        public:
            TypeAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::SymbolSize size;
            bool hasSize;
        };
        
        class Type;
        using TypePtr = std::shared_ptr<Type>;
        using TypeUPtr = std::unique_ptr<Type>;
        using TypeSet = std::vector<TypePtr>;
        using TypeSetIter = TypeSet::iterator;
        using TypeSetIterConst = TypeSet::const_iterator;
        inline TypePtr makeType() { return std::make_shared<Type>(); }
		inline TypePtr makeType( const t::NoteTypeValue& value ) { return std::make_shared<Type>( value ); }
		inline TypePtr makeType( t::NoteTypeValue&& value ) { return std::make_shared<Type>( std::move( value ) ); }
        class Type : public ElementInterface
        {
        public:
            Type();
            Type( const t::NoteTypeValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TypeAttributesPtr getAttributes() const;
            void setAttributes( const TypeAttributesPtr& attributes );
            t::NoteTypeValue getValue() const;
            void setValue( const t::NoteTypeValue& value );
        private:
            t::NoteTypeValue myValue;
            TypeAttributesPtr myAttributes;
        };
        
        
        /**************** Accidental ****************
         5012
         <xs:element name="accidental" type="accidental" minOccurs="0"/>
         <xs:complexType name="accidental">
         <xs:annotation>
         <xs:documentation>The accidental type represents actual notated accidentals. Editorial and cautionary indications are indicated by attributes. Values for these attributes are "no" if not present. Specific graphic display such as parentheses, brackets, and size are controlled by the level-display attribute group.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="accidental-value">
         <xs:attribute name="cautionary" type="yes-no"/>
         <xs:attribute name="editorial" type="yes-no"/>
         <xs:attributeGroup ref="level-display"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="accidental-value">
         <xs:annotation>
         <xs:documentation>The accidental-value type represents notated accidentals supported by MusicXML. In the MusicXML 2.0 DTD this was a string with values that could be included. The XSD strengthens the data typing to an enumerated list. The quarter- and three-quarters- accidentals are Tartini-style quarter-tone accidentals. The -down and -up accidentals are quarter-tone accidentals that include arrows pointing down or up. The slash- accidentals are used in Turkish classical music. The numbered sharp and flat accidentals are superscripted versions of the accidental signs, used in Turkish folk music. The sori and koron accidentals are microtonal sharp and flat accidentals used in Iranian and Persian music.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="sharp"/>
         <xs:enumeration value="natural"/>
         <xs:enumeration value="flat"/>
         <xs:enumeration value="double-sharp"/>
         <xs:enumeration value="sharp-sharp"/>
         <xs:enumeration value="flat-flat"/>
         <xs:enumeration value="natural-sharp"/>
         <xs:enumeration value="natural-flat"/>
         <xs:enumeration value="quarter-flat"/>
         <xs:enumeration value="quarter-sharp"/>
         <xs:enumeration value="three-quarters-flat"/>
         <xs:enumeration value="three-quarters-sharp"/>
         <xs:enumeration value="sharp-down"/>
         <xs:enumeration value="sharp-up"/>
         <xs:enumeration value="natural-down"/>
         <xs:enumeration value="natural-up"/>
         <xs:enumeration value="flat-down"/>
         <xs:enumeration value="flat-up"/>
         <xs:enumeration value="triple-sharp"/>
         <xs:enumeration value="triple-flat"/>
         <xs:enumeration value="slash-quarter-sharp"/>
         <xs:enumeration value="slash-sharp"/>
         <xs:enumeration value="slash-flat"/>
         <xs:enumeration value="double-slash-flat"/>
         <xs:enumeration value="sharp-1"/>
         <xs:enumeration value="sharp-2"/>
         <xs:enumeration value="sharp-3"/>
         <xs:enumeration value="sharp-5"/>
         <xs:enumeration value="flat-1"/>
         <xs:enumeration value="flat-2"/>
         <xs:enumeration value="flat-3"/>
         <xs:enumeration value="flat-4"/>
         <xs:enumeration value="sori"/>
         <xs:enumeration value="koron"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct AccidentalAttributes;
        using AccidentalAttributesPtr = std::shared_ptr<AccidentalAttributes>;
        
        struct AccidentalAttributes : public AttributesInterface
        {
        public:
            AccidentalAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo cautionary;
            t::YesNo editorial;
            t::YesNo parentheses;
            t::YesNo bracket;
            t::SymbolSize size;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasCautionary;
            bool hasEditorial;
            bool hasParentheses;
            bool hasBracket;
            bool hasSize;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class Accidental;
        using AccidentalPtr = std::shared_ptr<Accidental>;
        using AccidentalUPtr = std::unique_ptr<Accidental>;
        using AccidentalSet = std::vector<AccidentalPtr>;
        using AccidentalSetIter = AccidentalSet::iterator;
        using AccidentalSetIterConst = AccidentalSet::const_iterator;
        inline AccidentalPtr makeAccidental() { return std::make_shared<Accidental>(); }
		inline AccidentalPtr makeAccidental( const t::AccidentalValue& value ) { return std::make_shared<Accidental>( value ); }
		inline AccidentalPtr makeAccidental( t::AccidentalValue&& value ) { return std::make_shared<Accidental>( std::move( value ) ); }
        class Accidental : public ElementInterface
        {
        public:
            Accidental();
            Accidental( const t::AccidentalValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            AccidentalAttributesPtr getAttributes() const;
            void setAttributes( const AccidentalAttributesPtr& attributes );
            t::AccidentalValue getValue() const;
            void setValue( const t::AccidentalValue& value );
        private:
            t::AccidentalValue myValue;
            AccidentalAttributesPtr myAttributes;
        };
        
        
        /**************** Stem ****************
         5020
         <xs:element name="stem" type="stem" minOccurs="0"/>
         <xs:complexType name="stem">
         <xs:annotation>
         <xs:documentation>Stems can be down, up, none, or double. For down and up stems, the position attributes can be used to specify stem length. The relative values specify the end of the stem relative to the program default. Default values specify an absolute end stem position. Negative values of relative-y that would flip a stem instead of shortening it are ignored. A stem element associated with a rest refers to a stemlet.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="stem-value">
         <xs:attributeGroup ref="y-position"/>
         <xs:attributeGroup ref="color"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="stem-value">
         <xs:annotation>
         <xs:documentation>The stem type represents the notated stem direction.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="down"/>
         <xs:enumeration value="up"/>
         <xs:enumeration value="double"/>
         <xs:enumeration value="none"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct StemAttributes;
        using StemAttributesPtr = std::shared_ptr<StemAttributes>;
        
        struct StemAttributes : public AttributesInterface
        {
        public:
            StemAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
        };
        
        class Stem;
        using StemPtr = std::shared_ptr<Stem>;
        using StemUPtr = std::unique_ptr<Stem>;
        using StemSet = std::vector<StemPtr>;
        using StemSetIter = StemSet::iterator;
        using StemSetIterConst = StemSet::const_iterator;
        inline StemPtr makeStem() { return std::make_shared<Stem>(); }
		inline StemPtr makeStem( const t::StemValue& value ) { return std::make_shared<Stem>( value ); }
		inline StemPtr makeStem( t::StemValue&& value ) { return std::make_shared<Stem>( std::move( value ) ); }
        class Stem : public ElementInterface
        {
        public:
            Stem();
            Stem( const t::StemValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            StemAttributesPtr getAttributes() const;
            void setAttributes( const StemAttributesPtr& attributes );
            t::StemValue getValue() const;
            void setValue( const t::StemValue& value );
        private:
            t::StemValue myValue;
            StemAttributesPtr myAttributes;
        };
        
        
        /**************** Notehead ****************
         5024
         <xs:element name="notehead" type="notehead" minOccurs="0"/>
         <xs:complexType name="notehead">
         <xs:annotation>
         <xs:documentation>The notehead element indicates shapes other than the open and closed ovals associated with note durations.
         
         For the enclosed shapes, the default is to be hollow for half notes and longer, and filled otherwise. The filled attribute can be set to change this if needed.
         
         If the parentheses attribute is set to yes, the notehead is parenthesized. It is no by default.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="notehead-value">
         <xs:attribute name="filled" type="yes-no"/>
         <xs:attribute name="parentheses" type="yes-no"/>
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="notehead-value">
         <xs:annotation>
         <xs:documentation>The notehead type indicates shapes other than the open and closed ovals associated with note durations. The values do, re, mi, fa, fa up, so, la, and ti correspond to Aikin's 7-shape system.  The fa up shape is typically used with upstems; the fa shape is typically used with downstems or no stems.
         
         The arrow shapes differ from triangle and inverted triangle by being centered on the stem. Slashed and back slashed notes include both the normal notehead and a slash. The triangle shape has the tip of the triangle pointing up; the inverted triangle shape has the tip of the triangle pointing down. The left triangle shape is a right triangle with the hypotenuse facing up and to the left.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="slash"/>
         <xs:enumeration value="triangle"/>
         <xs:enumeration value="diamond"/>
         <xs:enumeration value="square"/>
         <xs:enumeration value="cross"/>
         <xs:enumeration value="x"/>
         <xs:enumeration value="circle-x"/>
         <xs:enumeration value="inverted triangle"/>
         <xs:enumeration value="arrow down"/>
         <xs:enumeration value="arrow up"/>
         <xs:enumeration value="slashed"/>
         <xs:enumeration value="back slashed"/>
         <xs:enumeration value="normal"/>
         <xs:enumeration value="cluster"/>
         <xs:enumeration value="circle dot"/>
         <xs:enumeration value="left triangle"/>
         <xs:enumeration value="rectangle"/>
         <xs:enumeration value="none"/>
         <xs:enumeration value="do"/>
         <xs:enumeration value="re"/>
         <xs:enumeration value="mi"/>
         <xs:enumeration value="fa"/>
         <xs:enumeration value="fa up"/>
         <xs:enumeration value="so"/>
         <xs:enumeration value="la"/>
         <xs:enumeration value="ti"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct NoteheadAttributes;
        using NoteheadAttributesPtr = std::shared_ptr<NoteheadAttributes>;
        
        struct NoteheadAttributes : public AttributesInterface
        {
        public:
            NoteheadAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo filled;
            t::YesNo parentheses;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasFilled;
            bool hasParentheses;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class Notehead;
        using NoteheadPtr = std::shared_ptr<Notehead>;
        using NoteheadUPtr = std::unique_ptr<Notehead>;
        using NoteheadSet = std::vector<NoteheadPtr>;
        using NoteheadSetIter = NoteheadSet::iterator;
        using NoteheadSetIterConst = NoteheadSet::const_iterator;
        inline NoteheadPtr makeNotehead() { return std::make_shared<Notehead>(); }
		inline NoteheadPtr makeNotehead( const t::NoteheadValue& value ) { return std::make_shared<Notehead>( value ); }
		inline NoteheadPtr makeNotehead( t::NoteheadValue&& value ) { return std::make_shared<Notehead>( std::move( value ) ); }
        class Notehead : public ElementInterface
        {
        public:
            Notehead();
            Notehead( const t::NoteheadValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            NoteheadAttributesPtr getAttributes() const;
            void setAttributes( const NoteheadAttributesPtr& attributes );
            t::NoteheadValue getValue() const;
            void setValue( const t::NoteheadValue& value );
        private:
            t::NoteheadValue myValue;
            NoteheadAttributesPtr myAttributes;
        };
        
        
        /**************** Beam ****************
         5035
         <xs:element name="beam" type="beam" minOccurs="0" maxOccurs="8"/>
         <xs:complexType name="beam">
         <xs:annotation>
         <xs:documentation>Beam values include begin, continue, end, forward hook, and backward hook. Up to eight concurrent beams are available to cover up to 1024th notes. Each beam in a note is represented with a separate beam element, starting with the eighth note beam using a number attribute of 1.
         
         Note that the beam number does not distinguish sets of beams that overlap, as it does for slur and other elements. Beaming groups are distinguished by being in different voices and/or the presence or absence of grace and cue elements.
         
         Beams that have a begin value can also have a fan attribute to indicate accelerandos and ritardandos using fanned beams. The fan attribute may also be used with a continue value if the fanning direction changes on that note. The value is "none" if not specified.
         
         The repeater attribute has been deprecated in MusicXML 3.0. Formerly used for tremolos, it needs to be specified with a "yes" value for each beam using it.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="beam-value">
         <xs:attribute name="number" type="beam-level" default="1"/>
         <xs:attribute name="repeater" type="yes-no"/>
         <xs:attribute name="fan" type="fan"/>
         <xs:attributeGroup ref="color"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="beam-value">
         <xs:annotation>
         <xs:documentation>The beam-value type represents the type of beam associated with each of 8 beam levels (up to 1024th notes) available for each note.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="begin"/>
         <xs:enumeration value="continue"/>
         <xs:enumeration value="end"/>
         <xs:enumeration value="forward hook"/>
         <xs:enumeration value="backward hook"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct BeamAttributes;
        using BeamAttributesPtr = std::shared_ptr<BeamAttributes>;
        
        struct BeamAttributes : public AttributesInterface
        {
        public:
            BeamAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::BeamLevel number;
            t::YesNo repeater;
            t::Fan fan;
            bool hasNumber;
            bool hasRepeater;
            bool hasFan;
        };
        
        class Beam;
        using BeamPtr = std::shared_ptr<Beam>;
        using BeamUPtr = std::unique_ptr<Beam>;
        using BeamSet = std::vector<BeamPtr>;
        using BeamSetIter = BeamSet::iterator;
        using BeamSetIterConst = BeamSet::const_iterator;
        inline BeamPtr makeBeam() { return std::make_shared<Beam>(); }
		inline BeamPtr makeBeam( const t::BeamValue& value ) { return std::make_shared<Beam>( value ); }
		inline BeamPtr makeBeam( t::BeamValue&& value ) { return std::make_shared<Beam>( std::move( value ) ); }
        class Beam : public ElementInterface
        {
        public:
            Beam();
            Beam( const t::BeamValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BeamAttributesPtr getAttributes() const;
            void setAttributes( const BeamAttributesPtr& attributes );
            t::BeamValue getValue() const;
            void setValue( const t::BeamValue& value );
        private:
            t::BeamValue myValue;
            BeamAttributesPtr myAttributes;
        };
        
        
        /**************** DisplayText ****************
         2517, 5114
         <xs:element name="display-text" type="formatted-text"/>
         <xs:complexType name="formatted-text">
         <xs:annotation>
         <xs:documentation>The formatted-text type represents a text element with text-formatting attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="text-formatting"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        
        
        /**************** Tremolo ****************
         5181
         <xs:element name="tremolo" type="tremolo"/>
         <xs:complexType name="tremolo">
         <xs:annotation>
         <xs:documentation>The tremolo ornament can be used to indicate either single-note or double-note tremolos. Single-note tremolos use the single type, while double-note tremolos use the start and stop types. The default is "single" for compatibility with Version 1.1. The text of the element indicates the number of tremolo marks and is an integer from 0 to 8. Note that the number of attached beams is not included in this value, but is represented separately using the beam element.
         
         When using double-note tremolos, the duration of each note in the tremolo should correspond to half of the notated type value. A time-modification element should also be added with an actual-notes value of 2 and a normal-notes value of 1. If used within a tuplet, this 2/1 ratio should be multiplied by the existing tuplet ratio.
         
         Using repeater beams for indicating tremolos is deprecated as of MusicXML 3.0.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="tremolo-marks">
         <xs:attribute name="type" type="start-stop-single" default="single"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="tremolo-marks">
         <xs:annotation>
         <xs:documentation>The number of tremolo marks is represented by a number from 0 to 8: the same as beam-level with 0 added.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer">
         <xs:minInclusive value="0"/>
         <xs:maxInclusive value="8"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct TremoloAttributes;
        using TremoloAttributesPtr = std::shared_ptr<TremoloAttributes>;
        
        struct TremoloAttributes : public AttributesInterface
        {
        public:
            TremoloAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStopSingle type;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasType;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class Tremolo;
        using TremoloPtr = std::shared_ptr<Tremolo>;
        using TremoloUPtr = std::unique_ptr<Tremolo>;
        using TremoloSet = std::vector<TremoloPtr>;
        using TremoloSetIter = TremoloSet::iterator;
        using TremoloSetIterConst = TremoloSet::const_iterator;
        inline TremoloPtr makeTremolo() { return std::make_shared<Tremolo>(); }
		inline TremoloPtr makeTremolo( const t::TremoloMarks& value ) { return std::make_shared<Tremolo>( value ); }
		inline TremoloPtr makeTremolo( t::TremoloMarks&& value ) { return std::make_shared<Tremolo>( std::move( value ) ); }
        class Tremolo : public ElementInterface
        {
        public:
            Tremolo();
            Tremolo( const t::TremoloMarks& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TremoloAttributesPtr getAttributes() const;
            void setAttributes( const TremoloAttributesPtr& attributes );
            t::TremoloMarks getValue() const;
            void setValue( const t::TremoloMarks& value );
        private:
            t::TremoloMarks myValue;
            TremoloAttributesPtr myAttributes;
        };
        
        
        /**************** OtherOrnament ****************
         5184
         <xs:element name="other-ornament" type="placement-text">   <xs:annotation>     <xs:documentation>The other-ornament element is used to define any ornaments not yet in the MusicXML format. This allows extended representation though without application interoperability.</xs:documentation>    </xs:annotation></xs:element>
         <xs:complexType name="placement-text">
         <xs:annotation>
         <xs:documentation>The placement-text type represents a text element with print-style and placement attribute groups.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct OtherOrnamentAttributes;
        using OtherOrnamentAttributesPtr = std::shared_ptr<OtherOrnamentAttributes>;
        
        struct OtherOrnamentAttributes : public AttributesInterface
        {
        public:
            OtherOrnamentAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class OtherOrnament;
        using OtherOrnamentPtr = std::shared_ptr<OtherOrnament>;
        using OtherOrnamentUPtr = std::unique_ptr<OtherOrnament>;
        using OtherOrnamentSet = std::vector<OtherOrnamentPtr>;
        using OtherOrnamentSetIter = OtherOrnamentSet::iterator;
        using OtherOrnamentSetIterConst = OtherOrnamentSet::const_iterator;
        inline OtherOrnamentPtr makeOtherOrnament() { return std::make_shared<OtherOrnament>(); }
		inline OtherOrnamentPtr makeOtherOrnament( const t::XsString& value ) { return std::make_shared<OtherOrnament>( value ); }
		inline OtherOrnamentPtr makeOtherOrnament( t::XsString&& value ) { return std::make_shared<OtherOrnament>( std::move( value ) ); }
        class OtherOrnament : public ElementInterface
        {
        public:
            OtherOrnament();
            OtherOrnament( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            OtherOrnamentAttributesPtr getAttributes() const;
            void setAttributes( const OtherOrnamentAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            OtherOrnamentAttributesPtr myAttributes;
        };
        
        
        /**************** AccidentalMark ****************
         4950, 5189
         <xs:element name="accidental-mark" type="accidental-mark" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="accidental-mark">
         <xs:annotation>
         <xs:documentation>An accidental-mark can be used as a separate notation or as part of an ornament. When used in an ornament, position and placement are relative to the ornament, not relative to the note.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="accidental-value">
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="accidental-value">
         <xs:annotation>
         <xs:documentation>The accidental-value type represents notated accidentals supported by MusicXML. In the MusicXML 2.0 DTD this was a string with values that could be included. The XSD strengthens the data typing to an enumerated list. The quarter- and three-quarters- accidentals are Tartini-style quarter-tone accidentals. The -down and -up accidentals are quarter-tone accidentals that include arrows pointing down or up. The slash- accidentals are used in Turkish classical music. The numbered sharp and flat accidentals are superscripted versions of the accidental signs, used in Turkish folk music. The sori and koron accidentals are microtonal sharp and flat accidentals used in Iranian and Persian music.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="sharp"/>
         <xs:enumeration value="natural"/>
         <xs:enumeration value="flat"/>
         <xs:enumeration value="double-sharp"/>
         <xs:enumeration value="sharp-sharp"/>
         <xs:enumeration value="flat-flat"/>
         <xs:enumeration value="natural-sharp"/>
         <xs:enumeration value="natural-flat"/>
         <xs:enumeration value="quarter-flat"/>
         <xs:enumeration value="quarter-sharp"/>
         <xs:enumeration value="three-quarters-flat"/>
         <xs:enumeration value="three-quarters-sharp"/>
         <xs:enumeration value="sharp-down"/>
         <xs:enumeration value="sharp-up"/>
         <xs:enumeration value="natural-down"/>
         <xs:enumeration value="natural-up"/>
         <xs:enumeration value="flat-down"/>
         <xs:enumeration value="flat-up"/>
         <xs:enumeration value="triple-sharp"/>
         <xs:enumeration value="triple-flat"/>
         <xs:enumeration value="slash-quarter-sharp"/>
         <xs:enumeration value="slash-sharp"/>
         <xs:enumeration value="slash-flat"/>
         <xs:enumeration value="double-slash-flat"/>
         <xs:enumeration value="sharp-1"/>
         <xs:enumeration value="sharp-2"/>
         <xs:enumeration value="sharp-3"/>
         <xs:enumeration value="sharp-5"/>
         <xs:enumeration value="flat-1"/>
         <xs:enumeration value="flat-2"/>
         <xs:enumeration value="flat-3"/>
         <xs:enumeration value="flat-4"/>
         <xs:enumeration value="sori"/>
         <xs:enumeration value="koron"/>
         </xs:restriction>
         </xs:simpleType>
         */
        
        
        /**************** Fingering ****************
         3487, 5362
         <xs:element name="fingering" type="fingering"/>
         <xs:complexType name="fingering">
         <xs:annotation>
         <xs:documentation>Fingering is typically indicated 1,2,3,4,5. Multiple fingerings may be given, typically to substitute fingerings in the middle of a note. The substitution and alternate values are "no" if the attribute is not present. For guitar and other fretted instruments, the fingering element represents the fretting finger; the pluck element represents the plucking finger.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="substitution" type="yes-no"/>
         <xs:attribute name="alternate" type="yes-no"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        
        /**************** Pluck ****************
         5365
         <xs:element name="pluck" type="placement-text">    <xs:annotation>     <xs:documentation>The pluck element is used to specify the plucking fingering on a fretted instrument where the fingering element refers to the fretting fingering. Typical values are p i m a for pulgar/thumb indicio/index medio/middle and anular/ring fingers.</xs:documentation>  </xs:annotation></xs:element>
         <xs:complexType name="placement-text">
         <xs:annotation>
         <xs:documentation>The placement-text type represents a text element with print-style and placement attribute groups.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct PluckAttributes;
        using PluckAttributesPtr = std::shared_ptr<PluckAttributes>;
        
        struct PluckAttributes : public AttributesInterface
        {
        public:
            PluckAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class Pluck;
        using PluckPtr = std::shared_ptr<Pluck>;
        using PluckUPtr = std::unique_ptr<Pluck>;
        using PluckSet = std::vector<PluckPtr>;
        using PluckSetIter = PluckSet::iterator;
        using PluckSetIterConst = PluckSet::const_iterator;
        inline PluckPtr makePluck() { return std::make_shared<Pluck>(); }
		inline PluckPtr makePluck( const t::XsString& value ) { return std::make_shared<Pluck>( value ); }
		inline PluckPtr makePluck( t::XsString&& value ) { return std::make_shared<Pluck>( std::move( value ) ); }
        class Pluck : public ElementInterface
        {
        public:
            Pluck();
            Pluck( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PluckAttributesPtr getAttributes() const;
            void setAttributes( const PluckAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            PluckAttributesPtr myAttributes;
        };
        
        
        /**************** Fret ****************
         3484, 5390
         <xs:element name="fret" type="fret"/>
         <xs:complexType name="fret">
         <xs:annotation>
         <xs:documentation>The fret element is used with tablature notation and chord diagrams. Fret numbers start with 0 for an open string and 1 for the first fret.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:nonNegativeInteger">
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         */
        
        /**************** HammerOn ****************
         5396
         <xs:element name="hammer-on" type="hammer-on-pull-off"/>
         <xs:complexType name="hammer-on-pull-off">
         <xs:annotation>
         <xs:documentation>The hammer-on and pull-off elements are used in guitar and fretted instrument notation. Since a single slur can be marked over many notes, the hammer-on and pull-off elements are separate so the individual pair of notes can be specified. The element content can be used to specify how the hammer-on or pull-off should be notated. An empty element leaves this choice up to the application.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="number" type="number-level" default="1"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct HammerOnAttributes;
        using HammerOnAttributesPtr = std::shared_ptr<HammerOnAttributes>;
        
        struct HammerOnAttributes : public AttributesInterface
        {
        public:
            HammerOnAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            t::NumberLevel number;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            const   bool hasType;
            bool hasNumber;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class HammerOn;
        using HammerOnPtr = std::shared_ptr<HammerOn>;
        using HammerOnUPtr = std::unique_ptr<HammerOn>;
        using HammerOnSet = std::vector<HammerOnPtr>;
        using HammerOnSetIter = HammerOnSet::iterator;
        using HammerOnSetIterConst = HammerOnSet::const_iterator;
        inline HammerOnPtr makeHammerOn() { return std::make_shared<HammerOn>(); }
		inline HammerOnPtr makeHammerOn( const t::XsString& value ) { return std::make_shared<HammerOn>( value ); }
		inline HammerOnPtr makeHammerOn( t::XsString&& value ) { return std::make_shared<HammerOn>( std::move( value ) ); }
        class HammerOn : public ElementInterface
        {
        public:
            HammerOn();
            HammerOn( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            HammerOnAttributesPtr getAttributes() const;
            void setAttributes( const HammerOnAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            HammerOnAttributesPtr myAttributes;
        };
        
        
        /**************** PullOff ****************
         5399
         <xs:element name="pull-off" type="hammer-on-pull-off"/>
         <xs:complexType name="hammer-on-pull-off">
         <xs:annotation>
         <xs:documentation>The hammer-on and pull-off elements are used in guitar and fretted instrument notation. Since a single slur can be marked over many notes, the hammer-on and pull-off elements are separate so the individual pair of notes can be specified. The element content can be used to specify how the hammer-on or pull-off should be notated. An empty element leaves this choice up to the application.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="number" type="number-level" default="1"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct PullOffAttributes;
        using PullOffAttributesPtr = std::shared_ptr<PullOffAttributes>;
        
        struct PullOffAttributes : public AttributesInterface
        {
        public:
            PullOffAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            t::NumberLevel number;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            const   bool hasType;
            bool hasNumber;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class PullOff;
        using PullOffPtr = std::shared_ptr<PullOff>;
        using PullOffUPtr = std::unique_ptr<PullOff>;
        using PullOffSet = std::vector<PullOffPtr>;
        using PullOffSetIter = PullOffSet::iterator;
        using PullOffSetIterConst = PullOffSet::const_iterator;
        inline PullOffPtr makePullOff() { return std::make_shared<PullOff>(); }
		inline PullOffPtr makePullOff( const t::XsString& value ) { return std::make_shared<PullOff>( value ); }
		inline PullOffPtr makePullOff( t::XsString&& value ) { return std::make_shared<PullOff>( std::move( value ) ); }
        class PullOff : public ElementInterface
        {
        public:
            PullOff();
            PullOff( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PullOffAttributesPtr getAttributes() const;
            void setAttributes( const PullOffAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            PullOffAttributesPtr myAttributes;
        };
        
        
        /**************** Tap ****************
         5405
         <xs:element name="tap" type="placement-text">  <xs:annotation>     <xs:documentation>The tap element indicates a tap on the fretboard. The element content allows specification of the notation; + and T are common choices. If empty the display is application-specific.</xs:documentation>  </xs:annotation></xs:element>
         <xs:complexType name="placement-text">
         <xs:annotation>
         <xs:documentation>The placement-text type represents a text element with print-style and placement attribute groups.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct TapAttributes;
        using TapAttributesPtr = std::shared_ptr<TapAttributes>;
        
        struct TapAttributes : public AttributesInterface
        {
        public:
            TapAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class Tap;
        using TapPtr = std::shared_ptr<Tap>;
        using TapUPtr = std::unique_ptr<Tap>;
        using TapSet = std::vector<TapPtr>;
        using TapSetIter = TapSet::iterator;
        using TapSetIterConst = TapSet::const_iterator;
        inline TapPtr makeTap() { return std::make_shared<Tap>(); }
		inline TapPtr makeTap( const t::XsString& value ) { return std::make_shared<Tap>( value ); }
		inline TapPtr makeTap( t::XsString&& value ) { return std::make_shared<Tap>( std::move( value ) ); }
        class Tap : public ElementInterface
        {
        public:
            Tap();
            Tap( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TapAttributesPtr getAttributes() const;
            void setAttributes( const TapAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            TapAttributesPtr myAttributes;
        };
        
        
        /**************** Handbell ****************
         5427
         <xs:element name="handbell" type="handbell"/>
         <xs:complexType name="handbell">
         <xs:annotation>
         <xs:documentation>The handbell element represents notation for various techniques used in handbell and handchime music.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="handbell-value">
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="handbell-value">
         <xs:annotation>
         <xs:documentation>The handbell-value type represents the type of handbell technique being notated.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="damp"/>
         <xs:enumeration value="echo"/>
         <xs:enumeration value="gyro"/>
         <xs:enumeration value="hand martellato"/>
         <xs:enumeration value="mallet lift"/>
         <xs:enumeration value="mallet table"/>
         <xs:enumeration value="martellato"/>
         <xs:enumeration value="martellato lift"/>
         <xs:enumeration value="muted martellato"/>
         <xs:enumeration value="pluck lift"/>
         <xs:enumeration value="swing"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct HandbellAttributes;
        using HandbellAttributesPtr = std::shared_ptr<HandbellAttributes>;
        
        struct HandbellAttributes : public AttributesInterface
        {
        public:
            HandbellAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class Handbell;
        using HandbellPtr = std::shared_ptr<Handbell>;
        using HandbellUPtr = std::unique_ptr<Handbell>;
        using HandbellSet = std::vector<HandbellPtr>;
        using HandbellSetIter = HandbellSet::iterator;
        using HandbellSetIterConst = HandbellSet::const_iterator;
        inline HandbellPtr makeHandbell() { return std::make_shared<Handbell>(); }
		inline HandbellPtr makeHandbell( const t::HandbellValue& value ) { return std::make_shared<Handbell>( value ); }
		inline HandbellPtr makeHandbell( t::HandbellValue&& value ) { return std::make_shared<Handbell>( std::move( value ) ); }
        class Handbell : public ElementInterface
        {
        public:
            Handbell();
            Handbell( const t::HandbellValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            HandbellAttributesPtr getAttributes() const;
            void setAttributes( const HandbellAttributesPtr& attributes );
            t::HandbellValue getValue() const;
            void setValue( const t::HandbellValue& value );
        private:
            t::HandbellValue myValue;
            HandbellAttributesPtr myAttributes;
        };
        
        
        /**************** OtherTechnical ****************
         5430
         <xs:element name="other-technical" type="placement-text">  <xs:annotation>     <xs:documentation>The other-technical element is used to define any technical indications not yet in the MusicXML format. This allows extended representation though without application interoperability.</xs:documentation>   </xs:annotation></xs:element>
         <xs:complexType name="placement-text">
         <xs:annotation>
         <xs:documentation>The placement-text type represents a text element with print-style and placement attribute groups.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct OtherTechnicalAttributes;
        using OtherTechnicalAttributesPtr = std::shared_ptr<OtherTechnicalAttributes>;
        
        struct OtherTechnicalAttributes : public AttributesInterface
        {
        public:
            OtherTechnicalAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        class OtherTechnical;
        using OtherTechnicalPtr = std::shared_ptr<OtherTechnical>;
        using OtherTechnicalUPtr = std::unique_ptr<OtherTechnical>;
        using OtherTechnicalSet = std::vector<OtherTechnicalPtr>;
        using OtherTechnicalSetIter = OtherTechnicalSet::iterator;
        using OtherTechnicalSetIterConst = OtherTechnicalSet::const_iterator;
        inline OtherTechnicalPtr makeOtherTechnical() { return std::make_shared<OtherTechnical>(); }
		inline OtherTechnicalPtr makeOtherTechnical( const t::XsString& value ) { return std::make_shared<OtherTechnical>( value ); }
		inline OtherTechnicalPtr makeOtherTechnical( t::XsString&& value ) { return std::make_shared<OtherTechnical>( std::move( value ) ); }
        class OtherTechnical : public ElementInterface
        {
        public:
            OtherTechnical();
            OtherTechnical( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            OtherTechnicalAttributesPtr getAttributes() const;
            void setAttributes( const OtherTechnicalAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            OtherTechnicalAttributesPtr myAttributes;
        };
        
        
        /**************** TupletNumber ****************
         5620
         <xs:element name="tuplet-number" type="tuplet-number" minOccurs="0"/>
         <xs:complexType name="tuplet-number">
         <xs:annotation>
         <xs:documentation>The tuplet-number type indicates the number of notes for this portion of the tuplet.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:nonNegativeInteger">
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         */
        struct TupletNumberAttributes;
        using TupletNumberAttributesPtr = std::shared_ptr<TupletNumberAttributes>;
        
        struct TupletNumberAttributes : public AttributesInterface
        {
        public:
            TupletNumberAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class TupletNumber;
        using TupletNumberPtr = std::shared_ptr<TupletNumber>;
        using TupletNumberUPtr = std::unique_ptr<TupletNumber>;
        using TupletNumberSet = std::vector<TupletNumberPtr>;
        using TupletNumberSetIter = TupletNumberSet::iterator;
        using TupletNumberSetIterConst = TupletNumberSet::const_iterator;
        inline TupletNumberPtr makeTupletNumber() { return std::make_shared<TupletNumber>(); }
		inline TupletNumberPtr makeTupletNumber( const t::NonNegativeInteger& value ) { return std::make_shared<TupletNumber>( value ); }
		inline TupletNumberPtr makeTupletNumber( t::NonNegativeInteger&& value ) { return std::make_shared<TupletNumber>( std::move( value ) ); }
        class TupletNumber : public ElementInterface
        {
        public:
            TupletNumber();
            TupletNumber( const t::NonNegativeInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TupletNumberAttributesPtr getAttributes() const;
            void setAttributes( const TupletNumberAttributesPtr& attributes );
            t::NonNegativeInteger getValue() const;
            void setValue( const t::NonNegativeInteger& value );
        private:
            t::NonNegativeInteger myValue;
            TupletNumberAttributesPtr myAttributes;
        };
        
        
        /**************** TupletType ****************
         5624
         <xs:element name="tuplet-type" type="tuplet-type" minOccurs="0"/>
         <xs:complexType name="tuplet-type">
         <xs:annotation>
         <xs:documentation>The tuplet-type type indicates the graphical note type of the notes for this portion of the tuplet.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="note-type-value">
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="note-type-value">
         <xs:annotation>
         <xs:documentation>The note-type type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="1024th"/>
         <xs:enumeration value="512th"/>
         <xs:enumeration value="256th"/>
         <xs:enumeration value="128th"/>
         <xs:enumeration value="64th"/>
         <xs:enumeration value="32nd"/>
         <xs:enumeration value="16th"/>
         <xs:enumeration value="eighth"/>
         <xs:enumeration value="quarter"/>
         <xs:enumeration value="half"/>
         <xs:enumeration value="whole"/>
         <xs:enumeration value="breve"/>
         <xs:enumeration value="long"/>
         <xs:enumeration value="maxima"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct TupletTypeAttributes;
        using TupletTypeAttributesPtr = std::shared_ptr<TupletTypeAttributes>;
        
        struct TupletTypeAttributes : public AttributesInterface
        {
        public:
            TupletTypeAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class TupletType;
        using TupletTypePtr = std::shared_ptr<TupletType>;
        using TupletTypeUPtr = std::unique_ptr<TupletType>;
        using TupletTypeSet = std::vector<TupletTypePtr>;
        using TupletTypeSetIter = TupletTypeSet::iterator;
        using TupletTypeSetIterConst = TupletTypeSet::const_iterator;
        inline TupletTypePtr makeTupletType() { return std::make_shared<TupletType>(); }
		inline TupletTypePtr makeTupletType( const t::NoteTypeValue& value ) { return std::make_shared<TupletType>( value ); }
		inline TupletTypePtr makeTupletType( t::NoteTypeValue&& value ) { return std::make_shared<TupletType>( std::move( value ) ); }
        class TupletType : public ElementInterface
        {
        public:
            TupletType();
            TupletType( const t::NoteTypeValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TupletTypeAttributesPtr getAttributes() const;
            void setAttributes( const TupletTypeAttributesPtr& attributes );
            t::NoteTypeValue getValue() const;
            void setValue( const t::NoteTypeValue& value );
        private:
            t::NoteTypeValue myValue;
            TupletTypeAttributesPtr myAttributes;
        };
        
        
        /**************** CreditWords ****************
         5677, 5693
         <xs:element name="credit-words" type="formatted-text"/>
         <xs:complexType name="formatted-text">
         <xs:annotation>
         <xs:documentation>The formatted-text type represents a text element with text-formatting attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="text-formatting"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct CreditWordsAttributes;
        using CreditWordsAttributesPtr = std::shared_ptr<CreditWordsAttributes>;
        
        struct CreditWordsAttributes : public AttributesInterface
        {
        public:
            CreditWordsAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::LeftCenterRight justify;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            t::NumberOfLines underline;
            t::NumberOfLines overline;
            t::NumberOfLines lineThrough;
            t::RotationDegrees rotation;
            t::NumberOrNormal letterSpacing;
            t::NumberOrNormal lineHeight;
            t::XmlLang lang;
            t::XmlSpace space;
            t::EnclosureShape enclosure;
            bool hasJustify;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
            bool hasUnderline;
            bool hasOverline;
            bool hasLineThrough;
            bool hasRotation;
            bool hasLetterSpacing;
            bool hasLineHeight;
            bool hasLang;
            bool hasSpace;
            bool hasEnclosure;
        };
        
        class CreditWords;
        using CreditWordsPtr = std::shared_ptr<CreditWords>;
        using CreditWordsUPtr = std::unique_ptr<CreditWords>;
        using CreditWordsSet = std::vector<CreditWordsPtr>;
        using CreditWordsSetIter = CreditWordsSet::iterator;
        using CreditWordsSetIterConst = CreditWordsSet::const_iterator;
        inline CreditWordsPtr makeCreditWords() { return std::make_shared<CreditWords>(); }
		inline CreditWordsPtr makeCreditWords( const t::XsString& value ) { return std::make_shared<CreditWords>( value ); }
		inline CreditWordsPtr makeCreditWords( t::XsString&& value ) { return std::make_shared<CreditWords>( std::move( value ) ); }
        class CreditWords : public ElementInterface
        {
        public:
            CreditWords();
            CreditWords( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            CreditWordsAttributesPtr getAttributes() const;
            void setAttributes( const CreditWordsAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            CreditWordsAttributesPtr myAttributes;
        };
        
        
        /**************** CreditWords ****************
         5677, 5693
         <xs:element name="credit-words" type="formatted-text"/>
         <xs:complexType name="formatted-text">
         <xs:annotation>
         <xs:documentation>The formatted-text type represents a text element with text-formatting attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="text-formatting"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        
        /**************** GroupName ****************
         5803
         <xs:element name="group-name" type="group-name" minOccurs="0"/>
         <xs:complexType name="group-name">
         <xs:annotation>
         <xs:documentation>The group-name type describes the name or abbreviation of a part-group element. Formatting attributes in the group-name type are deprecated in Version 2.0 in favor of the new group-name-display and group-abbreviation-display elements.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="group-name-text"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct GroupNameAttributes;
        using GroupNameAttributesPtr = std::shared_ptr<GroupNameAttributes>;
        
        struct GroupNameAttributes : public AttributesInterface
        {
        public:
            GroupNameAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight justify;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasJustify;
        };
        
        class GroupName;
        using GroupNamePtr = std::shared_ptr<GroupName>;
        using GroupNameUPtr = std::unique_ptr<GroupName>;
        using GroupNameSet = std::vector<GroupNamePtr>;
        using GroupNameSetIter = GroupNameSet::iterator;
        using GroupNameSetIterConst = GroupNameSet::const_iterator;
        inline GroupNamePtr makeGroupName() { return std::make_shared<GroupName>(); }
		inline GroupNamePtr makeGroupName( const t::XsString& value ) { return std::make_shared<GroupName>( value ); }
		inline GroupNamePtr makeGroupName( t::XsString&& value ) { return std::make_shared<GroupName>( std::move( value ) ); }
        class GroupName : public ElementInterface
        {
        public:
            GroupName();
            GroupName( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            GroupNameAttributesPtr getAttributes() const;
            void setAttributes( const GroupNameAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            GroupNameAttributesPtr myAttributes;
        };
        
        
        /**************** GroupAbbreviation ****************
         5813
         <xs:element name="group-abbreviation" type="group-name" minOccurs="0"/>
         <xs:complexType name="group-name">
         <xs:annotation>
         <xs:documentation>The group-name type describes the name or abbreviation of a part-group element. Formatting attributes in the group-name type are deprecated in Version 2.0 in favor of the new group-name-display and group-abbreviation-display elements.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="group-name-text"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct GroupAbbreviationAttributes;
        using GroupAbbreviationAttributesPtr = std::shared_ptr<GroupAbbreviationAttributes>;
        
        struct GroupAbbreviationAttributes : public AttributesInterface
        {
        public:
            GroupAbbreviationAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight justify;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasJustify;
        };
        
        class GroupAbbreviation;
        using GroupAbbreviationPtr = std::shared_ptr<GroupAbbreviation>;
        using GroupAbbreviationUPtr = std::unique_ptr<GroupAbbreviation>;
        using GroupAbbreviationSet = std::vector<GroupAbbreviationPtr>;
        using GroupAbbreviationSetIter = GroupAbbreviationSet::iterator;
        using GroupAbbreviationSetIterConst = GroupAbbreviationSet::const_iterator;
        inline GroupAbbreviationPtr makeGroupAbbreviation() { return std::make_shared<GroupAbbreviation>(); }
		inline GroupAbbreviationPtr makeGroupAbbreviation( const t::XsString& value ) { return std::make_shared<GroupAbbreviation>( value ); }
		inline GroupAbbreviationPtr makeGroupAbbreviation( t::XsString&& value ) { return std::make_shared<GroupAbbreviation>( std::move( value ) ); }
        class GroupAbbreviation : public ElementInterface
        {
        public:
            GroupAbbreviation();
            GroupAbbreviation( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            GroupAbbreviationAttributesPtr getAttributes() const;
            void setAttributes( const GroupAbbreviationAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            GroupAbbreviationAttributesPtr myAttributes;
        };
        
        
        /**************** GroupSymbol ****************
         5823
         <xs:element name="group-symbol" type="group-symbol" minOccurs="0"/>
         <xs:complexType name="group-symbol">
         <xs:annotation>
         <xs:documentation>The group-symbol type indicates how the symbol for a group is indicated in the score.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="group-symbol-value">
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="color"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="group-symbol-value">
         <xs:annotation>
         <xs:documentation>The group-symbol-value type indicates how the symbol for a group is indicated in the score. The default value is none.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="none"/>
         <xs:enumeration value="brace"/>
         <xs:enumeration value="line"/>
         <xs:enumeration value="bracket"/>
         <xs:enumeration value="square"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct GroupSymbolAttributes;
        using GroupSymbolAttributesPtr = std::shared_ptr<GroupSymbolAttributes>;
        
        struct GroupSymbolAttributes : public AttributesInterface
        {
        public:
            GroupSymbolAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
        };
        
        class GroupSymbol;
        using GroupSymbolPtr = std::shared_ptr<GroupSymbol>;
        using GroupSymbolUPtr = std::unique_ptr<GroupSymbol>;
        using GroupSymbolSet = std::vector<GroupSymbolPtr>;
        using GroupSymbolSetIter = GroupSymbolSet::iterator;
        using GroupSymbolSetIterConst = GroupSymbolSet::const_iterator;
        inline GroupSymbolPtr makeGroupSymbol() { return std::make_shared<GroupSymbol>(); }
		inline GroupSymbolPtr makeGroupSymbol( const t::GroupSymbolValue& value ) { return std::make_shared<GroupSymbol>( value ); }
		inline GroupSymbolPtr makeGroupSymbol( t::GroupSymbolValue&& value ) { return std::make_shared<GroupSymbol>( std::move( value ) ); }
        class GroupSymbol : public ElementInterface
        {
        public:
            GroupSymbol();
            GroupSymbol( const t::GroupSymbolValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            GroupSymbolAttributesPtr getAttributes() const;
            void setAttributes( const GroupSymbolAttributesPtr& attributes );
            t::GroupSymbolValue getValue() const;
            void setValue( const t::GroupSymbolValue& value );
        private:
            t::GroupSymbolValue myValue;
            GroupSymbolAttributesPtr myAttributes;
        };
        
        
        /**************** GroupBarline ****************
         5827
         <xs:element name="group-barline" type="group-barline" minOccurs="0"/>
         <xs:complexType name="group-barline">
         <xs:annotation>
         <xs:documentation>The group-barline type indicates if the group should have common barlines.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="group-barline-value">
         <xs:attributeGroup ref="color"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="group-barline-value">
         <xs:annotation>
         <xs:documentation>The group-barline-value type indicates if the group should have common barlines.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="yes"/>
         <xs:enumeration value="no"/>
         <xs:enumeration value="Mensurstrich"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct GroupBarlineAttributes;
        using GroupBarlineAttributesPtr = std::shared_ptr<GroupBarlineAttributes>;
        
        struct GroupBarlineAttributes : public AttributesInterface
        {
        public:
            GroupBarlineAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::Color color;
            bool hasColor;
        };
        
        class GroupBarline;
        using GroupBarlinePtr = std::shared_ptr<GroupBarline>;
        using GroupBarlineUPtr = std::unique_ptr<GroupBarline>;
        using GroupBarlineSet = std::vector<GroupBarlinePtr>;
        using GroupBarlineSetIter = GroupBarlineSet::iterator;
        using GroupBarlineSetIterConst = GroupBarlineSet::const_iterator;
        inline GroupBarlinePtr makeGroupBarline() { return std::make_shared<GroupBarline>(); }
		inline GroupBarlinePtr makeGroupBarline( const t::GroupBarlineValue& value ) { return std::make_shared<GroupBarline>( value ); }
		inline GroupBarlinePtr makeGroupBarline( t::GroupBarlineValue&& value ) { return std::make_shared<GroupBarline>( std::move( value ) ); }
        class GroupBarline : public ElementInterface
        {
        public:
            GroupBarline();
            GroupBarline( const t::GroupBarlineValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            GroupBarlineAttributesPtr getAttributes() const;
            void setAttributes( const GroupBarlineAttributesPtr& attributes );
            t::GroupBarlineValue getValue() const;
            void setValue( const t::GroupBarlineValue& value );
        private:
            t::GroupBarlineValue myValue;
            GroupBarlineAttributesPtr myAttributes;
        };
        
        
        /**************** PartName ****************
         5925
         <xs:element name="part-name" type="part-name"/>
         <xs:complexType name="part-name">
         <xs:annotation>
         <xs:documentation>The part-name type describes the name or abbreviation of a score-part element. Formatting attributes for the part-name element are deprecated in Version 2.0 in favor of the new part-name-display and part-abbreviation-display elements.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="part-name-text"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct PartNameAttributes;
        using PartNameAttributesPtr = std::shared_ptr<PartNameAttributes>;
        
        struct PartNameAttributes : public AttributesInterface
        {
        public:
            PartNameAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::YesNo printObject;
            t::LeftCenterRight justify;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPrintObject;
            bool hasJustify;
        };
        
        class PartName;
        using PartNamePtr = std::shared_ptr<PartName>;
        using PartNameUPtr = std::unique_ptr<PartName>;
        using PartNameSet = std::vector<PartNamePtr>;
        using PartNameSetIter = PartNameSet::iterator;
        using PartNameSetIterConst = PartNameSet::const_iterator;
        inline PartNamePtr makePartName() { return std::make_shared<PartName>(); }
		inline PartNamePtr makePartName( const t::XsString& value ) { return std::make_shared<PartName>( value ); }
		inline PartNamePtr makePartName( t::XsString&& value ) { return std::make_shared<PartName>( std::move( value ) ); }
        class PartName : public ElementInterface
        {
        public:
            PartName();
            PartName( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PartNameAttributesPtr getAttributes() const;
            void setAttributes( const PartNameAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            PartNameAttributesPtr myAttributes;
        };
        
        
        /**************** PartAbbreviation ****************
         5932
         <xs:element name="part-abbreviation" type="part-name" minOccurs="0"/>
         <xs:complexType name="part-name">
         <xs:annotation>
         <xs:documentation>The part-name type describes the name or abbreviation of a score-part element. Formatting attributes for the part-name element are deprecated in Version 2.0 in favor of the new part-name-display and part-abbreviation-display elements.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="part-name-text"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct PartAbbreviationAttributes;
        using PartAbbreviationAttributesPtr = std::shared_ptr<PartAbbreviationAttributes>;
        
        struct PartAbbreviationAttributes : public AttributesInterface
        {
        public:
            PartAbbreviationAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::YesNo printObject;
            t::LeftCenterRight justify;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPrintObject;
            bool hasJustify;
        };
        
        class PartAbbreviation;
        using PartAbbreviationPtr = std::shared_ptr<PartAbbreviation>;
        using PartAbbreviationUPtr = std::unique_ptr<PartAbbreviation>;
        using PartAbbreviationSet = std::vector<PartAbbreviationPtr>;
        using PartAbbreviationSetIter = PartAbbreviationSet::iterator;
        using PartAbbreviationSetIterConst = PartAbbreviationSet::const_iterator;
        inline PartAbbreviationPtr makePartAbbreviation() { return std::make_shared<PartAbbreviation>(); }
		inline PartAbbreviationPtr makePartAbbreviation( const t::XsString& value ) { return std::make_shared<PartAbbreviation>( value ); }
		inline PartAbbreviationPtr makePartAbbreviation( t::XsString&& value ) { return std::make_shared<PartAbbreviation>( std::move( value ) ); }
        class PartAbbreviation : public ElementInterface
        {
        public:
            PartAbbreviation();
            PartAbbreviation( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PartAbbreviationAttributesPtr getAttributes() const;
            void setAttributes( const PartAbbreviationAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            PartAbbreviationAttributesPtr myAttributes;
        };
        
        
        /**************** MidiDevice ****************
         3922, 5955
         <xs:element name="midi-device" type="midi-device" minOccurs="0"/>
         <xs:complexType name="midi-device">
         <xs:annotation>
         <xs:documentation>The midi-device type corresponds to the DeviceName meta event in Standard MIDI Files. The optional port attribute is a number from 1 to 16 that can be used with the unofficial MIDI port (or cable) meta event. Unlike the DeviceName meta event, there can be multiple midi-device elements per MusicXML part starting in MusicXML 3.0. The optional id attribute refers to the score-instrument assigned to this device. If missing, the device assignment affects all score-instrument elements in the score-part.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="port" type="midi-16"/>
         <xs:attribute name="id" type="xs:IDREF"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        
        /**************** Footnote ****************
         6049
         <xs:element name="footnote" type="formatted-text"/>
         <xs:complexType name="formatted-text">
         <xs:annotation>
         <xs:documentation>The formatted-text type represents a text element with text-formatting attributes.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="text-formatting"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct FootnoteAttributes;
        using FootnoteAttributesPtr = std::shared_ptr<FootnoteAttributes>;
        
        struct FootnoteAttributes : public AttributesInterface
        {
        public:
            FootnoteAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::LeftCenterRight justify;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            t::NumberOfLines underline;
            t::NumberOfLines overline;
            t::NumberOfLines lineThrough;
            t::RotationDegrees rotation;
            t::NumberOrNormal letterSpacing;
            t::NumberOrNormal lineHeight;
            t::XmlLang lang;
            t::XmlSpace space;
            t::EnclosureShape enclosure;
            bool hasJustify;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
            bool hasUnderline;
            bool hasOverline;
            bool hasLineThrough;
            bool hasRotation;
            bool hasLetterSpacing;
            bool hasLineHeight;
            bool hasLang;
            bool hasSpace;
            bool hasEnclosure;
        };
        
        class Footnote;
        using FootnotePtr = std::shared_ptr<Footnote>;
        using FootnoteUPtr = std::unique_ptr<Footnote>;
        using FootnoteSet = std::vector<FootnotePtr>;
        using FootnoteSetIter = FootnoteSet::iterator;
        using FootnoteSetIterConst = FootnoteSet::const_iterator;
        inline FootnotePtr makeFootnote() { return std::make_shared<Footnote>(); }
		inline FootnotePtr makeFootnote( const t::XsString& value ) { return std::make_shared<Footnote>( value ); }
		inline FootnotePtr makeFootnote( t::XsString&& value ) { return std::make_shared<Footnote>( std::move( value ) ); }
        class Footnote : public ElementInterface
        {
        public:
            Footnote();
            Footnote( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            FootnoteAttributesPtr getAttributes() const;
            void setAttributes( const FootnoteAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            FootnoteAttributesPtr myAttributes;
        };
        
        
        /**************** Level ****************
         6057
         <xs:element name="level" type="level"/>
         <xs:complexType name="level">
         <xs:annotation>
         <xs:documentation>The level type is used to specify editorial information for different MusicXML elements. If the reference attribute for the level element is yes, this indicates editorial information that is for display only and should not affect playback. For instance, a modern edition of older music may set reference="yes" on the attributes containing the music's original clef, key, and time signature. It is no by default.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attribute name="reference" type="yes-no"/>
         <xs:attributeGroup ref="level-display"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct LevelAttributes;
        using LevelAttributesPtr = std::shared_ptr<LevelAttributes>;
        
        struct LevelAttributes : public AttributesInterface
        {
        public:
            LevelAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo reference;
            t::YesNo parentheses;
            t::YesNo bracket;
            t::SymbolSize size;
            bool hasReference;
            bool hasParentheses;
            bool hasBracket;
            bool hasSize;
        };
        
        class Level;
        using LevelPtr = std::shared_ptr<Level>;
        using LevelUPtr = std::unique_ptr<Level>;
        using LevelSet = std::vector<LevelPtr>;
        using LevelSetIter = LevelSet::iterator;
        using LevelSetIterConst = LevelSet::const_iterator;
        inline LevelPtr makeLevel() { return std::make_shared<Level>(); }
		inline LevelPtr makeLevel( const t::XsString& value ) { return std::make_shared<Level>( value ); }
		inline LevelPtr makeLevel( t::XsString&& value ) { return std::make_shared<Level>( std::move( value ) ); }
        class Level : public ElementInterface
        {
        public:
            Level();
            Level( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            LevelAttributesPtr getAttributes() const;
            void setAttributes( const LevelAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            LevelAttributesPtr myAttributes;
        };
        
        
        /**************** Cancel ****************
         6157
         <xs:element name="cancel" type="cancel" minOccurs="0"/>
         <xs:complexType name="cancel">
         <xs:annotation>
         <xs:documentation>A cancel element indicates that the old key signature should be cancelled before the new one appears. This will always happen when changing to C major or A minor and need not be specified then. The cancel value matches the fifths value of the cancelled key signature (e.g., a cancel of -2 will provide an explicit cancellation for changing from B flat major to F major). The optional location attribute indicates whether the cancellation appears relative to the new key signature.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="fifths">
         <xs:attribute name="location" type="cancel-location"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="fifths">
         <xs:annotation>
         <xs:documentation>The fifths type represents the number of flats or sharps in a traditional key signature. Negative numbers are used for flats and positive numbers for sharps, reflecting the key's placement within the circle of fifths (hence the type name).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer"/>
         </xs:simpleType>
         */
        struct CancelAttributes;
        using CancelAttributesPtr = std::shared_ptr<CancelAttributes>;
        
        struct CancelAttributes : public AttributesInterface
        {
        public:
            CancelAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::CancelLocation location;
            bool hasLocation;
        };
        
        class Cancel;
        using CancelPtr = std::shared_ptr<Cancel>;
        using CancelUPtr = std::unique_ptr<Cancel>;
        using CancelSet = std::vector<CancelPtr>;
        using CancelSetIter = CancelSet::iterator;
        using CancelSetIterConst = CancelSet::const_iterator;
        inline CancelPtr makeCancel() { return std::make_shared<Cancel>(); }
		inline CancelPtr makeCancel( const t::FifthsValue& value ) { return std::make_shared<Cancel>( value ); }
		inline CancelPtr makeCancel( t::FifthsValue&& value ) { return std::make_shared<Cancel>( std::move( value ) ); }
        class Cancel : public ElementInterface
        {
        public:
            Cancel();
            Cancel( const t::FifthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            CancelAttributesPtr getAttributes() const;
            void setAttributes( const CancelAttributesPtr& attributes );
            t::FifthsValue getValue() const;
            void setValue( const t::FifthsValue& value );
        private:
            t::FifthsValue myValue;
            CancelAttributesPtr myAttributes;
        };
        
        
        /**************** Function ****************
         6194
         <xs:element name="function" type="style-text"> <xs:annotation>     <xs:documentation>The function element is used to represent classical functional harmony with an indication like I II III rather than C D E. It is relative to the key that is specified in the MusicXML encoding.</xs:documentation>   </xs:annotation></xs:element>
         <xs:complexType name="style-text">
         <xs:annotation>
         <xs:documentation>The style-text type represents a text element with a print-style attribute group.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:string"/>
         */
        struct FunctionAttributes;
        using FunctionAttributesPtr = std::shared_ptr<FunctionAttributes>;
        
        struct FunctionAttributes : public AttributesInterface
        {
        public:
            FunctionAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class Function;
        using FunctionPtr = std::shared_ptr<Function>;
        using FunctionUPtr = std::unique_ptr<Function>;
        using FunctionSet = std::vector<FunctionPtr>;
        using FunctionSetIter = FunctionSet::iterator;
        using FunctionSetIterConst = FunctionSet::const_iterator;
        inline FunctionPtr makeFunction() { return std::make_shared<Function>(); }
		inline FunctionPtr makeFunction( const t::XsString& value ) { return std::make_shared<Function>( value ); }
		inline FunctionPtr makeFunction( t::XsString&& value ) { return std::make_shared<Function>( std::move( value ) ); }
        class Function : public ElementInterface
        {
        public:
            Function();
            Function( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            FunctionAttributesPtr getAttributes() const;
            void setAttributes( const FunctionAttributesPtr& attributes );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
            FunctionAttributesPtr myAttributes;
        };
        
        
        /**************** Kind ****************
         6199
         <xs:element name="kind" type="kind"/>
         <xs:complexType name="kind">
         <xs:annotation>
         <xs:documentation>Kind indicates the type of chord. Degree elements can then add, subtract, or alter from these starting points
         
         The attributes are used to indicate the formatting of the symbol. Since the kind element is the constant in all the harmony-chord groups that can make up a polychord, many formatting attributes are here.
         
         The use-symbols attribute is yes if the kind should be represented when possible with harmony symbols rather than letters and numbers. These symbols include:
         
         major: a triangle, like Unicode 25B3
         minor: -, like Unicode 002D
         augmented: +, like Unicode 002B
         diminished: °, like Unicode 00B0
         half-diminished: ø, like Unicode 00F8
         
         For the major-minor kind, only the minor symbol is used when use-symbols is yes. The major symbol is set using the symbol attribute in the degree-value element. The corresponding degree-alter value will usually be 0 in this case.
         
         The text attribute describes how the kind should be spelled in a score. If use-symbols is yes, the value of the text attribute follows the symbol. The stack-degrees attribute is yes if the degree elements should be stacked above each other. The parentheses-degrees attribute is yes if all the degrees should be in parentheses. The bracket-degrees attribute is yes if all the degrees should be in a bracket. If not specified, these values are implementation-specific. The alignment attributes are for the entire harmony-chord group of which this kind element is a part.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="kind-value">
         <xs:attribute name="use-symbols" type="yes-no"/>
         <xs:attribute name="text" type="xs:token"/>
         <xs:attribute name="stack-degrees" type="yes-no"/>
         <xs:attribute name="parentheses-degrees" type="yes-no"/>
         <xs:attribute name="bracket-degrees" type="yes-no"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="halign"/>
         <xs:attributeGroup ref="valign"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="kind-value">
         <xs:annotation>
         <xs:documentation>A kind-value indicates the type of chord. Degree elements can then add, subtract, or alter from these starting points. Values include:
         
         Triads:
         major (major third, perfect fifth)
         minor (minor third, perfect fifth)
         augmented (major third, augmented fifth)
         diminished (minor third, diminished fifth)
         Sevenths:
         dominant (major triad, minor seventh)
         major-seventh (major triad, major seventh)
         minor-seventh (minor triad, minor seventh)
         diminished-seventh (diminished triad, diminished seventh)
         augmented-seventh (augmented triad, minor seventh)
         half-diminished (diminished triad, minor seventh)
         major-minor (minor triad, major seventh)
         Sixths:
         major-sixth (major triad, added sixth)
         minor-sixth (minor triad, added sixth)
         Ninths:
         dominant-ninth (dominant-seventh, major ninth)
         major-ninth (major-seventh, major ninth)
         minor-ninth (minor-seventh, major ninth)
         11ths (usually as the basis for alteration):
         dominant-11th (dominant-ninth, perfect 11th)
         major-11th (major-ninth, perfect 11th)
         minor-11th (minor-ninth, perfect 11th)
         13ths (usually as the basis for alteration):
         dominant-13th (dominant-11th, major 13th)
         major-13th (major-11th, major 13th)
         minor-13th (minor-11th, major 13th)
         Suspended:
         suspended-second (major second, perfect fifth)
         suspended-fourth (perfect fourth, perfect fifth)
         Functional sixths:
         Neapolitan
         Italian
         French
         German
         Other:
         pedal (pedal-point bass)
         power (perfect fifth)
         Tristan
         
         The "other" kind is used when the harmony is entirely composed of add elements. The "none" kind is used to explicitly encode absence of chords or functional harmony.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="major"/>
         <xs:enumeration value="minor"/>
         <xs:enumeration value="augmented"/>
         <xs:enumeration value="diminished"/>
         <xs:enumeration value="dominant"/>
         <xs:enumeration value="major-seventh"/>
         <xs:enumeration value="minor-seventh"/>
         <xs:enumeration value="diminished-seventh"/>
         <xs:enumeration value="augmented-seventh"/>
         <xs:enumeration value="half-diminished"/>
         <xs:enumeration value="major-minor"/>
         <xs:enumeration value="major-sixth"/>
         <xs:enumeration value="minor-sixth"/>
         <xs:enumeration value="dominant-ninth"/>
         <xs:enumeration value="major-ninth"/>
         <xs:enumeration value="minor-ninth"/>
         <xs:enumeration value="dominant-11th"/>
         <xs:enumeration value="major-11th"/>
         <xs:enumeration value="minor-11th"/>
         <xs:enumeration value="dominant-13th"/>
         <xs:enumeration value="major-13th"/>
         <xs:enumeration value="minor-13th"/>
         <xs:enumeration value="suspended-second"/>
         <xs:enumeration value="suspended-fourth"/>
         <xs:enumeration value="Neapolitan"/>
         <xs:enumeration value="Italian"/>
         <xs:enumeration value="French"/>
         <xs:enumeration value="German"/>
         <xs:enumeration value="pedal"/>
         <xs:enumeration value="power"/>
         <xs:enumeration value="Tristan"/>
         <xs:enumeration value="other"/>
         <xs:enumeration value="none"/>
         </xs:restriction>
         </xs:simpleType>
         */
        struct KindAttributes;
        using KindAttributesPtr = std::shared_ptr<KindAttributes>;
        
        struct KindAttributes : public AttributesInterface
        {
        public:
            KindAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo useSymbols;
            t::XsToken text;
            t::YesNo stackDegrees;
            t::YesNo parenthesesDegrees;
            t::YesNo bracketDegrees;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            bool hasUseSymbols;
            bool hasText;
            bool hasStackDegrees;
            bool hasParenthesesDegrees;
            bool hasBracketDegrees;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
        };
        
        class Kind;
        using KindPtr = std::shared_ptr<Kind>;
        using KindUPtr = std::unique_ptr<Kind>;
        using KindSet = std::vector<KindPtr>;
        using KindSetIter = KindSet::iterator;
        using KindSetIterConst = KindSet::const_iterator;
        inline KindPtr makeKind() { return std::make_shared<Kind>(); }
		inline KindPtr makeKind( const t::KindValue& value ) { return std::make_shared<Kind>( value ); }
		inline KindPtr makeKind( t::KindValue&& value ) { return std::make_shared<Kind>( std::move( value ) ); }
        class Kind : public ElementInterface
        {
        public:
            Kind();
            Kind( const t::KindValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            KindAttributesPtr getAttributes() const;
            void setAttributes( const KindAttributesPtr& attributes );
            t::KindValue getValue() const;
            void setValue( const t::KindValue& value );
        private:
            t::KindValue myValue;
            KindAttributesPtr myAttributes;
        };
        
        
        /**************** Inversion ****************
         6202
         <xs:element name="inversion" type="inversion" minOccurs="0"/>
         <xs:complexType name="inversion">
         <xs:annotation>
         <xs:documentation>The inversion type represents harmony inversions. The value is a number indicating which inversion is used: 0 for root position, 1 for first inversion, etc.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="xs:nonNegativeInteger">
         <xs:attributeGroup ref="print-style"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         */
        struct InversionAttributes;
        using InversionAttributesPtr = std::shared_ptr<InversionAttributes>;
        
        struct InversionAttributes : public AttributesInterface
        {
        public:
            InversionAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class Inversion;
        using InversionPtr = std::shared_ptr<Inversion>;
        using InversionUPtr = std::unique_ptr<Inversion>;
        using InversionSet = std::vector<InversionPtr>;
        using InversionSetIter = InversionSet::iterator;
        using InversionSetIterConst = InversionSet::const_iterator;
        inline InversionPtr makeInversion() { return std::make_shared<Inversion>(); }
		inline InversionPtr makeInversion( const t::NonNegativeInteger& value ) { return std::make_shared<Inversion>( value ); }
		inline InversionPtr makeInversion( t::NonNegativeInteger&& value ) { return std::make_shared<Inversion>( std::move( value ) ); }
        class Inversion : public ElementInterface
        {
        public:
            Inversion();
            Inversion( const t::NonNegativeInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            InversionAttributesPtr getAttributes() const;
            void setAttributes( const InversionAttributesPtr& attributes );
            t::NonNegativeInteger getValue() const;
            void setValue( const t::NonNegativeInteger& value );
        private:
            t::NonNegativeInteger myValue;
            InversionAttributesPtr myAttributes;
        };
        
        /***************************************************************************************************************************
         ***************************************************************************************************************************
         ***************************************************************************************************************************
         ***************************************************************************************************************************
         **********************      Value Elements with NO Attributes *************************************************************
         ***************************************************************************************************************************
         ***************************************************************************************************************************
         ***************************************************************************************************************************
         ***************************************************************************************************************************/
        
        
        /**************** MidiChannel ****************
         2457
         <xs:element name="midi-channel" type="midi-16" minOccurs="0">  <xs:annotation>     <xs:documentation>The midi-channel element specifies a MIDI 1.0 channel numbers ranging from 1 to 16.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="midi-16">
         <xs:annotation>
         <xs:documentation>The midi-16 type is used to express MIDI 1.0 values that range from 1 to 16.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:positiveInteger">
         <xs:minInclusive value="1"/>
         <xs:maxInclusive value="16"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="midi-16">
         <xs:annotation>
         <xs:documentation>The midi-16 type is used to express MIDI 1.0 values that range from 1 to 16.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:positiveInteger">
         <xs:minInclusive value="1"/>
         <xs:maxInclusive value="16"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class MidiChannel;
        using MidiChannelPtr = std::shared_ptr<MidiChannel>;
        using MidiChannelUPtr = std::unique_ptr<MidiChannel>;
        using MidiChannelSet = std::vector<MidiChannelPtr>;
        using MidiChannelSetIter = MidiChannelSet::iterator;
        using MidiChannelSetIterConst = MidiChannelSet::const_iterator;
        inline MidiChannelPtr makeMidiChannel() { return std::make_shared<MidiChannel>(); }
		inline MidiChannelPtr makeMidiChannel( const t::Midi16& value ) { return std::make_shared<MidiChannel>( value ); }
		inline MidiChannelPtr makeMidiChannel( t::Midi16&& value ) { return std::make_shared<MidiChannel>( std::move( value ) ); }
        class MidiChannel : public ElementInterface
        {
        public:
            MidiChannel();
            MidiChannel( const t::Midi16& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Midi16 getValue() const;
            void setValue( const t::Midi16& value );
        private:
            t::Midi16 myValue;
        };
        
        
        /**************** MidiName ****************
         2463
         <xs:element name="midi-name" type="xs:string" minOccurs="0">   <xs:annotation>     <xs:documentation>The midi-name element corresponds to a ProgramName meta-event within a Standard MIDI File.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class MidiName;
        using MidiNamePtr = std::shared_ptr<MidiName>;
        using MidiNameUPtr = std::unique_ptr<MidiName>;
        using MidiNameSet = std::vector<MidiNamePtr>;
        using MidiNameSetIter = MidiNameSet::iterator;
        using MidiNameSetIterConst = MidiNameSet::const_iterator;
        inline MidiNamePtr makeMidiName() { return std::make_shared<MidiName>(); }
		inline MidiNamePtr makeMidiName( const t::XsString& value ) { return std::make_shared<MidiName>( value ); }
		inline MidiNamePtr makeMidiName( t::XsString&& value ) { return std::make_shared<MidiName>( std::move( value ) ); }
        class MidiName : public ElementInterface
        {
        public:
            MidiName();
            MidiName( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** MidiBank ****************
         2469
         <xs:element name="midi-bank" type="midi-16384" minOccurs="0">  <xs:annotation>     <xs:documentation>The midi-bank element specified a MIDI 1.0 bank number ranging from 1 to 16384.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="midi-16384">
         <xs:annotation>
         <xs:documentation>The midi-16 type is used to express MIDI 1.0 values that range from 1 to 16,384.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:positiveInteger">
         <xs:minInclusive value="1"/>
         <xs:maxInclusive value="16384"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="midi-16384">
         <xs:annotation>
         <xs:documentation>The midi-16 type is used to express MIDI 1.0 values that range from 1 to 16,384.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:positiveInteger">
         <xs:minInclusive value="1"/>
         <xs:maxInclusive value="16384"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class MidiBank;
        using MidiBankPtr = std::shared_ptr<MidiBank>;
        using MidiBankUPtr = std::unique_ptr<MidiBank>;
        using MidiBankSet = std::vector<MidiBankPtr>;
        using MidiBankSetIter = MidiBankSet::iterator;
        using MidiBankSetIterConst = MidiBankSet::const_iterator;
        inline MidiBankPtr makeMidiBank() { return std::make_shared<MidiBank>(); }
		inline MidiBankPtr makeMidiBank( const t::Midi16384& value ) { return std::make_shared<MidiBank>( value ); }
		inline MidiBankPtr makeMidiBank( t::Midi16384&& value ) { return std::make_shared<MidiBank>( std::move( value ) ); }
        class MidiBank : public ElementInterface
        {
        public:
            MidiBank();
            MidiBank( const t::Midi16384& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Midi16384 getValue() const;
            void setValue( const t::Midi16384& value );
        private:
            t::Midi16384 myValue;
        };
        
        
        /**************** MidiProgram ****************
         2475
         <xs:element name="midi-program" type="midi-128" minOccurs="0"> <xs:annotation>     <xs:documentation>The midi-program element specifies a MIDI 1.0 program number ranging from 1 to 128.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="midi-128">
         <xs:annotation>
         <xs:documentation>The midi-16 type is used to express MIDI 1.0 values that range from 1 to 128.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:positiveInteger">
         <xs:minInclusive value="1"/>
         <xs:maxInclusive value="128"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="midi-128">
         <xs:annotation>
         <xs:documentation>The midi-16 type is used to express MIDI 1.0 values that range from 1 to 128.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:positiveInteger">
         <xs:minInclusive value="1"/>
         <xs:maxInclusive value="128"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class MidiProgram;
        using MidiProgramPtr = std::shared_ptr<MidiProgram>;
        using MidiProgramUPtr = std::unique_ptr<MidiProgram>;
        using MidiProgramSet = std::vector<MidiProgramPtr>;
        using MidiProgramSetIter = MidiProgramSet::iterator;
        using MidiProgramSetIterConst = MidiProgramSet::const_iterator;
        inline MidiProgramPtr makeMidiProgram() { return std::make_shared<MidiProgram>(); }
		inline MidiProgramPtr makeMidiProgram( const t::Midi128& value ) { return std::make_shared<MidiProgram>( value ); }
		inline MidiProgramPtr makeMidiProgram( t::Midi128&& value ) { return std::make_shared<MidiProgram>( std::move( value ) ); }
        class MidiProgram : public ElementInterface
        {
        public:
            MidiProgram();
            MidiProgram( const t::Midi128& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Midi128 getValue() const;
            void setValue( const t::Midi128& value );
        private:
            t::Midi128 myValue;
        };
        
        
        /**************** MidiUnpitched ****************
         2481
         <xs:element name="midi-unpitched" type="midi-128" minOccurs="0">   <xs:annotation>     <xs:documentation>For unpitched instruments the midi-unpitched element specifies a MIDI 1.0 note number ranging from 1 to 128. It is usually used with MIDI banks for percussion. Note that MIDI 1.0 note numbers are generally specified from 0 to 127 rather than the 1 to 128 numbering used in this element.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="midi-128">
         <xs:annotation>
         <xs:documentation>The midi-16 type is used to express MIDI 1.0 values that range from 1 to 128.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:positiveInteger">
         <xs:minInclusive value="1"/>
         <xs:maxInclusive value="128"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="midi-128">
         <xs:annotation>
         <xs:documentation>The midi-16 type is used to express MIDI 1.0 values that range from 1 to 128.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:positiveInteger">
         <xs:minInclusive value="1"/>
         <xs:maxInclusive value="128"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class MidiUnpitched;
        using MidiUnpitchedPtr = std::shared_ptr<MidiUnpitched>;
        using MidiUnpitchedUPtr = std::unique_ptr<MidiUnpitched>;
        using MidiUnpitchedSet = std::vector<MidiUnpitchedPtr>;
        using MidiUnpitchedSetIter = MidiUnpitchedSet::iterator;
        using MidiUnpitchedSetIterConst = MidiUnpitchedSet::const_iterator;
        inline MidiUnpitchedPtr makeMidiUnpitched() { return std::make_shared<MidiUnpitched>(); }
		inline MidiUnpitchedPtr makeMidiUnpitched( const t::Midi128& value ) { return std::make_shared<MidiUnpitched>( value ); }
		inline MidiUnpitchedPtr makeMidiUnpitched( t::Midi128&& value ) { return std::make_shared<MidiUnpitched>( std::move( value ) ); }
        class MidiUnpitched : public ElementInterface
        {
        public:
            MidiUnpitched();
            MidiUnpitched( const t::Midi128& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Midi128 getValue() const;
            void setValue( const t::Midi128& value );
        private:
            t::Midi128 myValue;
        };
        
        
        /**************** Volume ****************
         2487
         <xs:element name="volume" type="percent" minOccurs="0">    <xs:annotation>     <xs:documentation>The volume element value is a percentage of the maximum ranging from 0 to 100 with decimal values allowed. This corresponds to a scaling value for the MIDI 1.0 channel volume controller.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="percent">
         <xs:annotation>
         <xs:documentation>The percent type specifies a percentage from 0 to 100.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal">
         <xs:minInclusive value="0"/>
         <xs:maxInclusive value="100"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="percent">
         <xs:annotation>
         <xs:documentation>The percent type specifies a percentage from 0 to 100.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal">
         <xs:minInclusive value="0"/>
         <xs:maxInclusive value="100"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Volume;
        using VolumePtr = std::shared_ptr<Volume>;
        using VolumeUPtr = std::unique_ptr<Volume>;
        using VolumeSet = std::vector<VolumePtr>;
        using VolumeSetIter = VolumeSet::iterator;
        using VolumeSetIterConst = VolumeSet::const_iterator;
        inline VolumePtr makeVolume() { return std::make_shared<Volume>(); }
		inline VolumePtr makeVolume( const t::Percent& value ) { return std::make_shared<Volume>( value ); }
		inline VolumePtr makeVolume( t::Percent&& value ) { return std::make_shared<Volume>( std::move( value ) ); }
        class Volume : public ElementInterface
        {
        public:
            Volume();
            Volume( const t::Percent& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Percent getValue() const;
            void setValue( const t::Percent& value );
        private:
            t::Percent myValue;
        };
        
        
        /**************** Pan ****************
         2493
         <xs:element name="pan" type="rotation-degrees" minOccurs="0">  <xs:annotation>     <xs:documentation>The pan and elevation elements allow placing of sound in a 3-D space relative to the listener. Both are expressed in degrees ranging from -180 to 180. For pan 0 is straight ahead -90 is hard left 90 is hard right and -180 and 180 are directly behind the listener.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="rotation-degrees">
         <xs:annotation>
         <xs:documentation>The rotation-degrees type specifies rotation, pan, and elevation values in degrees. Values range from -180 to 180.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal">
         <xs:minInclusive value="-180"/>
         <xs:maxInclusive value="180"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="rotation-degrees">
         <xs:annotation>
         <xs:documentation>The rotation-degrees type specifies rotation, pan, and elevation values in degrees. Values range from -180 to 180.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal">
         <xs:minInclusive value="-180"/>
         <xs:maxInclusive value="180"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Pan;
        using PanPtr = std::shared_ptr<Pan>;
        using PanUPtr = std::unique_ptr<Pan>;
        using PanSet = std::vector<PanPtr>;
        using PanSetIter = PanSet::iterator;
        using PanSetIterConst = PanSet::const_iterator;
        inline PanPtr makePan() { return std::make_shared<Pan>(); }
		inline PanPtr makePan( const t::RotationDegrees& value ) { return std::make_shared<Pan>( value ); }
		inline PanPtr makePan( t::RotationDegrees&& value ) { return std::make_shared<Pan>( std::move( value ) ); }
        class Pan : public ElementInterface
        {
        public:
            Pan();
            Pan( const t::RotationDegrees& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::RotationDegrees getValue() const;
            void setValue( const t::RotationDegrees& value );
        private:
            t::RotationDegrees myValue;
        };
        
        
        /**************** Elevation ****************
         2499
         <xs:element name="elevation" type="rotation-degrees" minOccurs="0">    <xs:annotation>     <xs:documentation>The elevation and pan elements allow placing of sound in a 3-D space relative to the listener. Both are expressed in degrees ranging from -180 to 180. For elevation 0 is level with the listener 90 is directly above and -90 is directly below.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="rotation-degrees">
         <xs:annotation>
         <xs:documentation>The rotation-degrees type specifies rotation, pan, and elevation values in degrees. Values range from -180 to 180.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal">
         <xs:minInclusive value="-180"/>
         <xs:maxInclusive value="180"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="rotation-degrees">
         <xs:annotation>
         <xs:documentation>The rotation-degrees type specifies rotation, pan, and elevation values in degrees. Values range from -180 to 180.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal">
         <xs:minInclusive value="-180"/>
         <xs:maxInclusive value="180"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Elevation;
        using ElevationPtr = std::shared_ptr<Elevation>;
        using ElevationUPtr = std::unique_ptr<Elevation>;
        using ElevationSet = std::vector<ElevationPtr>;
        using ElevationSetIter = ElevationSet::iterator;
        using ElevationSetIterConst = ElevationSet::const_iterator;
        inline ElevationPtr makeElevation() { return std::make_shared<Elevation>(); }
		inline ElevationPtr makeElevation( const t::RotationDegrees& value ) { return std::make_shared<Elevation>( value ); }
		inline ElevationPtr makeElevation( t::RotationDegrees&& value ) { return std::make_shared<Elevation>( std::move( value ) ); }
        class Elevation : public ElementInterface
        {
        public:
            Elevation();
            Elevation( const t::RotationDegrees& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::RotationDegrees getValue() const;
            void setValue( const t::RotationDegrees& value );
        private:
            t::RotationDegrees myValue;
        };
        
        
        /**************** Ipa ****************
         2544
         <xs:element name="ipa" type="xs:string">   <xs:annotation>     <xs:documentation>The ipa element represents International Phonetic Alphabet (IPA) sounds for vocal music. String content is limited to IPA 2005 symbols represented in Unicode 6.0.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class Ipa;
        using IpaPtr = std::shared_ptr<Ipa>;
        using IpaUPtr = std::unique_ptr<Ipa>;
        using IpaSet = std::vector<IpaPtr>;
        using IpaSetIter = IpaSet::iterator;
        using IpaSetIterConst = IpaSet::const_iterator;
        inline IpaPtr makeIpa() { return std::make_shared<Ipa>(); }
		inline IpaPtr makeIpa( const t::XsString& value ) { return std::make_shared<Ipa>( value ); }
		inline IpaPtr makeIpa( t::XsString&& value ) { return std::make_shared<Ipa>( std::move( value ) ); }
        class Ipa : public ElementInterface
        {
        public:
            Ipa();
            Ipa( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** Mute ****************
         2549
         <xs:element name="mute" type="mute"/>
         <xs:simpleType name="mute">
         <xs:annotation>
         <xs:documentation>The mute type represents muting for different instruments, including brass, winds, and strings. The on and off values are used for undifferentiated mutes. The remaining values represent specific mutes.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="on"/>
         <xs:enumeration value="off"/>
         <xs:enumeration value="straight"/>
         <xs:enumeration value="cup"/>
         <xs:enumeration value="harmon-no-stem"/>
         <xs:enumeration value="harmon-stem"/>
         <xs:enumeration value="bucket"/>
         <xs:enumeration value="plunger"/>
         <xs:enumeration value="hat"/>
         <xs:enumeration value="solotone"/>
         <xs:enumeration value="practice"/>
         <xs:enumeration value="stop-mute"/>
         <xs:enumeration value="stop-hand"/>
         <xs:enumeration value="echo"/>
         <xs:enumeration value="palm"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="mute">
         <xs:annotation>
         <xs:documentation>The mute type represents muting for different instruments, including brass, winds, and strings. The on and off values are used for undifferentiated mutes. The remaining values represent specific mutes.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="on"/>
         <xs:enumeration value="off"/>
         <xs:enumeration value="straight"/>
         <xs:enumeration value="cup"/>
         <xs:enumeration value="harmon-no-stem"/>
         <xs:enumeration value="harmon-stem"/>
         <xs:enumeration value="bucket"/>
         <xs:enumeration value="plunger"/>
         <xs:enumeration value="hat"/>
         <xs:enumeration value="solotone"/>
         <xs:enumeration value="practice"/>
         <xs:enumeration value="stop-mute"/>
         <xs:enumeration value="stop-hand"/>
         <xs:enumeration value="echo"/>
         <xs:enumeration value="palm"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Mute;
        using MutePtr = std::shared_ptr<Mute>;
        using MuteUPtr = std::unique_ptr<Mute>;
        using MuteSet = std::vector<MutePtr>;
        using MuteSetIter = MuteSet::iterator;
        using MuteSetIterConst = MuteSet::const_iterator;
        inline MutePtr makeMute() { return std::make_shared<Mute>(); }
		inline MutePtr makeMute( const t::MuteEnum& value ) { return std::make_shared<Mute>( value ); }
		inline MutePtr makeMute( t::MuteEnum&& value ) { return std::make_shared<Mute>( std::move( value ) ); }
        class Mute : public ElementInterface
        {
        public:
            Mute();
            Mute( const t::MuteEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::MuteEnum getValue() const;
            void setValue( const t::MuteEnum& value );
        private:
            t::MuteEnum myValue;
        };
        
        
        /**************** SemiPitched ****************
         2552
         <xs:element name="semi-pitched" type="semi-pitched"/>
         <xs:simpleType name="semi-pitched">
         <xs:annotation>
         <xs:documentation>The semi-pitched type represents categories of indefinite pitch for percussion instruments.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="high"/>
         <xs:enumeration value="medium-high"/>
         <xs:enumeration value="medium"/>
         <xs:enumeration value="medium-low"/>
         <xs:enumeration value="low"/>
         <xs:enumeration value="very-low"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="semi-pitched">
         <xs:annotation>
         <xs:documentation>The semi-pitched type represents categories of indefinite pitch for percussion instruments.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="high"/>
         <xs:enumeration value="medium-high"/>
         <xs:enumeration value="medium"/>
         <xs:enumeration value="medium-low"/>
         <xs:enumeration value="low"/>
         <xs:enumeration value="very-low"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class SemiPitched;
        using SemiPitchedPtr = std::shared_ptr<SemiPitched>;
        using SemiPitchedUPtr = std::unique_ptr<SemiPitched>;
        using SemiPitchedSet = std::vector<SemiPitchedPtr>;
        using SemiPitchedSetIter = SemiPitchedSet::iterator;
        using SemiPitchedSetIterConst = SemiPitchedSet::const_iterator;
        inline SemiPitchedPtr makeSemiPitched() { return std::make_shared<SemiPitched>(); }
		inline SemiPitchedPtr makeSemiPitched( const t::SemiPitchedEnum& value ) { return std::make_shared<SemiPitched>( value ); }
		inline SemiPitchedPtr makeSemiPitched( t::SemiPitchedEnum&& value ) { return std::make_shared<SemiPitched>( std::move( value ) ); }
        class SemiPitched : public ElementInterface
        {
        public:
            SemiPitched();
            SemiPitched( const t::SemiPitchedEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::SemiPitchedEnum getValue() const;
            void setValue( const t::SemiPitchedEnum& value );
        private:
            t::SemiPitchedEnum myValue;
        };
        
        
        /**************** Divisions ****************
         2608
         <xs:element name="divisions" type="positive-divisions" minOccurs="0">  <xs:annotation>     <xs:documentation>Musical notation duration is commonly represented as fractions. The divisions element indicates how many divisions per quarter note are used to indicate a note's duration. For example if duration = 1 and divisions = 2 this is an eighth note duration. Duration and divisions are used directly for generating sound output so they must be chosen to take tuplets into account. Using a divisions element lets us use just one number to represent a duration for each note in the score while retaining the full power of a fractional representation. If maximum compatibility with Standard MIDI 1.0 files is important do not have the divisions value exceed 16383.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="positive-divisions">
         <xs:annotation>
         <xs:documentation>The positive-divisions type restricts divisions values to positive numbers.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="divisions">
         <xs:minExclusive value="0"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="positive-divisions">
         <xs:annotation>
         <xs:documentation>The positive-divisions type restricts divisions values to positive numbers.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="divisions">
         <xs:minExclusive value="0"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Divisions;
        using DivisionsPtr = std::shared_ptr<Divisions>;
        using DivisionsUPtr = std::unique_ptr<Divisions>;
        using DivisionsSet = std::vector<DivisionsPtr>;
        using DivisionsSetIter = DivisionsSet::iterator;
        using DivisionsSetIterConst = DivisionsSet::const_iterator;
        inline DivisionsPtr makeDivisions() { return std::make_shared<Divisions>(); }
		inline DivisionsPtr makeDivisions( const t::PositiveDivisionsValue& value ) { return std::make_shared<Divisions>( value ); }
		inline DivisionsPtr makeDivisions( t::PositiveDivisionsValue&& value ) { return std::make_shared<Divisions>( std::move( value ) ); }
        class Divisions : public ElementInterface
        {
        public:
            Divisions();
            Divisions( const t::PositiveDivisionsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::PositiveDivisionsValue getValue() const;
            void setValue( const t::PositiveDivisionsValue& value );
        private:
            t::PositiveDivisionsValue myValue;
        };
        
        
        /**************** Staves ****************
         2628
         <xs:element name="staves" type="xs:nonNegativeInteger" minOccurs="0">  <xs:annotation>     <xs:documentation>The staves element is used if there is more than one staff represented in the given part (e.g. 2 staves for typical piano parts). If absent a value of 1 is assumed. Staves are ordered from top to bottom in a part in numerical order with staff 1 above staff 2.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         */
        class Staves;
        using StavesPtr = std::shared_ptr<Staves>;
        using StavesUPtr = std::unique_ptr<Staves>;
        using StavesSet = std::vector<StavesPtr>;
        using StavesSetIter = StavesSet::iterator;
        using StavesSetIterConst = StavesSet::const_iterator;
        inline StavesPtr makeStaves() { return std::make_shared<Staves>(); }
		inline StavesPtr makeStaves( const t::NonNegativeInteger& value ) { return std::make_shared<Staves>( value ); }
		inline StavesPtr makeStaves( t::NonNegativeInteger&& value ) { return std::make_shared<Staves>( std::move( value ) ); }
        class Staves : public ElementInterface
        {
        public:
            Staves();
            Staves( const t::NonNegativeInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::NonNegativeInteger getValue() const;
            void setValue( const t::NonNegativeInteger& value );
        private:
            t::NonNegativeInteger myValue;
        };
        
        
        /**************** Instruments ****************
         2640
         <xs:element name="instruments" type="xs:nonNegativeInteger" minOccurs="0"> <xs:annotation>     <xs:documentation>The instruments element is only used if more than one instrument is represented in the part (e.g. oboe I and II where they play together most of the time). If absent a value of 1 is assumed.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         */
        class Instruments;
        using InstrumentsPtr = std::shared_ptr<Instruments>;
        using InstrumentsUPtr = std::unique_ptr<Instruments>;
        using InstrumentsSet = std::vector<InstrumentsPtr>;
        using InstrumentsSetIter = InstrumentsSet::iterator;
        using InstrumentsSetIterConst = InstrumentsSet::const_iterator;
        inline InstrumentsPtr makeInstruments() { return std::make_shared<Instruments>(); }
		inline InstrumentsPtr makeInstruments( const t::NonNegativeInteger& value ) { return std::make_shared<Instruments>( value ); }
		inline InstrumentsPtr makeInstruments( t::NonNegativeInteger&& value ) { return std::make_shared<Instruments>( std::move( value ) ); }
        class Instruments : public ElementInterface
        {
        public:
            Instruments();
            Instruments( const t::NonNegativeInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::NonNegativeInteger getValue() const;
            void setValue( const t::NonNegativeInteger& value );
        private:
            t::NonNegativeInteger myValue;
        };
        
        
        /**************** Sign ****************
         2720
         <xs:element name="sign" type="clef-sign">  <xs:annotation>     <xs:documentation>The sign element represents the clef symbol.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="clef-sign">
         <xs:annotation>
         <xs:documentation>The clef-sign element represents the different clef symbols. The jianpu sign indicates that the music that follows should be in jianpu numbered notation, just as the TAB sign indicates that the music that follows should be in tablature notation. Unlike TAB, a jianpu sign does not correspond to a visual clef notation.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="G"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="percussion"/>
         <xs:enumeration value="TAB"/>
         <xs:enumeration value="jianpu"/>
         <xs:enumeration value="none"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="clef-sign">
         <xs:annotation>
         <xs:documentation>The clef-sign element represents the different clef symbols. The jianpu sign indicates that the music that follows should be in jianpu numbered notation, just as the TAB sign indicates that the music that follows should be in tablature notation. Unlike TAB, a jianpu sign does not correspond to a visual clef notation.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="G"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="percussion"/>
         <xs:enumeration value="TAB"/>
         <xs:enumeration value="jianpu"/>
         <xs:enumeration value="none"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Sign;
        using SignPtr = std::shared_ptr<Sign>;
        using SignUPtr = std::unique_ptr<Sign>;
        using SignSet = std::vector<SignPtr>;
        using SignSetIter = SignSet::iterator;
        using SignSetIterConst = SignSet::const_iterator;
        inline SignPtr makeSign() { return std::make_shared<Sign>(); }
		inline SignPtr makeSign( const t::ClefSign& value ) { return std::make_shared<Sign>( value ); }
		inline SignPtr makeSign( t::ClefSign&& value ) { return std::make_shared<Sign>( std::move( value ) ); }
        class Sign : public ElementInterface
        {
        public:
            Sign();
            Sign( const t::ClefSign& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::ClefSign getValue() const;
            void setValue( const t::ClefSign& value );
        private:
            t::ClefSign myValue;
        };
        
        
        /**************** Line ****************
         2725
         <xs:element name="line" type="staff-line" minOccurs="0">   <xs:annotation>     <xs:documentation>Line numbers are counted from the bottom of the staff. Standard values are 2 for the G sign (treble clef) 4 for the F sign (bass clef) 3 for the C sign (alto clef) and 5 for TAB (on a 6-line staff).</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="staff-line">
         <xs:annotation>
         <xs:documentation>The staff-line type indicates the line on a given staff. Staff lines are numbered from bottom to top, with 1 being the bottom line on a staff. Staff line values can be used to specify positions outside the staff, such as a C clef positioned in the middle of a grand staff.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer"/>
         </xs:simpleType>
         <xs:simpleType name="staff-line">
         <xs:annotation>
         <xs:documentation>The staff-line type indicates the line on a given staff. Staff lines are numbered from bottom to top, with 1 being the bottom line on a staff. Staff line values can be used to specify positions outside the staff, such as a C clef positioned in the middle of a grand staff.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer"/>
         </xs:simpleType>
         */
        class Line;
        using LinePtr = std::shared_ptr<Line>;
        using LineUPtr = std::unique_ptr<Line>;
        using LineSet = std::vector<LinePtr>;
        using LineSetIter = LineSet::iterator;
        using LineSetIterConst = LineSet::const_iterator;
        inline LinePtr makeLine() { return std::make_shared<Line>(); }
		inline LinePtr makeLine( const t::StaffLine& value ) { return std::make_shared<Line>( value ); }
		inline LinePtr makeLine( t::StaffLine&& value ) { return std::make_shared<Line>( std::move( value ) ); }
        class Line : public ElementInterface
        {
        public:
            Line();
            Line( const t::StaffLine& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::StaffLine getValue() const;
            void setValue( const t::StaffLine& value );
        private:
            t::StaffLine myValue;
        };
        
        
        /**************** ClefOctaveChange ****************
         2731
         <xs:element name="clef-octave-change" type="xs:integer" minOccurs="0"> <xs:annotation>     <xs:documentation>The clef-octave-change element is used for transposing clefs. A treble clef for tenors would have a value of -1.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="xs:integer"/>
         <xs:simpleType name="xs:integer"/>
         */
        class ClefOctaveChange;
        using ClefOctaveChangePtr = std::shared_ptr<ClefOctaveChange>;
        using ClefOctaveChangeUPtr = std::unique_ptr<ClefOctaveChange>;
        using ClefOctaveChangeSet = std::vector<ClefOctaveChangePtr>;
        using ClefOctaveChangeSetIter = ClefOctaveChangeSet::iterator;
        using ClefOctaveChangeSetIterConst = ClefOctaveChangeSet::const_iterator;
        inline ClefOctaveChangePtr makeClefOctaveChange() { return std::make_shared<ClefOctaveChange>(); }
		inline ClefOctaveChangePtr makeClefOctaveChange( const t::Integer& value ) { return std::make_shared<ClefOctaveChange>( value ); }
		inline ClefOctaveChangePtr makeClefOctaveChange( t::Integer&& value ) { return std::make_shared<ClefOctaveChange>( std::move( value ) ); }
        class ClefOctaveChange : public ElementInterface
        {
        public:
            ClefOctaveChange();
            ClefOctaveChange( const t::Integer& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Integer getValue() const;
            void setValue( const t::Integer& value );
        private:
            t::Integer myValue;
        };
        
        
        /**************** TimeRelation ****************
         2758
         <xs:element name="time-relation" type="time-relation" minOccurs="0"/>
         <xs:simpleType name="time-relation">
         <xs:annotation>
         <xs:documentation>The time-relation type indicates the symbol used to represent the interchangeable aspect of dual time signatures.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="parentheses"/>
         <xs:enumeration value="bracket"/>
         <xs:enumeration value="equals"/>
         <xs:enumeration value="slash"/>
         <xs:enumeration value="space"/>
         <xs:enumeration value="hyphen"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="time-relation">
         <xs:annotation>
         <xs:documentation>The time-relation type indicates the symbol used to represent the interchangeable aspect of dual time signatures.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="parentheses"/>
         <xs:enumeration value="bracket"/>
         <xs:enumeration value="equals"/>
         <xs:enumeration value="slash"/>
         <xs:enumeration value="space"/>
         <xs:enumeration value="hyphen"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class TimeRelation;
        using TimeRelationPtr = std::shared_ptr<TimeRelation>;
        using TimeRelationUPtr = std::unique_ptr<TimeRelation>;
        using TimeRelationSet = std::vector<TimeRelationPtr>;
        using TimeRelationSetIter = TimeRelationSet::iterator;
        using TimeRelationSetIterConst = TimeRelationSet::const_iterator;
        inline TimeRelationPtr makeTimeRelation() { return std::make_shared<TimeRelation>(); }
		inline TimeRelationPtr makeTimeRelation( const t::TimeRelationEnum& value ) { return std::make_shared<TimeRelation>( value ); }
		inline TimeRelationPtr makeTimeRelation( t::TimeRelationEnum&& value ) { return std::make_shared<TimeRelation>( std::move( value ) ); }
        class TimeRelation : public ElementInterface
        {
        public:
            TimeRelation();
            TimeRelation( const t::TimeRelationEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TimeRelationEnum getValue() const;
            void setValue( const t::TimeRelationEnum& value );
        private:
            t::TimeRelationEnum myValue;
        };
        
        
        /**************** StaffType ****************
         2898
         <xs:element name="staff-type" type="staff-type" minOccurs="0"/>
         <xs:simpleType name="staff-type">
         <xs:annotation>
         <xs:documentation>The staff-type value can be ossia, cue, editorial, regular, or alternate. An alternate staff indicates one that shares the same musical data as the prior staff, but displayed differently (e.g., treble and bass clef, standard notation and tab).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="ossia"/>
         <xs:enumeration value="cue"/>
         <xs:enumeration value="editorial"/>
         <xs:enumeration value="regular"/>
         <xs:enumeration value="alternate"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="staff-type">
         <xs:annotation>
         <xs:documentation>The staff-type value can be ossia, cue, editorial, regular, or alternate. An alternate staff indicates one that shares the same musical data as the prior staff, but displayed differently (e.g., treble and bass clef, standard notation and tab).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="ossia"/>
         <xs:enumeration value="cue"/>
         <xs:enumeration value="editorial"/>
         <xs:enumeration value="regular"/>
         <xs:enumeration value="alternate"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class StaffType;
        using StaffTypePtr = std::shared_ptr<StaffType>;
        using StaffTypeUPtr = std::unique_ptr<StaffType>;
        using StaffTypeSet = std::vector<StaffTypePtr>;
        using StaffTypeSetIter = StaffTypeSet::iterator;
        using StaffTypeSetIterConst = StaffTypeSet::const_iterator;
        inline StaffTypePtr makeStaffType() { return std::make_shared<StaffType>(); }
		inline StaffTypePtr makeStaffType( const t::StaffTypeEnum& value ) { return std::make_shared<StaffType>( value ); }
		inline StaffTypePtr makeStaffType( t::StaffTypeEnum&& value ) { return std::make_shared<StaffType>( std::move( value ) ); }
        class StaffType : public ElementInterface
        {
        public:
            StaffType();
            StaffType( const t::StaffTypeEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::StaffTypeEnum getValue() const;
            void setValue( const t::StaffTypeEnum& value );
        private:
            t::StaffTypeEnum myValue;
        };
        
        
        /**************** StaffLines ****************
         2902
         <xs:element name="staff-lines" type="xs:nonNegativeInteger" minOccurs="0"> <xs:annotation>     <xs:documentation>The staff-lines element specifies the number of lines for a non 5-line staff.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         */
        class StaffLines;
        using StaffLinesPtr = std::shared_ptr<StaffLines>;
        using StaffLinesUPtr = std::unique_ptr<StaffLines>;
        using StaffLinesSet = std::vector<StaffLinesPtr>;
        using StaffLinesSetIter = StaffLinesSet::iterator;
        using StaffLinesSetIterConst = StaffLinesSet::const_iterator;
        inline StaffLinesPtr makeStaffLines() { return std::make_shared<StaffLines>(); }
		inline StaffLinesPtr makeStaffLines( const t::NonNegativeInteger& value ) { return std::make_shared<StaffLines>( value ); }
		inline StaffLinesPtr makeStaffLines( t::NonNegativeInteger&& value ) { return std::make_shared<StaffLines>( std::move( value ) ); }
        class StaffLines : public ElementInterface
        {
        public:
            StaffLines();
            StaffLines( const t::NonNegativeInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::NonNegativeInteger getValue() const;
            void setValue( const t::NonNegativeInteger& value );
        private:
            t::NonNegativeInteger myValue;
        };
        
        
        /**************** Capo ****************
         2913
         <xs:element name="capo" type="xs:nonNegativeInteger" minOccurs="0">    <xs:annotation>     <xs:documentation>The capo element indicates at which fret a capo should be placed on a fretted instrument. This changes the open tuning of the strings specified by staff-tuning by the specified number of half-steps.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         */
        class Capo;
        using CapoPtr = std::shared_ptr<Capo>;
        using CapoUPtr = std::unique_ptr<Capo>;
        using CapoSet = std::vector<CapoPtr>;
        using CapoSetIter = CapoSet::iterator;
        using CapoSetIterConst = CapoSet::const_iterator;
        inline CapoPtr makeCapo() { return std::make_shared<Capo>(); }
		inline CapoPtr makeCapo( const t::NonNegativeInteger& value ) { return std::make_shared<Capo>( value ); }
		inline CapoPtr makeCapo( t::NonNegativeInteger&& value ) { return std::make_shared<Capo>( std::move( value ) ); }
        class Capo : public ElementInterface
        {
        public:
            Capo();
            Capo( const t::NonNegativeInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::NonNegativeInteger getValue() const;
            void setValue( const t::NonNegativeInteger& value );
        private:
            t::NonNegativeInteger myValue;
        };
        
        
        /**************** StaffSize ****************
         2919
         <xs:element name="staff-size" type="non-negative-decimal" minOccurs="0">   <xs:annotation>     <xs:documentation>The staff-size element indicates how large a staff space is on this staff expressed as a percentage of the work's default scaling. Values less than 100 make the staff space smaller while values over 100 make the staff space larger. A staff-type of cue ossia or editorial implies a staff-size of less than 100 but the exact value is implementation-dependent unless specified here. Staff size affects staff height only not the relationship of the staff to the left and right margins.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="non-negative-decimal">
         <xs:annotation>
         <xs:documentation>The non-negative-decimal type specifies a non-negative decimal value.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal">
         <xs:minInclusive value="0"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="non-negative-decimal">
         <xs:annotation>
         <xs:documentation>The non-negative-decimal type specifies a non-negative decimal value.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal">
         <xs:minInclusive value="0"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class StaffSize;
        using StaffSizePtr = std::shared_ptr<StaffSize>;
        using StaffSizeUPtr = std::unique_ptr<StaffSize>;
        using StaffSizeSet = std::vector<StaffSizePtr>;
        using StaffSizeSetIter = StaffSizeSet::iterator;
        using StaffSizeSetIterConst = StaffSizeSet::const_iterator;
        inline StaffSizePtr makeStaffSize() { return std::make_shared<StaffSize>(); }
		inline StaffSizePtr makeStaffSize( const t::NonNegativeDecimal& value ) { return std::make_shared<StaffSize>( value ); }
		inline StaffSizePtr makeStaffSize( t::NonNegativeDecimal&& value ) { return std::make_shared<StaffSize>( std::move( value ) ); }
        class StaffSize : public ElementInterface
        {
        public:
            StaffSize();
            StaffSize( const t::NonNegativeDecimal& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::NonNegativeDecimal getValue() const;
            void setValue( const t::NonNegativeDecimal& value );
        private:
            t::NonNegativeDecimal myValue;
        };
        
        
        /**************** SenzaMisura ****************
         2957
         <xs:element name="senza-misura" type="xs:string">  <xs:annotation>     <xs:documentation>A senza-misura element explicitly indicates that no time signature is present. The optional element content indicates the symbol to be used if any such as an X. The time element's symbol attribute is not used when a senza-misura element is present.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class SenzaMisura;
        using SenzaMisuraPtr = std::shared_ptr<SenzaMisura>;
        using SenzaMisuraUPtr = std::unique_ptr<SenzaMisura>;
        using SenzaMisuraSet = std::vector<SenzaMisuraPtr>;
        using SenzaMisuraSetIter = SenzaMisuraSet::iterator;
        using SenzaMisuraSetIterConst = SenzaMisuraSet::const_iterator;
        inline SenzaMisuraPtr makeSenzaMisura() { return std::make_shared<SenzaMisura>(); }
		inline SenzaMisuraPtr makeSenzaMisura( const t::XsString& value ) { return std::make_shared<SenzaMisura>( value ); }
		inline SenzaMisuraPtr makeSenzaMisura( t::XsString&& value ) { return std::make_shared<SenzaMisura>( std::move( value ) ); }
        class SenzaMisura : public ElementInterface
        {
        public:
            SenzaMisura();
            SenzaMisura( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** Diatonic ****************
         2980
         <xs:element name="diatonic" type="xs:integer" minOccurs="0">   <xs:annotation>     <xs:documentation>The diatonic element specifies the number of pitch steps needed to go from written to sounding pitch. This allows for correct spelling of enharmonic transpositions.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="xs:integer"/>
         <xs:simpleType name="xs:integer"/>
         */
        class Diatonic;
        using DiatonicPtr = std::shared_ptr<Diatonic>;
        using DiatonicUPtr = std::unique_ptr<Diatonic>;
        using DiatonicSet = std::vector<DiatonicPtr>;
        using DiatonicSetIter = DiatonicSet::iterator;
        using DiatonicSetIterConst = DiatonicSet::const_iterator;
        inline DiatonicPtr makeDiatonic() { return std::make_shared<Diatonic>(); }
		inline DiatonicPtr makeDiatonic( const t::Integer& value ) { return std::make_shared<Diatonic>( value ); }
		inline DiatonicPtr makeDiatonic( t::Integer&& value ) { return std::make_shared<Diatonic>( std::move( value ) ); }
        class Diatonic : public ElementInterface
        {
        public:
            Diatonic();
            Diatonic( const t::Integer& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Integer getValue() const;
            void setValue( const t::Integer& value );
        private:
            t::Integer myValue;
        };
        
        
        /**************** Chromatic ****************
         2986
         <xs:element name="chromatic" type="semitones"> <xs:annotation>     <xs:documentation>The chromatic element represents the number of semitones needed to get from written to sounding pitch. This value does not include octave-change values; the values for both elements need to be added to the written pitch to get the correct sounding pitch.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class Chromatic;
        using ChromaticPtr = std::shared_ptr<Chromatic>;
        using ChromaticUPtr = std::unique_ptr<Chromatic>;
        using ChromaticSet = std::vector<ChromaticPtr>;
        using ChromaticSetIter = ChromaticSet::iterator;
        using ChromaticSetIterConst = ChromaticSet::const_iterator;
        inline ChromaticPtr makeChromatic() { return std::make_shared<Chromatic>(); }
		inline ChromaticPtr makeChromatic( const t::Semitones& value ) { return std::make_shared<Chromatic>( value ); }
		inline ChromaticPtr makeChromatic( t::Semitones&& value ) { return std::make_shared<Chromatic>( std::move( value ) ); }
        class Chromatic : public ElementInterface
        {
        public:
            Chromatic();
            Chromatic( const t::Semitones& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Semitones getValue() const;
            void setValue( const t::Semitones& value );
        private:
            t::Semitones myValue;
        };
        
        
        /**************** OctaveChange ****************
         2991
         <xs:element name="octave-change" type="xs:integer" minOccurs="0">  <xs:annotation>     <xs:documentation>The octave-change element indicates how many octaves to add to get from written pitch to sounding pitch.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="xs:integer"/>
         <xs:simpleType name="xs:integer"/>
         */
        class OctaveChange;
        using OctaveChangePtr = std::shared_ptr<OctaveChange>;
        using OctaveChangeUPtr = std::unique_ptr<OctaveChange>;
        using OctaveChangeSet = std::vector<OctaveChangePtr>;
        using OctaveChangeSetIter = OctaveChangeSet::iterator;
        using OctaveChangeSetIterConst = OctaveChangeSet::const_iterator;
        inline OctaveChangePtr makeOctaveChange() { return std::make_shared<OctaveChange>(); }
		inline OctaveChangePtr makeOctaveChange( const t::Integer& value ) { return std::make_shared<OctaveChange>( value ); }
		inline OctaveChangePtr makeOctaveChange( t::Integer&& value ) { return std::make_shared<OctaveChange>( std::move( value ) ); }
        class OctaveChange : public ElementInterface
        {
        public:
            OctaveChange();
            OctaveChange( const t::Integer& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Integer getValue() const;
            void setValue( const t::Integer& value );
        private:
            t::Integer myValue;
        };
        
        
        /**************** AccordionMiddle ****************
         3126
         <xs:element name="accordion-middle" type="accordion-middle" minOccurs="0"> <xs:annotation>     <xs:documentation>The accordion-middle element indicates the presence of 1 to 3 dots in the middle (8') section of the registration symbol.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="accordion-middle">
         <xs:annotation>
         <xs:documentation>The accordion-middle type may have values of 1, 2, or 3, corresponding to having 1 to 3 dots in the middle section of the accordion registration symbol.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:positiveInteger">
         <xs:minInclusive value="1"/>
         <xs:maxInclusive value="3"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="accordion-middle">
         <xs:annotation>
         <xs:documentation>The accordion-middle type may have values of 1, 2, or 3, corresponding to having 1 to 3 dots in the middle section of the accordion registration symbol.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:positiveInteger">
         <xs:minInclusive value="1"/>
         <xs:maxInclusive value="3"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class AccordionMiddle;
        using AccordionMiddlePtr = std::shared_ptr<AccordionMiddle>;
        using AccordionMiddleUPtr = std::unique_ptr<AccordionMiddle>;
        using AccordionMiddleSet = std::vector<AccordionMiddlePtr>;
        using AccordionMiddleSetIter = AccordionMiddleSet::iterator;
        using AccordionMiddleSetIterConst = AccordionMiddleSet::const_iterator;
        inline AccordionMiddlePtr makeAccordionMiddle() { return std::make_shared<AccordionMiddle>(); }
		inline AccordionMiddlePtr makeAccordionMiddle( const t::AccordionMiddleValue& value ) { return std::make_shared<AccordionMiddle>( value ); }
		inline AccordionMiddlePtr makeAccordionMiddle( t::AccordionMiddleValue&& value ) { return std::make_shared<AccordionMiddle>( std::move( value ) ); }
        class AccordionMiddle : public ElementInterface
        {
        public:
            AccordionMiddle();
            AccordionMiddle( const t::AccordionMiddleValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::AccordionMiddleValue getValue() const;
            void setValue( const t::AccordionMiddleValue& value );
        private:
            t::AccordionMiddleValue myValue;
        };
        
        
        /**************** FrameStrings ****************
         3441
         <xs:element name="frame-strings" type="xs:positiveInteger">    <xs:annotation>     <xs:documentation>The frame-strings element gives the overall size of the frame in vertical lines (strings).</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="xs:positiveInteger"/>
         <xs:simpleType name="xs:positiveInteger"/>
         */
        class FrameStrings;
        using FrameStringsPtr = std::shared_ptr<FrameStrings>;
        using FrameStringsUPtr = std::unique_ptr<FrameStrings>;
        using FrameStringsSet = std::vector<FrameStringsPtr>;
        using FrameStringsSetIter = FrameStringsSet::iterator;
        using FrameStringsSetIterConst = FrameStringsSet::const_iterator;
        inline FrameStringsPtr makeFrameStrings() { return std::make_shared<FrameStrings>(); }
		inline FrameStringsPtr makeFrameStrings( const t::PositiveInteger& value ) { return std::make_shared<FrameStrings>( value ); }
		inline FrameStringsPtr makeFrameStrings( t::PositiveInteger&& value ) { return std::make_shared<FrameStrings>( std::move( value ) ); }
        class FrameStrings : public ElementInterface
        {
        public:
            FrameStrings();
            FrameStrings( const t::PositiveInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::PositiveInteger getValue() const;
            void setValue( const t::PositiveInteger& value );
        private:
            t::PositiveInteger myValue;
        };
        
        
        /**************** FrameFrets ****************
         3446
         <xs:element name="frame-frets" type="xs:positiveInteger">  <xs:annotation>     <xs:documentation>The frame-frets element gives the overall size of the frame in horizontal spaces (frets).</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="xs:positiveInteger"/>
         <xs:simpleType name="xs:positiveInteger"/>
         */
        class FrameFrets;
        using FrameFretsPtr = std::shared_ptr<FrameFrets>;
        using FrameFretsUPtr = std::unique_ptr<FrameFrets>;
        using FrameFretsSet = std::vector<FrameFretsPtr>;
        using FrameFretsSetIter = FrameFretsSet::iterator;
        using FrameFretsSetIterConst = FrameFretsSet::const_iterator;
        inline FrameFretsPtr makeFrameFrets() { return std::make_shared<FrameFrets>(); }
		inline FrameFretsPtr makeFrameFrets( const t::PositiveInteger& value ) { return std::make_shared<FrameFrets>( value ); }
		inline FrameFretsPtr makeFrameFrets( t::PositiveInteger&& value ) { return std::make_shared<FrameFrets>( std::move( value ) ); }
        class FrameFrets : public ElementInterface
        {
        public:
            FrameFrets();
            FrameFrets( const t::PositiveInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::PositiveInteger getValue() const;
            void setValue( const t::PositiveInteger& value );
        private:
            t::PositiveInteger myValue;
        };
        
        
        /**************** MetronomeRelation ****************
         3633
         <xs:element name="metronome-relation" type="xs:string">    <xs:annotation>     <xs:documentation>The metronome-relation element describes the relationship symbol that goes between the two sets of metronome-note elements. The currently allowed value is equals but this may expand in future versions. If the element is empty the equals value is used.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class MetronomeRelation;
        using MetronomeRelationPtr = std::shared_ptr<MetronomeRelation>;
        using MetronomeRelationUPtr = std::unique_ptr<MetronomeRelation>;
        using MetronomeRelationSet = std::vector<MetronomeRelationPtr>;
        using MetronomeRelationSetIter = MetronomeRelationSet::iterator;
        using MetronomeRelationSetIterConst = MetronomeRelationSet::const_iterator;
        inline MetronomeRelationPtr makeMetronomeRelation() { return std::make_shared<MetronomeRelation>(); }
        class MetronomeRelation : public ElementInterface
        {
        public:
            // This is weird, the only allowed value is "equals"
            // per the specification, so the client cannot change
            // the value.  No matter what you do here, MetronomeRelation's
            // value will always be "equals"
        public:
            MetronomeRelation();
            MetronomeRelation( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** MetronomeType ****************
         3665
         <xs:element name="metronome-type" type="note-type-value">  <xs:annotation>     <xs:documentation>The metronome-type element works like the type element in defining metric relationships.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="note-type-value">
         <xs:annotation>
         <xs:documentation>The note-type type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="1024th"/>
         <xs:enumeration value="512th"/>
         <xs:enumeration value="256th"/>
         <xs:enumeration value="128th"/>
         <xs:enumeration value="64th"/>
         <xs:enumeration value="32nd"/>
         <xs:enumeration value="16th"/>
         <xs:enumeration value="eighth"/>
         <xs:enumeration value="quarter"/>
         <xs:enumeration value="half"/>
         <xs:enumeration value="whole"/>
         <xs:enumeration value="breve"/>
         <xs:enumeration value="long"/>
         <xs:enumeration value="maxima"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="note-type-value">
         <xs:annotation>
         <xs:documentation>The note-type type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="1024th"/>
         <xs:enumeration value="512th"/>
         <xs:enumeration value="256th"/>
         <xs:enumeration value="128th"/>
         <xs:enumeration value="64th"/>
         <xs:enumeration value="32nd"/>
         <xs:enumeration value="16th"/>
         <xs:enumeration value="eighth"/>
         <xs:enumeration value="quarter"/>
         <xs:enumeration value="half"/>
         <xs:enumeration value="whole"/>
         <xs:enumeration value="breve"/>
         <xs:enumeration value="long"/>
         <xs:enumeration value="maxima"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class MetronomeType;
        using MetronomeTypePtr = std::shared_ptr<MetronomeType>;
        using MetronomeTypeUPtr = std::unique_ptr<MetronomeType>;
        using MetronomeTypeSet = std::vector<MetronomeTypePtr>;
        using MetronomeTypeSetIter = MetronomeTypeSet::iterator;
        using MetronomeTypeSetIterConst = MetronomeTypeSet::const_iterator;
        inline MetronomeTypePtr makeMetronomeType() { return std::make_shared<MetronomeType>(); }
		inline MetronomeTypePtr makeMetronomeType( const t::NoteTypeValue& value ) { return std::make_shared<MetronomeType>( value ); }
		inline MetronomeTypePtr makeMetronomeType( t::NoteTypeValue&& value ) { return std::make_shared<MetronomeType>( std::move( value ) ); }
        class MetronomeType : public ElementInterface
        {
        public:
            MetronomeType();
            MetronomeType( const t::NoteTypeValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::NoteTypeValue getValue() const;
            void setValue( const t::NoteTypeValue& value );
        private:
            t::NoteTypeValue myValue;
        };
        
        
        /**************** PedalStep ****************
         3764
         <xs:element name="pedal-step" type="step"> <xs:annotation>     <xs:documentation>The pedal-step element defines the pitch step for a single harp pedal.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class PedalStep;
        using PedalStepPtr = std::shared_ptr<PedalStep>;
        using PedalStepUPtr = std::unique_ptr<PedalStep>;
        using PedalStepSet = std::vector<PedalStepPtr>;
        using PedalStepSetIter = PedalStepSet::iterator;
        using PedalStepSetIterConst = PedalStepSet::const_iterator;
        inline PedalStepPtr makePedalStep() { return std::make_shared<PedalStep>(); }
		inline PedalStepPtr makePedalStep( const t::StepEnum& value ) { return std::make_shared<PedalStep>( value ); }
		inline PedalStepPtr makePedalStep( t::StepEnum&& value ) { return std::make_shared<PedalStep>( std::move( value ) ); }
        class PedalStep : public ElementInterface
        {
        public:
            PedalStep();
            PedalStep( const t::StepEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::StepEnum getValue() const;
            void setValue( const t::StepEnum& value );
        private:
            t::StepEnum myValue;
        };
        
        
        /**************** PedalAlter ****************
         3769
         <xs:element name="pedal-alter" type="semitones">   <xs:annotation>     <xs:documentation>The pedal-alter element defines the chromatic alteration for a single harp pedal.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class PedalAlter;
        using PedalAlterPtr = std::shared_ptr<PedalAlter>;
        using PedalAlterUPtr = std::unique_ptr<PedalAlter>;
        using PedalAlterSet = std::vector<PedalAlterPtr>;
        using PedalAlterSetIter = PedalAlterSet::iterator;
        using PedalAlterSetIterConst = PedalAlterSet::const_iterator;
        inline PedalAlterPtr makePedalAlter() { return std::make_shared<PedalAlter>(); }
		inline PedalAlterPtr makePedalAlter( const t::Semitones& value ) { return std::make_shared<PedalAlter>( value ); }
		inline PedalAlterPtr makePedalAlter( t::Semitones&& value ) { return std::make_shared<PedalAlter>( std::move( value ) ); }
        class PedalAlter : public ElementInterface
        {
        public:
            PedalAlter();
            PedalAlter( const t::Semitones& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Semitones getValue() const;
            void setValue( const t::Semitones& value );
        private:
            t::Semitones myValue;
        };
        
        
        /**************** Glass ****************
         3788
         <xs:element name="glass" type="glass"/>
         <xs:simpleType name="glass">
         <xs:annotation>
         <xs:documentation>The glass type represents pictograms for glass percussion instruments.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="wind chimes"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="glass">
         <xs:annotation>
         <xs:documentation>The glass type represents pictograms for glass percussion instruments.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="wind chimes"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Glass;
        using GlassPtr = std::shared_ptr<Glass>;
        using GlassUPtr = std::unique_ptr<Glass>;
        using GlassSet = std::vector<GlassPtr>;
        using GlassSetIter = GlassSet::iterator;
        using GlassSetIterConst = GlassSet::const_iterator;
        inline GlassPtr makeGlass() { return std::make_shared<Glass>(); }
		inline GlassPtr makeGlass( const t::GlassEnum& value ) { return std::make_shared<Glass>( value ); }
		inline GlassPtr makeGlass( t::GlassEnum&& value ) { return std::make_shared<Glass>( std::move( value ) ); }
        class Glass : public ElementInterface
        {
        public:
            Glass();
            Glass( const t::GlassEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::GlassEnum getValue() const;
            void setValue( const t::GlassEnum& value );
        private:
            t::GlassEnum myValue;
        };
        
        
        /**************** Metal ****************
         3791
         <xs:element name="metal" type="metal"/>
         <xs:simpleType name="metal">
         <xs:annotation>
         <xs:documentation>The metal type represents pictograms for metal percussion instruments. The hi-hat value refers to a pictogram like Stone's high-hat cymbals but without the long vertical line at the bottom.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="almglocken"/>
         <xs:enumeration value="bell"/>
         <xs:enumeration value="bell plate"/>
         <xs:enumeration value="brake drum"/>
         <xs:enumeration value="Chinese cymbal"/>
         <xs:enumeration value="cowbell"/>
         <xs:enumeration value="crash cymbals"/>
         <xs:enumeration value="crotale"/>
         <xs:enumeration value="cymbal tongs"/>
         <xs:enumeration value="domed gong"/>
         <xs:enumeration value="finger cymbals"/>
         <xs:enumeration value="flexatone"/>
         <xs:enumeration value="gong"/>
         <xs:enumeration value="hi-hat"/>
         <xs:enumeration value="high-hat cymbals"/>
         <xs:enumeration value="handbell"/>
         <xs:enumeration value="sistrum"/>
         <xs:enumeration value="sizzle cymbal"/>
         <xs:enumeration value="sleigh bells"/>
         <xs:enumeration value="suspended cymbal"/>
         <xs:enumeration value="tam tam"/>
         <xs:enumeration value="triangle"/>
         <xs:enumeration value="Vietnamese hat"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="metal">
         <xs:annotation>
         <xs:documentation>The metal type represents pictograms for metal percussion instruments. The hi-hat value refers to a pictogram like Stone's high-hat cymbals but without the long vertical line at the bottom.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="almglocken"/>
         <xs:enumeration value="bell"/>
         <xs:enumeration value="bell plate"/>
         <xs:enumeration value="brake drum"/>
         <xs:enumeration value="Chinese cymbal"/>
         <xs:enumeration value="cowbell"/>
         <xs:enumeration value="crash cymbals"/>
         <xs:enumeration value="crotale"/>
         <xs:enumeration value="cymbal tongs"/>
         <xs:enumeration value="domed gong"/>
         <xs:enumeration value="finger cymbals"/>
         <xs:enumeration value="flexatone"/>
         <xs:enumeration value="gong"/>
         <xs:enumeration value="hi-hat"/>
         <xs:enumeration value="high-hat cymbals"/>
         <xs:enumeration value="handbell"/>
         <xs:enumeration value="sistrum"/>
         <xs:enumeration value="sizzle cymbal"/>
         <xs:enumeration value="sleigh bells"/>
         <xs:enumeration value="suspended cymbal"/>
         <xs:enumeration value="tam tam"/>
         <xs:enumeration value="triangle"/>
         <xs:enumeration value="Vietnamese hat"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Metal;
        using MetalPtr = std::shared_ptr<Metal>;
        using MetalUPtr = std::unique_ptr<Metal>;
        using MetalSet = std::vector<MetalPtr>;
        using MetalSetIter = MetalSet::iterator;
        using MetalSetIterConst = MetalSet::const_iterator;
        inline MetalPtr makeMetal() { return std::make_shared<Metal>(); }
		inline MetalPtr makeMetal( const t::MetalEnum& value ) { return std::make_shared<Metal>( value ); }
		inline MetalPtr makeMetal( t::MetalEnum&& value ) { return std::make_shared<Metal>( std::move( value ) ); }
        class Metal : public ElementInterface
        {
        public:
            Metal();
            Metal( const t::MetalEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::MetalEnum getValue() const;
            void setValue( const t::MetalEnum& value );
        private:
            t::MetalEnum myValue;
        };
        
        
        /**************** Wood ****************
         3794
         <xs:element name="wood" type="wood"/>
         <xs:simpleType name="wood">
         <xs:annotation>
         <xs:documentation>The wood type represents pictograms for wood percussion instruments. The maraca and maracas values distinguish the one- and two-maraca versions of the pictogram. The vibraslap and castanets values are in addition to Stone's list.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="board clapper"/>
         <xs:enumeration value="cabasa"/>
         <xs:enumeration value="castanets"/>
         <xs:enumeration value="claves"/>
         <xs:enumeration value="guiro"/>
         <xs:enumeration value="log drum"/>
         <xs:enumeration value="maraca"/>
         <xs:enumeration value="maracas"/>
         <xs:enumeration value="ratchet"/>
         <xs:enumeration value="sandpaper blocks"/>
         <xs:enumeration value="slit drum"/>
         <xs:enumeration value="temple block"/>
         <xs:enumeration value="vibraslap"/>
         <xs:enumeration value="wood block"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="wood">
         <xs:annotation>
         <xs:documentation>The wood type represents pictograms for wood percussion instruments. The maraca and maracas values distinguish the one- and two-maraca versions of the pictogram. The vibraslap and castanets values are in addition to Stone's list.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="board clapper"/>
         <xs:enumeration value="cabasa"/>
         <xs:enumeration value="castanets"/>
         <xs:enumeration value="claves"/>
         <xs:enumeration value="guiro"/>
         <xs:enumeration value="log drum"/>
         <xs:enumeration value="maraca"/>
         <xs:enumeration value="maracas"/>
         <xs:enumeration value="ratchet"/>
         <xs:enumeration value="sandpaper blocks"/>
         <xs:enumeration value="slit drum"/>
         <xs:enumeration value="temple block"/>
         <xs:enumeration value="vibraslap"/>
         <xs:enumeration value="wood block"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Wood;
        using WoodPtr = std::shared_ptr<Wood>;
        using WoodUPtr = std::unique_ptr<Wood>;
        using WoodSet = std::vector<WoodPtr>;
        using WoodSetIter = WoodSet::iterator;
        using WoodSetIterConst = WoodSet::const_iterator;
        inline WoodPtr makeWood() { return std::make_shared<Wood>(); }
		inline WoodPtr makeWood( const t::WoodEnum& value ) { return std::make_shared<Wood>( value ); }
		inline WoodPtr makeWood( t::WoodEnum&& value ) { return std::make_shared<Wood>( std::move( value ) ); }
        class Wood : public ElementInterface
        {
        public:
            Wood();
            Wood( const t::WoodEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::WoodEnum getValue() const;
            void setValue( const t::WoodEnum& value );
        private:
            t::WoodEnum myValue;
        };
        
        
        /**************** Pitched ****************
         3797
         <xs:element name="pitched" type="pitched"/>
         <xs:simpleType name="pitched">
         <xs:annotation>
         <xs:documentation>The pitched type represents pictograms for pitched percussion instruments. The chimes and tubular chimes values distinguish the single-line and double-line versions of the pictogram. The mallet value is in addition to Stone's list.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="chimes"/>
         <xs:enumeration value="glockenspiel"/>
         <xs:enumeration value="mallet"/>
         <xs:enumeration value="marimba"/>
         <xs:enumeration value="tubular chimes"/>
         <xs:enumeration value="vibraphone"/>
         <xs:enumeration value="xylophone"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="pitched">
         <xs:annotation>
         <xs:documentation>The pitched type represents pictograms for pitched percussion instruments. The chimes and tubular chimes values distinguish the single-line and double-line versions of the pictogram. The mallet value is in addition to Stone's list.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="chimes"/>
         <xs:enumeration value="glockenspiel"/>
         <xs:enumeration value="mallet"/>
         <xs:enumeration value="marimba"/>
         <xs:enumeration value="tubular chimes"/>
         <xs:enumeration value="vibraphone"/>
         <xs:enumeration value="xylophone"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Pitched;
        using PitchedPtr = std::shared_ptr<Pitched>;
        using PitchedUPtr = std::unique_ptr<Pitched>;
        using PitchedSet = std::vector<PitchedPtr>;
        using PitchedSetIter = PitchedSet::iterator;
        using PitchedSetIterConst = PitchedSet::const_iterator;
        inline PitchedPtr makePitched() { return std::make_shared<Pitched>(); }
		inline PitchedPtr makePitched( const t::PitchedEnum& value ) { return std::make_shared<Pitched>( value ); }
		inline PitchedPtr makePitched( t::PitchedEnum&& value ) { return std::make_shared<Pitched>( std::move( value ) ); }
        class Pitched : public ElementInterface
        {
        public:
            Pitched();
            Pitched( const t::PitchedEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::PitchedEnum getValue() const;
            void setValue( const t::PitchedEnum& value );
        private:
            t::PitchedEnum myValue;
        };
        
        
        /**************** Membrane ****************
         3800
         <xs:element name="membrane" type="membrane"/>
         <xs:simpleType name="membrane">
         <xs:annotation>
         <xs:documentation>The membrane type represents pictograms for membrane percussion instruments. The goblet drum value is in addition to Stone's list.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="bass drum"/>
         <xs:enumeration value="bass drum on side"/>
         <xs:enumeration value="bongos"/>
         <xs:enumeration value="conga drum"/>
         <xs:enumeration value="goblet drum"/>
         <xs:enumeration value="military drum"/>
         <xs:enumeration value="snare drum"/>
         <xs:enumeration value="snare drum snares off"/>
         <xs:enumeration value="tambourine"/>
         <xs:enumeration value="tenor drum"/>
         <xs:enumeration value="timbales"/>
         <xs:enumeration value="tomtom"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="membrane">
         <xs:annotation>
         <xs:documentation>The membrane type represents pictograms for membrane percussion instruments. The goblet drum value is in addition to Stone's list.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="bass drum"/>
         <xs:enumeration value="bass drum on side"/>
         <xs:enumeration value="bongos"/>
         <xs:enumeration value="conga drum"/>
         <xs:enumeration value="goblet drum"/>
         <xs:enumeration value="military drum"/>
         <xs:enumeration value="snare drum"/>
         <xs:enumeration value="snare drum snares off"/>
         <xs:enumeration value="tambourine"/>
         <xs:enumeration value="tenor drum"/>
         <xs:enumeration value="timbales"/>
         <xs:enumeration value="tomtom"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Membrane;
        using MembranePtr = std::shared_ptr<Membrane>;
        using MembraneUPtr = std::unique_ptr<Membrane>;
        using MembraneSet = std::vector<MembranePtr>;
        using MembraneSetIter = MembraneSet::iterator;
        using MembraneSetIterConst = MembraneSet::const_iterator;
        inline MembranePtr makeMembrane() { return std::make_shared<Membrane>(); }
		inline MembranePtr makeMembrane( const t::MembraneEnum& value ) { return std::make_shared<Membrane>( value ); }
		inline MembranePtr makeMembrane( t::MembraneEnum&& value ) { return std::make_shared<Membrane>( std::move( value ) ); }
        class Membrane : public ElementInterface
        {
        public:
            Membrane();
            Membrane( const t::MembraneEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::MembraneEnum getValue() const;
            void setValue( const t::MembraneEnum& value );
        private:
            t::MembraneEnum myValue;
        };
        
        
        /**************** Effect ****************
         3803
         <xs:element name="effect" type="effect"/>
         <xs:simpleType name="effect">
         <xs:annotation>
         <xs:documentation>The effect type represents pictograms for sound effect percussion instruments. The cannon value is in addition to Stone's list.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="anvil"/>
         <xs:enumeration value="auto horn"/>
         <xs:enumeration value="bird whistle"/>
         <xs:enumeration value="cannon"/>
         <xs:enumeration value="duck call"/>
         <xs:enumeration value="gun shot"/>
         <xs:enumeration value="klaxon horn"/>
         <xs:enumeration value="lions roar"/>
         <xs:enumeration value="police whistle"/>
         <xs:enumeration value="siren"/>
         <xs:enumeration value="slide whistle"/>
         <xs:enumeration value="thunder sheet"/>
         <xs:enumeration value="wind machine"/>
         <xs:enumeration value="wind whistle"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="effect">
         <xs:annotation>
         <xs:documentation>The effect type represents pictograms for sound effect percussion instruments. The cannon value is in addition to Stone's list.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="anvil"/>
         <xs:enumeration value="auto horn"/>
         <xs:enumeration value="bird whistle"/>
         <xs:enumeration value="cannon"/>
         <xs:enumeration value="duck call"/>
         <xs:enumeration value="gun shot"/>
         <xs:enumeration value="klaxon horn"/>
         <xs:enumeration value="lions roar"/>
         <xs:enumeration value="police whistle"/>
         <xs:enumeration value="siren"/>
         <xs:enumeration value="slide whistle"/>
         <xs:enumeration value="thunder sheet"/>
         <xs:enumeration value="wind machine"/>
         <xs:enumeration value="wind whistle"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Effect;
        using EffectPtr = std::shared_ptr<Effect>;
        using EffectUPtr = std::unique_ptr<Effect>;
        using EffectSet = std::vector<EffectPtr>;
        using EffectSetIter = EffectSet::iterator;
        using EffectSetIterConst = EffectSet::const_iterator;
        inline EffectPtr makeEffect() { return std::make_shared<Effect>(); }
		inline EffectPtr makeEffect( const t::EffectEnum& value ) { return std::make_shared<Effect>( value ); }
		inline EffectPtr makeEffect( t::EffectEnum&& value ) { return std::make_shared<Effect>( std::move( value ) ); }
        class Effect : public ElementInterface
        {
        public:
            Effect();
            Effect( const t::EffectEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::EffectEnum getValue() const;
            void setValue( const t::EffectEnum& value );
        private:
            t::EffectEnum myValue;
        };
        
        
        /**************** StickLocation ****************
         3815
         <xs:element name="stick-location" type="stick-location"/>
         <xs:simpleType name="stick-location">
         <xs:annotation>
         <xs:documentation>The stick-location type represents pictograms for the location of sticks, beaters, or mallets on cymbals, gongs, drums, and other instruments.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="center"/>
         <xs:enumeration value="rim"/>
         <xs:enumeration value="cymbal bell"/>
         <xs:enumeration value="cymbal edge"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="stick-location">
         <xs:annotation>
         <xs:documentation>The stick-location type represents pictograms for the location of sticks, beaters, or mallets on cymbals, gongs, drums, and other instruments.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="center"/>
         <xs:enumeration value="rim"/>
         <xs:enumeration value="cymbal bell"/>
         <xs:enumeration value="cymbal edge"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class StickLocation;
        using StickLocationPtr = std::shared_ptr<StickLocation>;
        using StickLocationUPtr = std::unique_ptr<StickLocation>;
        using StickLocationSet = std::vector<StickLocationPtr>;
        using StickLocationSetIter = StickLocationSet::iterator;
        using StickLocationSetIterConst = StickLocationSet::const_iterator;
        inline StickLocationPtr makeStickLocation() { return std::make_shared<StickLocation>(); }
		inline StickLocationPtr makeStickLocation( const t::StickLocationEnum& value ) { return std::make_shared<StickLocation>( value ); }
		inline StickLocationPtr makeStickLocation( t::StickLocationEnum&& value ) { return std::make_shared<StickLocation>( std::move( value ) ); }
        class StickLocation : public ElementInterface
        {
        public:
            StickLocation();
            StickLocation( const t::StickLocationEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::StickLocationEnum getValue() const;
            void setValue( const t::StickLocationEnum& value );
        private:
            t::StickLocationEnum myValue;
        };
        
        
        /**************** OtherPercussion ****************
         3818
         <xs:element name="other-percussion" type="xs:string"/>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class OtherPercussion;
        using OtherPercussionPtr = std::shared_ptr<OtherPercussion>;
        using OtherPercussionUPtr = std::unique_ptr<OtherPercussion>;
        using OtherPercussionSet = std::vector<OtherPercussionPtr>;
        using OtherPercussionSetIter = OtherPercussionSet::iterator;
        using OtherPercussionSetIterConst = OtherPercussionSet::const_iterator;
        inline OtherPercussionPtr makeOtherPercussion() { return std::make_shared<OtherPercussion>(); }
		inline OtherPercussionPtr makeOtherPercussion( const t::XsString& value ) { return std::make_shared<OtherPercussion>( value ); }
		inline OtherPercussionPtr makeOtherPercussion( t::XsString&& value ) { return std::make_shared<OtherPercussion>( std::move( value ) ); }
        class OtherPercussion : public ElementInterface
        {
        public:
            OtherPercussion();
            OtherPercussion( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** StickType ****************
         3994
         <xs:element name="stick-type" type="stick-type"/>
         <xs:simpleType name="stick-type">
         <xs:annotation>
         <xs:documentation>The stick-type type represents the shape of pictograms where the material
         in the stick, mallet, or beater is represented in the pictogram.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="bass drum"/>
         <xs:enumeration value="double bass drum"/>
         <xs:enumeration value="timpani"/>
         <xs:enumeration value="xylophone"/>
         <xs:enumeration value="yarn"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="stick-type">
         <xs:annotation>
         <xs:documentation>The stick-type type represents the shape of pictograms where the material
         in the stick, mallet, or beater is represented in the pictogram.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="bass drum"/>
         <xs:enumeration value="double bass drum"/>
         <xs:enumeration value="timpani"/>
         <xs:enumeration value="xylophone"/>
         <xs:enumeration value="yarn"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class StickType;
        using StickTypePtr = std::shared_ptr<StickType>;
        using StickTypeUPtr = std::unique_ptr<StickType>;
        using StickTypeSet = std::vector<StickTypePtr>;
        using StickTypeSetIter = StickTypeSet::iterator;
        using StickTypeSetIterConst = StickTypeSet::const_iterator;
        inline StickTypePtr makeStickType() { return std::make_shared<StickType>(); }
		inline StickTypePtr makeStickType( const t::StickTypeEnum& value ) { return std::make_shared<StickType>( value ); }
		inline StickTypePtr makeStickType( t::StickTypeEnum&& value ) { return std::make_shared<StickType>( std::move( value ) ); }
        class StickType : public ElementInterface
        {
        public:
            StickType();
            StickType( const t::StickTypeEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::StickTypeEnum getValue() const;
            void setValue( const t::StickTypeEnum& value );
        private:
            t::StickTypeEnum myValue;
        };
        
        
        /**************** StickMaterial ****************
         3997
         <xs:element name="stick-material" type="stick-material"/>
         <xs:simpleType name="stick-material">
         <xs:annotation>
         <xs:documentation>The stick-material type represents the material being displayed in a stick pictogram.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="soft"/>
         <xs:enumeration value="medium"/>
         <xs:enumeration value="hard"/>
         <xs:enumeration value="shaded"/>
         <xs:enumeration value="x"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="stick-material">
         <xs:annotation>
         <xs:documentation>The stick-material type represents the material being displayed in a stick pictogram.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="soft"/>
         <xs:enumeration value="medium"/>
         <xs:enumeration value="hard"/>
         <xs:enumeration value="shaded"/>
         <xs:enumeration value="x"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class StickMaterial;
        using StickMaterialPtr = std::shared_ptr<StickMaterial>;
        using StickMaterialUPtr = std::unique_ptr<StickMaterial>;
        using StickMaterialSet = std::vector<StickMaterialPtr>;
        using StickMaterialSetIter = StickMaterialSet::iterator;
        using StickMaterialSetIterConst = StickMaterialSet::const_iterator;
        inline StickMaterialPtr makeStickMaterial() { return std::make_shared<StickMaterial>(); }
		inline StickMaterialPtr makeStickMaterial( const t::StickMaterialEnum& value ) { return std::make_shared<StickMaterial>( value ); }
		inline StickMaterialPtr makeStickMaterial( t::StickMaterialEnum&& value ) { return std::make_shared<StickMaterial>( std::move( value ) ); }
        class StickMaterial : public ElementInterface
        {
        public:
            StickMaterial();
            StickMaterial( const t::StickMaterialEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::StickMaterialEnum getValue() const;
            void setValue( const t::StickMaterialEnum& value );
        private:
            t::StickMaterialEnum myValue;
        };
        
        
        /**************** EncodingDate ****************
         4045
         <xs:element name="encoding-date" type="yyyy-mm-dd"/>
         <xs:simpleType name="yyyy-mm-dd">
         <xs:annotation>
         <xs:documentation>Calendar dates are represented yyyy-mm-dd format, following ISO 8601. This is a W3C XML Schema date type, but without the optional timezone data.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:date">
         <xs:pattern value="[^:Z]*"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="yyyy-mm-dd">
         <xs:annotation>
         <xs:documentation>Calendar dates are represented yyyy-mm-dd format, following ISO 8601. This is a W3C XML Schema date type, but without the optional timezone data.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:date">
         <xs:pattern value="[^:Z]*"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class EncodingDate;
        using EncodingDatePtr = std::shared_ptr<EncodingDate>;
        using EncodingDateUPtr = std::unique_ptr<EncodingDate>;
        using EncodingDateSet = std::vector<EncodingDatePtr>;
        using EncodingDateSetIter = EncodingDateSet::iterator;
        using EncodingDateSetIterConst = EncodingDateSet::const_iterator;
        inline EncodingDatePtr makeEncodingDate() { return std::make_shared<EncodingDate>(); }
		inline EncodingDatePtr makeEncodingDate( const t::Date& value ) { return std::make_shared<EncodingDate>( value ); }
		inline EncodingDatePtr makeEncodingDate( t::Date&& value ) { return std::make_shared<EncodingDate>( std::move( value ) ); }
        class EncodingDate : public ElementInterface
        {
        public:
            EncodingDate();
            EncodingDate( const t::Date& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Date getValue() const;
            void setValue( const t::Date& value );
        private:
            t::Date myValue;
        };
        
        
        /**************** Software ****************
         4051
         <xs:element name="software" type="xs:string"/>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class Software;
        using SoftwarePtr = std::shared_ptr<Software>;
        using SoftwareUPtr = std::unique_ptr<Software>;
        using SoftwareSet = std::vector<SoftwarePtr>;
        using SoftwareSetIter = SoftwareSet::iterator;
        using SoftwareSetIterConst = SoftwareSet::const_iterator;
        inline SoftwarePtr makeSoftware() { return std::make_shared<Software>(); }
		inline SoftwarePtr makeSoftware( const t::XsString& value ) { return std::make_shared<Software>( value ); }
		inline SoftwarePtr makeSoftware( t::XsString&& value ) { return std::make_shared<Software>( std::move( value ) ); }
        class Software : public ElementInterface
        {
        public:
            Software();
            Software( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** EncodingDescription ****************
         4054
         <xs:element name="encoding-description" type="xs:string"/>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class EncodingDescription;
        using EncodingDescriptionPtr = std::shared_ptr<EncodingDescription>;
        using EncodingDescriptionUPtr = std::unique_ptr<EncodingDescription>;
        using EncodingDescriptionSet = std::vector<EncodingDescriptionPtr>;
        using EncodingDescriptionSetIter = EncodingDescriptionSet::iterator;
        using EncodingDescriptionSetIterConst = EncodingDescriptionSet::const_iterator;
        inline EncodingDescriptionPtr makeEncodingDescription() { return std::make_shared<EncodingDescription>(); }
		inline EncodingDescriptionPtr makeEncodingDescription( const t::XsString& value ) { return std::make_shared<EncodingDescription>( value ); }
		inline EncodingDescriptionPtr makeEncodingDescription( t::XsString&& value ) { return std::make_shared<EncodingDescription>( std::move( value ) ); }
        class EncodingDescription : public ElementInterface
        {
        public:
            EncodingDescription();
            EncodingDescription( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** Source ****************
         4083
         <xs:element name="source" type="xs:string" minOccurs="0">  <xs:annotation>     <xs:documentation>The source for the music that is encoded. This is similar to the Dublin Core source element.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class Source;
        using SourcePtr = std::shared_ptr<Source>;
        using SourceUPtr = std::unique_ptr<Source>;
        using SourceSet = std::vector<SourcePtr>;
        using SourceSetIter = SourceSet::iterator;
        using SourceSetIterConst = SourceSet::const_iterator;
        inline SourcePtr makeSource() { return std::make_shared<Source>(); }
		inline SourcePtr makeSource( const t::XsString& value ) { return std::make_shared<Source>( value ); }
		inline SourcePtr makeSource( t::XsString&& value ) { return std::make_shared<Source>( std::move( value ) ); }
        class Source : public ElementInterface
        {
        public:
            Source();
            Source( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** MeasureDistance ****************
         4191
         <xs:element name="measure-distance" type="tenths" minOccurs="0">   <xs:annotation>     <xs:documentation>The measure-distance element specifies the horizontal distance from the previous measure. This value is only used for systems where there is horizontal whitespace in the middle of a system as in systems with codas. To specify the measure width use the width attribute of the measure element.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class MeasureDistance;
        using MeasureDistancePtr = std::shared_ptr<MeasureDistance>;
        using MeasureDistanceUPtr = std::unique_ptr<MeasureDistance>;
        using MeasureDistanceSet = std::vector<MeasureDistancePtr>;
        using MeasureDistanceSetIter = MeasureDistanceSet::iterator;
        using MeasureDistanceSetIterConst = MeasureDistanceSet::const_iterator;
        inline MeasureDistancePtr makeMeasureDistance() { return std::make_shared<MeasureDistance>(); }
		inline MeasureDistancePtr makeMeasureDistance( const t::TenthsValue& value ) { return std::make_shared<MeasureDistance>( value ); }
		inline MeasureDistancePtr makeMeasureDistance( t::TenthsValue&& value ) { return std::make_shared<MeasureDistance>( std::move( value ) ); }
        class MeasureDistance : public ElementInterface
        {
        public:
            MeasureDistance();
            MeasureDistance( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
        };
        
        
        /**************** PageHeight ****************
         4226
         <xs:element name="page-height" type="tenths"/>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class PageHeight;
        using PageHeightPtr = std::shared_ptr<PageHeight>;
        using PageHeightUPtr = std::unique_ptr<PageHeight>;
        using PageHeightSet = std::vector<PageHeightPtr>;
        using PageHeightSetIter = PageHeightSet::iterator;
        using PageHeightSetIterConst = PageHeightSet::const_iterator;
        inline PageHeightPtr makePageHeight() { return std::make_shared<PageHeight>(); }
		inline PageHeightPtr makePageHeight( const t::TenthsValue& value ) { return std::make_shared<PageHeight>( value ); }
		inline PageHeightPtr makePageHeight( t::TenthsValue&& value ) { return std::make_shared<PageHeight>( std::move( value ) ); }
        class PageHeight : public ElementInterface
        {
        public:
            PageHeight();
            PageHeight( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
        };
        
        
        /**************** PageWidth ****************
         4229
         <xs:element name="page-width" type="tenths"/>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class PageWidth;
        using PageWidthPtr = std::shared_ptr<PageWidth>;
        using PageWidthUPtr = std::unique_ptr<PageWidth>;
        using PageWidthSet = std::vector<PageWidthPtr>;
        using PageWidthSetIter = PageWidthSet::iterator;
        using PageWidthSetIterConst = PageWidthSet::const_iterator;
        inline PageWidthPtr makePageWidth() { return std::make_shared<PageWidth>(); }
		inline PageWidthPtr makePageWidth( const t::TenthsValue& value ) { return std::make_shared<PageWidth>( value ); }
		inline PageWidthPtr makePageWidth( t::TenthsValue&& value ) { return std::make_shared<PageWidth>( std::move( value ) ); }
        class PageWidth : public ElementInterface
        {
        public:
            PageWidth();
            PageWidth( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
        };
        
        
        /**************** Millimeters ****************
         4251
         <xs:element name="millimeters" type="millimeters"/>
         <xs:simpleType name="millimeters">
         <xs:annotation>
         <xs:documentation>The millimeters type is a number representing millimeters. This is used in the scaling element to provide a default scaling from tenths to physical units.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="millimeters">
         <xs:annotation>
         <xs:documentation>The millimeters type is a number representing millimeters. This is used in the scaling element to provide a default scaling from tenths to physical units.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class Millimeters;
        using MillimetersPtr = std::shared_ptr<Millimeters>;
        using MillimetersUPtr = std::unique_ptr<Millimeters>;
        using MillimetersSet = std::vector<MillimetersPtr>;
        using MillimetersSetIter = MillimetersSet::iterator;
        using MillimetersSetIterConst = MillimetersSet::const_iterator;
        inline MillimetersPtr makeMillimeters() { return std::make_shared<Millimeters>(); }
		inline MillimetersPtr makeMillimeters( const t::MillimetersValue& value ) { return std::make_shared<Millimeters>( value ); }
		inline MillimetersPtr makeMillimeters( t::MillimetersValue&& value ) { return std::make_shared<Millimeters>( std::move( value ) ); }
        class Millimeters : public ElementInterface
        {
        public:
            Millimeters();
            Millimeters( const t::MillimetersValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::MillimetersValue getValue() const;
            void setValue( const t::MillimetersValue& value );
        private:
            t::MillimetersValue myValue;
        };
        
        
        /**************** TenthsValue ****************
         4254
         <xs:element name="tenths" type="tenths"/>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class Tenths;
        using TenthsPtr = std::shared_ptr<Tenths>;
        using TenthsUPtr = std::unique_ptr<Tenths>;
        using TenthsSet = std::vector<TenthsPtr>;
        using TenthsSetIter = TenthsSet::iterator;
        using TenthsSetIterConst = TenthsSet::const_iterator;
        inline TenthsPtr makeTenths() { return std::make_shared<Tenths>(); }
		inline TenthsPtr makeTenths( const t::TenthsValue& value ) { return std::make_shared<Tenths>( value ); }
		inline TenthsPtr makeTenths( t::TenthsValue&& value ) { return std::make_shared<Tenths>( std::move( value ) ); }
        class Tenths : public ElementInterface
        {
        public:
            Tenths();
            Tenths( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
        };
        
        
        /**************** StaffDistance ****************
         4262
         <xs:element name="staff-distance" type="tenths" minOccurs="0"/>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class StaffDistance;
        using StaffDistancePtr = std::shared_ptr<StaffDistance>;
        using StaffDistanceUPtr = std::unique_ptr<StaffDistance>;
        using StaffDistanceSet = std::vector<StaffDistancePtr>;
        using StaffDistanceSetIter = StaffDistanceSet::iterator;
        using StaffDistanceSetIterConst = StaffDistanceSet::const_iterator;
        inline StaffDistancePtr makeStaffDistance() { return std::make_shared<StaffDistance>(); }
		inline StaffDistancePtr makeStaffDistance( const t::TenthsValue& value ) { return std::make_shared<StaffDistance>( value ); }
		inline StaffDistancePtr makeStaffDistance( t::TenthsValue&& value ) { return std::make_shared<StaffDistance>( std::move( value ) ); }
        class StaffDistance : public ElementInterface
        {
        public:
            StaffDistance();
            StaffDistance( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
        };
        
        
        /**************** SystemDistance ****************
         4289
         <xs:element name="system-distance" type="tenths" minOccurs="0"/>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class SystemDistance;
        using SystemDistancePtr = std::shared_ptr<SystemDistance>;
        using SystemDistanceUPtr = std::unique_ptr<SystemDistance>;
        using SystemDistanceSet = std::vector<SystemDistancePtr>;
        using SystemDistanceSetIter = SystemDistanceSet::iterator;
        using SystemDistanceSetIterConst = SystemDistanceSet::const_iterator;
        inline SystemDistancePtr makeSystemDistance() { return std::make_shared<SystemDistance>(); }
		inline SystemDistancePtr makeSystemDistance( const t::TenthsValue& value ) { return std::make_shared<SystemDistance>( value ); }
		inline SystemDistancePtr makeSystemDistance( t::TenthsValue&& value ) { return std::make_shared<SystemDistance>( std::move( value ) ); }
        class SystemDistance : public ElementInterface
        {
        public:
            SystemDistance();
            SystemDistance( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
        };
        
        
        /**************** TopSystemDistance ****************
         4293
         <xs:element name="top-system-distance" type="tenths" minOccurs="0"/>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class TopSystemDistance;
        using TopSystemDistancePtr = std::shared_ptr<TopSystemDistance>;
        using TopSystemDistanceUPtr = std::unique_ptr<TopSystemDistance>;
        using TopSystemDistanceSet = std::vector<TopSystemDistancePtr>;
        using TopSystemDistanceSetIter = TopSystemDistanceSet::iterator;
        using TopSystemDistanceSetIterConst = TopSystemDistanceSet::const_iterator;
        inline TopSystemDistancePtr makeTopSystemDistance() { return std::make_shared<TopSystemDistance>(); }
		inline TopSystemDistancePtr makeTopSystemDistance( const t::TenthsValue& value ) { return std::make_shared<TopSystemDistance>( value ); }
		inline TopSystemDistancePtr makeTopSystemDistance( t::TenthsValue&& value ) { return std::make_shared<TopSystemDistance>( std::move( value ) ); }
        class TopSystemDistance : public ElementInterface
        {
        public:
            TopSystemDistance();
            TopSystemDistance( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
        };
        
        
        /**************** ArrowDirection ****************
         4468
         <xs:element name="arrow-direction" type="arrow-direction"/>
         <xs:simpleType name="arrow-direction">
         <xs:annotation>
         <xs:documentation>The arrow-direction type represents the direction in which an arrow points, using Unicode arrow terminology.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="left"/>
         <xs:enumeration value="up"/>
         <xs:enumeration value="right"/>
         <xs:enumeration value="down"/>
         <xs:enumeration value="northwest"/>
         <xs:enumeration value="northeast"/>
         <xs:enumeration value="southeast"/>
         <xs:enumeration value="southwest"/>
         <xs:enumeration value="left right"/>
         <xs:enumeration value="up down"/>
         <xs:enumeration value="northwest southeast"/>
         <xs:enumeration value="northeast southwest"/>
         <xs:enumeration value="other"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="arrow-direction">
         <xs:annotation>
         <xs:documentation>The arrow-direction type represents the direction in which an arrow points, using Unicode arrow terminology.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="left"/>
         <xs:enumeration value="up"/>
         <xs:enumeration value="right"/>
         <xs:enumeration value="down"/>
         <xs:enumeration value="northwest"/>
         <xs:enumeration value="northeast"/>
         <xs:enumeration value="southeast"/>
         <xs:enumeration value="southwest"/>
         <xs:enumeration value="left right"/>
         <xs:enumeration value="up down"/>
         <xs:enumeration value="northwest southeast"/>
         <xs:enumeration value="northeast southwest"/>
         <xs:enumeration value="other"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class ArrowDirection;
        using ArrowDirectionPtr = std::shared_ptr<ArrowDirection>;
        using ArrowDirectionUPtr = std::unique_ptr<ArrowDirection>;
        using ArrowDirectionSet = std::vector<ArrowDirectionPtr>;
        using ArrowDirectionSetIter = ArrowDirectionSet::iterator;
        using ArrowDirectionSetIterConst = ArrowDirectionSet::const_iterator;
        inline ArrowDirectionPtr makeArrowDirection() { return std::make_shared<ArrowDirection>(); }
		inline ArrowDirectionPtr makeArrowDirection( const t::ArrowDirectionEnum& value ) { return std::make_shared<ArrowDirection>( value ); }
		inline ArrowDirectionPtr makeArrowDirection( t::ArrowDirectionEnum&& value ) { return std::make_shared<ArrowDirection>( std::move( value ) ); }
        class ArrowDirection : public ElementInterface
        {
        public:
            ArrowDirection();
            ArrowDirection( const t::ArrowDirectionEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::ArrowDirectionEnum getValue() const;
            void setValue( const t::ArrowDirectionEnum& value );
        private:
            t::ArrowDirectionEnum myValue;
        };
        
        
        /**************** ArrowStyle ****************
         4471
         <xs:element name="arrow-style" type="arrow-style" minOccurs="0"/>
         <xs:simpleType name="arrow-style">
         <xs:annotation>
         <xs:documentation>The arrow-style type represents the style of an arrow, using Unicode arrow terminology. Filled and hollow arrows indicate polygonal single arrows. Paired arrows are duplicate single arrows in the same direction. Combined arrows apply to double direction arrows like left right, indicating that an arrow in one direction should be combined with an arrow in the other direction.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="single"/>
         <xs:enumeration value="double"/>
         <xs:enumeration value="filled"/>
         <xs:enumeration value="hollow"/>
         <xs:enumeration value="paired"/>
         <xs:enumeration value="combined"/>
         <xs:enumeration value="other"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="arrow-style">
         <xs:annotation>
         <xs:documentation>The arrow-style type represents the style of an arrow, using Unicode arrow terminology. Filled and hollow arrows indicate polygonal single arrows. Paired arrows are duplicate single arrows in the same direction. Combined arrows apply to double direction arrows like left right, indicating that an arrow in one direction should be combined with an arrow in the other direction.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="single"/>
         <xs:enumeration value="double"/>
         <xs:enumeration value="filled"/>
         <xs:enumeration value="hollow"/>
         <xs:enumeration value="paired"/>
         <xs:enumeration value="combined"/>
         <xs:enumeration value="other"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class ArrowStyle;
        using ArrowStylePtr = std::shared_ptr<ArrowStyle>;
        using ArrowStyleUPtr = std::unique_ptr<ArrowStyle>;
        using ArrowStyleSet = std::vector<ArrowStylePtr>;
        using ArrowStyleSetIter = ArrowStyleSet::iterator;
        using ArrowStyleSetIterConst = ArrowStyleSet::const_iterator;
        inline ArrowStylePtr makeArrowStyle() { return std::make_shared<ArrowStyle>(); }
		inline ArrowStylePtr makeArrowStyle( const t::ArrowStyleEnum& value ) { return std::make_shared<ArrowStyle>( value ); }
		inline ArrowStylePtr makeArrowStyle( t::ArrowStyleEnum&& value ) { return std::make_shared<ArrowStyle>( std::move( value ) ); }
        class ArrowStyle : public ElementInterface
        {
        public:
            ArrowStyle();
            ArrowStyle( const t::ArrowStyleEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::ArrowStyleEnum getValue() const;
            void setValue( const t::ArrowStyleEnum& value );
        private:
            t::ArrowStyleEnum myValue;
        };
        
        
        /**************** CircularArrow ****************
         4475
         <xs:element name="circular-arrow" type="circular-arrow"/>
         <xs:simpleType name="circular-arrow">
         <xs:annotation>
         <xs:documentation>The circular-arrow type represents the direction in which a circular arrow points, using Unicode arrow terminology.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="clockwise"/>
         <xs:enumeration value="anticlockwise"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="circular-arrow">
         <xs:annotation>
         <xs:documentation>The circular-arrow type represents the direction in which a circular arrow points, using Unicode arrow terminology.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="clockwise"/>
         <xs:enumeration value="anticlockwise"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class CircularArrow;
        using CircularArrowPtr = std::shared_ptr<CircularArrow>;
        using CircularArrowUPtr = std::unique_ptr<CircularArrow>;
        using CircularArrowSet = std::vector<CircularArrowPtr>;
        using CircularArrowSetIter = CircularArrowSet::iterator;
        using CircularArrowSetIterConst = CircularArrowSet::const_iterator;
        inline CircularArrowPtr makeCircularArrow() { return std::make_shared<CircularArrow>(); }
		inline CircularArrowPtr makeCircularArrow( const t::CircularArrowEnum& value ) { return std::make_shared<CircularArrow>( value ); }
		inline CircularArrowPtr makeCircularArrow( t::CircularArrowEnum&& value ) { return std::make_shared<CircularArrow>( std::move( value ) ); }
        class CircularArrow : public ElementInterface
        {
        public:
            CircularArrow();
            CircularArrow( const t::CircularArrowEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::CircularArrowEnum getValue() const;
            void setValue( const t::CircularArrowEnum& value );
        private:
            t::CircularArrowEnum myValue;
        };
        
        
        /**************** BendAlter ****************
         4515
         <xs:element name="bend-alter" type="semitones">    <xs:annotation>     <xs:documentation>The bend-alter element indicates the number of steps in the bend similar to the alter element. As with the alter element numbers like 0.5 can be used to indicate microtones. Negative numbers indicate pre-bends or releases; the pre-bend and release elements are used to distinguish what is intended.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class BendAlter;
        using BendAlterPtr = std::shared_ptr<BendAlter>;
        using BendAlterUPtr = std::unique_ptr<BendAlter>;
        using BendAlterSet = std::vector<BendAlterPtr>;
        using BendAlterSetIter = BendAlterSet::iterator;
        using BendAlterSetIterConst = BendAlterSet::const_iterator;
        inline BendAlterPtr makeBendAlter() { return std::make_shared<BendAlter>(); }
		inline BendAlterPtr makeBendAlter( const t::Semitones& value ) { return std::make_shared<BendAlter>( value ); }
		inline BendAlterPtr makeBendAlter( t::Semitones&& value ) { return std::make_shared<BendAlter>( std::move( value ) ); }
        class BendAlter : public ElementInterface
        {
        public:
            BendAlter();
            BendAlter( const t::Semitones& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Semitones getValue() const;
            void setValue( const t::Semitones& value );
        private:
            t::Semitones myValue;
        };
        
        
        /**************** HoleType ****************
         4758
         <xs:element name="hole-type" type="xs:string" minOccurs="0">   <xs:annotation>     <xs:documentation>The content of the optional hole-type element indicates what the hole symbol represents in terms of instrument fingering or other techniques.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class HoleType;
        using HoleTypePtr = std::shared_ptr<HoleType>;
        using HoleTypeUPtr = std::unique_ptr<HoleType>;
        using HoleTypeSet = std::vector<HoleTypePtr>;
        using HoleTypeSetIter = HoleTypeSet::iterator;
        using HoleTypeSetIterConst = HoleTypeSet::const_iterator;
        inline HoleTypePtr makeHoleType() { return std::make_shared<HoleType>(); }
		inline HoleTypePtr makeHoleType( const t::XsString& value ) { return std::make_shared<HoleType>( value ); }
		inline HoleTypePtr makeHoleType( t::XsString&& value ) { return std::make_shared<HoleType>( std::move( value ) ); }
        class HoleType : public ElementInterface
        {
        public:
            HoleType();
            HoleType( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** HoleShape ****************
         4767
         <xs:element name="hole-shape" type="xs:string" minOccurs="0">  <xs:annotation>     <xs:documentation>The optional hole-shape element indicates the shape of the hole symbol; the default is a circle.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class HoleShape;
        using HoleShapePtr = std::shared_ptr<HoleShape>;
        using HoleShapeUPtr = std::unique_ptr<HoleShape>;
        using HoleShapeSet = std::vector<HoleShapePtr>;
        using HoleShapeSetIter = HoleShapeSet::iterator;
        using HoleShapeSetIterConst = HoleShapeSet::const_iterator;
        inline HoleShapePtr makeHoleShape() { return std::make_shared<HoleShape>(); }
		inline HoleShapePtr makeHoleShape( const t::XsString& value ) { return std::make_shared<HoleShape>( value ); }
		inline HoleShapePtr makeHoleShape( t::XsString&& value ) { return std::make_shared<HoleShape>( std::move( value ) ); }
        class HoleShape : public ElementInterface
        {
        public:
            HoleShape();
            HoleShape( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** Syllabic ****************
         4802, 4817
         <xs:element name="syllabic" type="syllabic" minOccurs="0"/>
         <xs:simpleType name="syllabic">
         <xs:annotation>
         <xs:documentation>Lyric hyphenation is indicated by the syllabic type. The single, begin, end, and middle values represent single-syllable words, word-beginning syllables, word-ending syllables, and mid-word syllables, respectively.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="single"/>
         <xs:enumeration value="begin"/>
         <xs:enumeration value="end"/>
         <xs:enumeration value="middle"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="syllabic">
         <xs:annotation>
         <xs:documentation>Lyric hyphenation is indicated by the syllabic type. The single, begin, end, and middle values represent single-syllable words, word-beginning syllables, word-ending syllables, and mid-word syllables, respectively.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="single"/>
         <xs:enumeration value="begin"/>
         <xs:enumeration value="end"/>
         <xs:enumeration value="middle"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Syllabic;
        using SyllabicPtr = std::shared_ptr<Syllabic>;
        using SyllabicUPtr = std::unique_ptr<Syllabic>;
        using SyllabicSet = std::vector<SyllabicPtr>;
        using SyllabicSetIter = SyllabicSet::iterator;
        using SyllabicSetIterConst = SyllabicSet::const_iterator;
        inline SyllabicPtr makeSyllabic() { return std::make_shared<Syllabic>(); }
		inline SyllabicPtr makeSyllabic( const t::SyllabicEnum& value ) { return std::make_shared<Syllabic>( value ); }
		inline SyllabicPtr makeSyllabic( t::SyllabicEnum&& value ) { return std::make_shared<Syllabic>( std::move( value ) ); }
        class Syllabic : public ElementInterface
        {
        public:
            Syllabic();
            Syllabic( const t::SyllabicEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::SyllabicEnum getValue() const;
            void setValue( const t::SyllabicEnum& value );
        private:
            t::SyllabicEnum myValue;
        };
        
        
        
        
        
        /**************** Step ****************
         5220
         <xs:element name="step" type="step"/>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Step;
        using StepPtr = std::shared_ptr<Step>;
        using StepUPtr = std::unique_ptr<Step>;
        using StepSet = std::vector<StepPtr>;
        using StepSetIter = StepSet::iterator;
        using StepSetIterConst = StepSet::const_iterator;
        inline StepPtr makeStep() { return std::make_shared<Step>(); }
		inline StepPtr makeStep( const t::StepEnum& value ) { return std::make_shared<Step>( value ); }
		inline StepPtr makeStep( t::StepEnum&& value ) { return std::make_shared<Step>( std::move( value ) ); }
        class Step : public ElementInterface
        {
        public:
            Step();
            Step( const t::StepEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::StepEnum getValue() const;
            void setValue( const t::StepEnum& value );
        private:
            t::StepEnum myValue;
        };
        
        
        /**************** Alter ****************
         5223
         <xs:element name="alter" type="semitones" minOccurs="0"/>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class Alter;
        using AlterPtr = std::shared_ptr<Alter>;
        using AlterUPtr = std::unique_ptr<Alter>;
        using AlterSet = std::vector<AlterPtr>;
        using AlterSetIter = AlterSet::iterator;
        using AlterSetIterConst = AlterSet::const_iterator;
        inline AlterPtr makeAlter() { return std::make_shared<Alter>(); }
		inline AlterPtr makeAlter( const t::Semitones& value ) { return std::make_shared<Alter>( value ); }
		inline AlterPtr makeAlter( t::Semitones&& value ) { return std::make_shared<Alter>( std::move( value ) ); }
        class Alter : public ElementInterface
        {
        public:
            Alter();
            Alter( const t::Semitones& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Semitones getValue() const;
            void setValue( const t::Semitones& value );
        private:
            t::Semitones myValue;
        };
        
        
        /**************** Octave ****************
         5227
         <xs:element name="octave" type="octave"/>
         <xs:simpleType name="octave">
         <xs:annotation>
         <xs:documentation>Octaves are represented by the numbers 0 to 9, where 4 indicates the octave started by middle C.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer">
         <xs:minInclusive value="0"/>
         <xs:maxInclusive value="9"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="octave">
         <xs:annotation>
         <xs:documentation>Octaves are represented by the numbers 0 to 9, where 4 indicates the octave started by middle C.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer">
         <xs:minInclusive value="0"/>
         <xs:maxInclusive value="9"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Octave;
        using OctavePtr = std::shared_ptr<Octave>;
        using OctaveUPtr = std::unique_ptr<Octave>;
        using OctaveSet = std::vector<OctavePtr>;
        using OctaveSetIter = OctaveSet::iterator;
        using OctaveSetIterConst = OctaveSet::const_iterator;
        inline OctavePtr makeOctave() { return std::make_shared<Octave>(); }
		inline OctavePtr makeOctave( const t::OctaveValue& value ) { return std::make_shared<Octave>( value ); }
		inline OctavePtr makeOctave( t::OctaveValue&& value ) { return std::make_shared<Octave>( std::move( value ) ); }
        class Octave : public ElementInterface
        {
        public:
            Octave();
            Octave( const t::OctaveValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::OctaveValue getValue() const;
            void setValue( const t::OctaveValue& value );
        private:
            t::OctaveValue myValue;
        };
        
        
        /**************** ActualNotes ****************
         5518
         <xs:element name="actual-notes" type="xs:nonNegativeInteger">  <xs:annotation>     <xs:documentation>The actual-notes element describes how many notes are played in the time usually occupied by the number in the normal-notes element.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         */
        class ActualNotes;
        using ActualNotesPtr = std::shared_ptr<ActualNotes>;
        using ActualNotesUPtr = std::unique_ptr<ActualNotes>;
        using ActualNotesSet = std::vector<ActualNotesPtr>;
        using ActualNotesSetIter = ActualNotesSet::iterator;
        using ActualNotesSetIterConst = ActualNotesSet::const_iterator;
        inline ActualNotesPtr makeActualNotes() { return std::make_shared<ActualNotes>(); }
		inline ActualNotesPtr makeActualNotes( const t::NonNegativeInteger& value ) { return std::make_shared<ActualNotes>( value ); }
		inline ActualNotesPtr makeActualNotes( t::NonNegativeInteger&& value ) { return std::make_shared<ActualNotes>( std::move( value ) ); }
        class ActualNotes : public ElementInterface
        {
        public:
            ActualNotes();
            ActualNotes( const t::NonNegativeInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::NonNegativeInteger getValue() const;
            void setValue( const t::NonNegativeInteger& value );
        private:
            t::NonNegativeInteger myValue;
        };
        
        
        /**************** NormalNotes ****************
         5523
         <xs:element name="normal-notes" type="xs:nonNegativeInteger">  <xs:annotation>     <xs:documentation>The normal-notes element describes how many notes are usually played in the time occupied by the number in the actual-notes element.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         <xs:simpleType name="xs:nonNegativeInteger"/>
         */
        class NormalNotes;
        using NormalNotesPtr = std::shared_ptr<NormalNotes>;
        using NormalNotesUPtr = std::unique_ptr<NormalNotes>;
        using NormalNotesSet = std::vector<NormalNotesPtr>;
        using NormalNotesSetIter = NormalNotesSet::iterator;
        using NormalNotesSetIterConst = NormalNotesSet::const_iterator;
        inline NormalNotesPtr makeNormalNotes() { return std::make_shared<NormalNotes>(); }
		inline NormalNotesPtr makeNormalNotes( const t::NonNegativeInteger& value ) { return std::make_shared<NormalNotes>( value ); }
		inline NormalNotesPtr makeNormalNotes( t::NonNegativeInteger&& value ) { return std::make_shared<NormalNotes>( std::move( value ) ); }
        class NormalNotes : public ElementInterface
        {
        public:
            NormalNotes();
            NormalNotes( const t::NonNegativeInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::NonNegativeInteger getValue() const;
            void setValue( const t::NonNegativeInteger& value );
        private:
            t::NonNegativeInteger myValue;
        };
        
        
        /**************** NormalType ****************
         5530
         <xs:element name="normal-type" type="note-type-value"> <xs:annotation>     <xs:documentation>If the type associated with the number in the normal-notes element is different than the current note type (e.g. a quarter note within an eighth note triplet) then the normal-notes type (e.g. eighth) is specified in the normal-type and normal-dot elements.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="note-type-value">
         <xs:annotation>
         <xs:documentation>The note-type type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="1024th"/>
         <xs:enumeration value="512th"/>
         <xs:enumeration value="256th"/>
         <xs:enumeration value="128th"/>
         <xs:enumeration value="64th"/>
         <xs:enumeration value="32nd"/>
         <xs:enumeration value="16th"/>
         <xs:enumeration value="eighth"/>
         <xs:enumeration value="quarter"/>
         <xs:enumeration value="half"/>
         <xs:enumeration value="whole"/>
         <xs:enumeration value="breve"/>
         <xs:enumeration value="long"/>
         <xs:enumeration value="maxima"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="note-type-value">
         <xs:annotation>
         <xs:documentation>The note-type type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="1024th"/>
         <xs:enumeration value="512th"/>
         <xs:enumeration value="256th"/>
         <xs:enumeration value="128th"/>
         <xs:enumeration value="64th"/>
         <xs:enumeration value="32nd"/>
         <xs:enumeration value="16th"/>
         <xs:enumeration value="eighth"/>
         <xs:enumeration value="quarter"/>
         <xs:enumeration value="half"/>
         <xs:enumeration value="whole"/>
         <xs:enumeration value="breve"/>
         <xs:enumeration value="long"/>
         <xs:enumeration value="maxima"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class NormalType;
        using NormalTypePtr = std::shared_ptr<NormalType>;
        using NormalTypeUPtr = std::unique_ptr<NormalType>;
        using NormalTypeSet = std::vector<NormalTypePtr>;
        using NormalTypeSetIter = NormalTypeSet::iterator;
        using NormalTypeSetIterConst = NormalTypeSet::const_iterator;
        inline NormalTypePtr makeNormalType() { return std::make_shared<NormalType>(); }
		inline NormalTypePtr makeNormalType( const t::NoteTypeValue& value ) { return std::make_shared<NormalType>( value ); }
		inline NormalTypePtr makeNormalType( t::NoteTypeValue&& value ) { return std::make_shared<NormalType>( std::move( value ) ); }
        class NormalType : public ElementInterface
        {
        public:
            NormalType();
            NormalType( const t::NoteTypeValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::NoteTypeValue getValue() const;
            void setValue( const t::NoteTypeValue& value );
        private:
            t::NoteTypeValue myValue;
        };
        
        
        /**************** CreditType ****************
         5657
         <xs:element name="credit-type" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class CreditType;
        using CreditTypePtr = std::shared_ptr<CreditType>;
        using CreditTypeUPtr = std::unique_ptr<CreditType>;
        using CreditTypeSet = std::vector<CreditTypePtr>;
        using CreditTypeSetIter = CreditTypeSet::iterator;
        using CreditTypeSetIterConst = CreditTypeSet::const_iterator;
        inline CreditTypePtr makeCreditType() { return std::make_shared<CreditType>(); }
		inline CreditTypePtr makeCreditType( const t::XsString& value ) { return std::make_shared<CreditType>( value ); }
		inline CreditTypePtr makeCreditType( t::XsString&& value ) { return std::make_shared<CreditType>( std::move( value ) ); }
        class CreditType : public ElementInterface
        {
        public:
            CreditType();
            CreditType( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** InstrumentName ****************
         5879
         <xs:element name="instrument-name" type="xs:string">   <xs:annotation>     <xs:documentation>The instrument-name element is typically used within a software application rather than appearing on the printed page of a score.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class InstrumentName;
        using InstrumentNamePtr = std::shared_ptr<InstrumentName>;
        using InstrumentNameUPtr = std::unique_ptr<InstrumentName>;
        using InstrumentNameSet = std::vector<InstrumentNamePtr>;
        using InstrumentNameSetIter = InstrumentNameSet::iterator;
        using InstrumentNameSetIterConst = InstrumentNameSet::const_iterator;
        inline InstrumentNamePtr makeInstrumentName() { return std::make_shared<InstrumentName>(); }
		inline InstrumentNamePtr makeInstrumentName( const t::XsString& value ) { return std::make_shared<InstrumentName>( value ); }
		inline InstrumentNamePtr makeInstrumentName( t::XsString&& value ) { return std::make_shared<InstrumentName>( std::move( value ) ); }
        class InstrumentName : public ElementInterface
        {
        public:
            InstrumentName();
            InstrumentName( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** InstrumentAbbreviation ****************
         5884
         <xs:element name="instrument-abbreviation" type="xs:string" minOccurs="0"> <xs:annotation>     <xs:documentation>The optional instrument-abbreviation element is typically used within a software application rather than appearing on the printed page of a score.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class InstrumentAbbreviation;
        using InstrumentAbbreviationPtr = std::shared_ptr<InstrumentAbbreviation>;
        using InstrumentAbbreviationUPtr = std::unique_ptr<InstrumentAbbreviation>;
        using InstrumentAbbreviationSet = std::vector<InstrumentAbbreviationPtr>;
        using InstrumentAbbreviationSetIter = InstrumentAbbreviationSet::iterator;
        using InstrumentAbbreviationSetIterConst = InstrumentAbbreviationSet::const_iterator;
        inline InstrumentAbbreviationPtr makeInstrumentAbbreviation() { return std::make_shared<InstrumentAbbreviation>(); }
		inline InstrumentAbbreviationPtr makeInstrumentAbbreviation( const t::XsString& value ) { return std::make_shared<InstrumentAbbreviation>( value ); }
		inline InstrumentAbbreviationPtr makeInstrumentAbbreviation( t::XsString&& value ) { return std::make_shared<InstrumentAbbreviation>( std::move( value ) ); }
        class InstrumentAbbreviation : public ElementInterface
        {
        public:
            InstrumentAbbreviation();
            InstrumentAbbreviation( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** InstrumentSound ****************
         5890
         <xs:element name="instrument-sound" type="xs:string" minOccurs="0">    <xs:annotation>     <xs:documentation>The instrument-sound element describes the default timbre of the score-instrument. This description is independent of a particular virtual or MIDI instrument specification and allows playback to be shared more easily between applications and libraries.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class InstrumentSound;
        using InstrumentSoundPtr = std::shared_ptr<InstrumentSound>;
        using InstrumentSoundUPtr = std::unique_ptr<InstrumentSound>;
        using InstrumentSoundSet = std::vector<InstrumentSoundPtr>;
        using InstrumentSoundSetIter = InstrumentSoundSet::iterator;
        using InstrumentSoundSetIterConst = InstrumentSoundSet::const_iterator;
        inline InstrumentSoundPtr makeInstrumentSound() { return std::make_shared<InstrumentSound>(); }
		inline InstrumentSoundPtr makeInstrumentSound( const t::XsString& value ) { return std::make_shared<InstrumentSound>( value ); }
		inline InstrumentSoundPtr makeInstrumentSound( t::XsString&& value ) { return std::make_shared<InstrumentSound>( std::move( value ) ); }
        class InstrumentSound : public ElementInterface
        {
        public:
            InstrumentSound();
            InstrumentSound( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** Ensemble ****************
         5903
         <xs:element name="ensemble" type="positive-integer-or-empty">  <xs:annotation>     <xs:documentation>The ensemble element was added in Version 2.0. It is present if performance is intended by an ensemble such as an orchestral section. The text of the ensemble element contains the size of the section or is empty if the ensemble size is not specified.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="positive-integer-or-empty">
         <xs:annotation>
         <xs:documentation>The positive-integer-or-empty values can be either a positive integer or an empty string.</xs:documentation>
         </xs:annotation>
         <xs:union memberTypes="xs:positiveInteger">
         <xs:simpleType>
         <xs:restriction base="xs:string">
         <xs:enumeration value=""/>
         </xs:restriction>
         </xs:simpleType>
         </xs:union>
         </xs:simpleType>
         <xs:simpleType name="positive-integer-or-empty">
         <xs:annotation>
         <xs:documentation>The positive-integer-or-empty values can be either a positive integer or an empty string.</xs:documentation>
         </xs:annotation>
         <xs:union memberTypes="xs:positiveInteger">
         <xs:simpleType>
         <xs:restriction base="xs:string">
         <xs:enumeration value=""/>
         </xs:restriction>
         </xs:simpleType>
         </xs:union>
         </xs:simpleType>
         */
        class Ensemble;
        using EnsemblePtr = std::shared_ptr<Ensemble>;
        using EnsembleUPtr = std::unique_ptr<Ensemble>;
        using EnsembleSet = std::vector<EnsemblePtr>;
        using EnsembleSetIter = EnsembleSet::iterator;
        using EnsembleSetIterConst = EnsembleSet::const_iterator;
        inline EnsemblePtr makeEnsemble() { return std::make_shared<Ensemble>(); }
		inline EnsemblePtr makeEnsemble( const t::PositiveIntegerOrEmpty& value ) { return std::make_shared<Ensemble>( value ); }
		inline EnsemblePtr makeEnsemble( t::PositiveIntegerOrEmpty&& value ) { return std::make_shared<Ensemble>( std::move( value ) ); }
        class Ensemble : public ElementInterface
        {
        public:
            Ensemble();
            Ensemble( const t::PositiveIntegerOrEmpty& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::PositiveIntegerOrEmpty getValue() const;
            void setValue( const t::PositiveIntegerOrEmpty& value );
        private:
            t::PositiveIntegerOrEmpty myValue;
        };
        
        
        /**************** Group ****************
         5940
         <xs:element name="group" type="xs:string" minOccurs="0" maxOccurs="unbounded"> <xs:annotation>     <xs:documentation>The group element allows the use of different versions of the part for different purposes. Typical values include score parts sound and data. Ordering information that is directly encoded in MuseData can be derived from the ordering within a MusicXML score or opus.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class Group;
        using GroupPtr = std::shared_ptr<Group>;
        using GroupUPtr = std::unique_ptr<Group>;
        using GroupSet = std::vector<GroupPtr>;
        using GroupSetIter = GroupSet::iterator;
        using GroupSetIterConst = GroupSet::const_iterator;
        inline GroupPtr makeGroup() { return std::make_shared<Group>(); }
		inline GroupPtr makeGroup( const t::XsString& value ) { return std::make_shared<Group>( value ); }
		inline GroupPtr makeGroup( t::XsString&& value ) { return std::make_shared<Group>( std::move( value ) ); }
        class Group : public ElementInterface
        {
        public:
            Group();
            Group( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** VirtualLibrary ****************
         5972
         <xs:element name="virtual-library" type="xs:string" minOccurs="0"> <xs:annotation>     <xs:documentation>The virtual-library element indicates the virtual instrument library name.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class VirtualLibrary;
        using VirtualLibraryPtr = std::shared_ptr<VirtualLibrary>;
        using VirtualLibraryUPtr = std::unique_ptr<VirtualLibrary>;
        using VirtualLibrarySet = std::vector<VirtualLibraryPtr>;
        using VirtualLibrarySetIter = VirtualLibrarySet::iterator;
        using VirtualLibrarySetIterConst = VirtualLibrarySet::const_iterator;
        inline VirtualLibraryPtr makeVirtualLibrary() { return std::make_shared<VirtualLibrary>(); }
		inline VirtualLibraryPtr makeVirtualLibrary( const t::XsString& value ) { return std::make_shared<VirtualLibrary>( value ); }
		inline VirtualLibraryPtr makeVirtualLibrary( t::XsString&& value ) { return std::make_shared<VirtualLibrary>( std::move( value ) ); }
        class VirtualLibrary : public ElementInterface
        {
        public:
            VirtualLibrary();
            VirtualLibrary( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** VirtualName ****************
         5978
         <xs:element name="virtual-name" type="xs:string" minOccurs="0">    <xs:annotation>     <xs:documentation>The virtual-name element indicates the library-specific name for the virtual instrument.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class VirtualName;
        using VirtualNamePtr = std::shared_ptr<VirtualName>;
        using VirtualNameUPtr = std::unique_ptr<VirtualName>;
        using VirtualNameSet = std::vector<VirtualNamePtr>;
        using VirtualNameSetIter = VirtualNameSet::iterator;
        using VirtualNameSetIterConst = VirtualNameSet::const_iterator;
        inline VirtualNamePtr makeVirtualName() { return std::make_shared<VirtualName>(); }
		inline VirtualNamePtr makeVirtualName( const t::XsString& value ) { return std::make_shared<VirtualName>( value ); }
		inline VirtualNamePtr makeVirtualName( t::XsString&& value ) { return std::make_shared<VirtualName>( std::move( value ) ); }
        class VirtualName : public ElementInterface
        {
        public:
            VirtualName();
            VirtualName( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** WorkNumber ****************
         5989
         <xs:element name="work-number" type="xs:string" minOccurs="0"> <xs:annotation>     <xs:documentation>The work-number element specifies the number of a work such as its opus number.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class WorkNumber;
        using WorkNumberPtr = std::shared_ptr<WorkNumber>;
        using WorkNumberUPtr = std::unique_ptr<WorkNumber>;
        using WorkNumberSet = std::vector<WorkNumberPtr>;
        using WorkNumberSetIter = WorkNumberSet::iterator;
        using WorkNumberSetIterConst = WorkNumberSet::const_iterator;
        inline WorkNumberPtr makeWorkNumber() { return std::make_shared<WorkNumber>(); }
		inline WorkNumberPtr makeWorkNumber( const t::XsString& value ) { return std::make_shared<WorkNumber>( value ); }
		inline WorkNumberPtr makeWorkNumber( t::XsString&& value ) { return std::make_shared<WorkNumber>( std::move( value ) ); }
        class WorkNumber : public ElementInterface
        {
        public:
            WorkNumber();
            WorkNumber( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** WorkTitle ****************
         5995
         <xs:element name="work-title" type="xs:string" minOccurs="0">  <xs:annotation>     <xs:documentation>The work-title element specifies the title of a work not including its opus or other work number.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class WorkTitle;
        using WorkTitlePtr = std::shared_ptr<WorkTitle>;
        using WorkTitleUPtr = std::unique_ptr<WorkTitle>;
        using WorkTitleSet = std::vector<WorkTitlePtr>;
        using WorkTitleSetIter = WorkTitleSet::iterator;
        using WorkTitleSetIterConst = WorkTitleSet::const_iterator;
        inline WorkTitlePtr makeWorkTitle() { return std::make_shared<WorkTitle>(); }
		inline WorkTitlePtr makeWorkTitle( const t::XsString& value ) { return std::make_shared<WorkTitle>( value ); }
		inline WorkTitlePtr makeWorkTitle( t::XsString&& value ) { return std::make_shared<WorkTitle>( std::move( value ) ); }
        class WorkTitle : public ElementInterface
        {
        public:
            WorkTitle();
            WorkTitle( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** Staff ****************
         6065
         <xs:element name="staff" type="xs:positiveInteger">    <xs:annotation>     <xs:documentation>Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers with 1 referring to the top-most staff in a part.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="xs:positiveInteger"/>
         <xs:simpleType name="xs:positiveInteger"/>
         */
        class Staff;
        using StaffPtr = std::shared_ptr<Staff>;
        using StaffUPtr = std::unique_ptr<Staff>;
        using StaffSet = std::vector<StaffPtr>;
        using StaffSetIter = StaffSet::iterator;
        using StaffSetIterConst = StaffSet::const_iterator;
        inline StaffPtr makeStaff() { return std::make_shared<Staff>(); }
		inline StaffPtr makeStaff( const t::PositiveInteger& value ) { return std::make_shared<Staff>( value ); }
		inline StaffPtr makeStaff( t::PositiveInteger&& value ) { return std::make_shared<Staff>( std::move( value ) ); }
        class Staff : public ElementInterface
        {
        public:
            Staff();
            Staff( const t::PositiveInteger& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::PositiveInteger getValue() const;
            void setValue( const t::PositiveInteger& value );
        private:
            t::PositiveInteger myValue;
        };
        
        
        /**************** TuningStep ****************
         6075
         <xs:element name="tuning-step" type="step">    <xs:annotation>     <xs:documentation>The tuning-step element is represented like the step element with a different name to reflect is different function.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class TuningStep;
        using TuningStepPtr = std::shared_ptr<TuningStep>;
        using TuningStepUPtr = std::unique_ptr<TuningStep>;
        using TuningStepSet = std::vector<TuningStepPtr>;
        using TuningStepSetIter = TuningStepSet::iterator;
        using TuningStepSetIterConst = TuningStepSet::const_iterator;
        inline TuningStepPtr makeTuningStep() { return std::make_shared<TuningStep>(); }
		inline TuningStepPtr makeTuningStep( const t::StepEnum& value ) { return std::make_shared<TuningStep>( value ); }
		inline TuningStepPtr makeTuningStep( t::StepEnum&& value ) { return std::make_shared<TuningStep>( std::move( value ) ); }
        class TuningStep : public ElementInterface
        {
        public:
            TuningStep();
            TuningStep( const t::StepEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::StepEnum getValue() const;
            void setValue( const t::StepEnum& value );
        private:
            t::StepEnum myValue;
        };
        
        
        /**************** TuningAlter ****************
         6080
         <xs:element name="tuning-alter" type="semitones" minOccurs="0">    <xs:annotation>     <xs:documentation>The tuning-alter element is represented like the alter element with a different name to reflect is different function.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class TuningAlter;
        using TuningAlterPtr = std::shared_ptr<TuningAlter>;
        using TuningAlterUPtr = std::unique_ptr<TuningAlter>;
        using TuningAlterSet = std::vector<TuningAlterPtr>;
        using TuningAlterSetIter = TuningAlterSet::iterator;
        using TuningAlterSetIterConst = TuningAlterSet::const_iterator;
        inline TuningAlterPtr makeTuningAlter() { return std::make_shared<TuningAlter>(); }
		inline TuningAlterPtr makeTuningAlter( const t::Semitones& value ) { return std::make_shared<TuningAlter>( value ); }
		inline TuningAlterPtr makeTuningAlter( t::Semitones&& value ) { return std::make_shared<TuningAlter>( std::move( value ) ); }
        class TuningAlter : public ElementInterface
        {
        public:
            TuningAlter();
            TuningAlter( const t::Semitones& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Semitones getValue() const;
            void setValue( const t::Semitones& value );
        private:
            t::Semitones myValue;
        };
        
        
        /**************** TuningOctave ****************
         6086
         <xs:element name="tuning-octave" type="octave">    <xs:annotation>     <xs:documentation>The tuning-octave element is represented like the octave element with a different name to reflect is different function.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="octave">
         <xs:annotation>
         <xs:documentation>Octaves are represented by the numbers 0 to 9, where 4 indicates the octave started by middle C.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer">
         <xs:minInclusive value="0"/>
         <xs:maxInclusive value="9"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="octave">
         <xs:annotation>
         <xs:documentation>Octaves are represented by the numbers 0 to 9, where 4 indicates the octave started by middle C.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer">
         <xs:minInclusive value="0"/>
         <xs:maxInclusive value="9"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class TuningOctave;
        using TuningOctavePtr = std::shared_ptr<TuningOctave>;
        using TuningOctaveUPtr = std::unique_ptr<TuningOctave>;
        using TuningOctaveSet = std::vector<TuningOctavePtr>;
        using TuningOctaveSetIter = TuningOctaveSet::iterator;
        using TuningOctaveSetIterConst = TuningOctaveSet::const_iterator;
        inline TuningOctavePtr makeTuningOctave() { return std::make_shared<TuningOctave>(); }
		inline TuningOctavePtr makeTuningOctave( const t::OctaveValue& value ) { return std::make_shared<TuningOctave>( value ); }
		inline TuningOctavePtr makeTuningOctave( t::OctaveValue&& value ) { return std::make_shared<TuningOctave>( std::move( value ) ); }
        class TuningOctave : public ElementInterface
        {
        public:
            TuningOctave();
            TuningOctave( const t::OctaveValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::OctaveValue getValue() const;
            void setValue( const t::OctaveValue& value );
        private:
            t::OctaveValue myValue;
        };
        
        
        /**************** Voice ****************
         6096
         <xs:element name="voice" type="xs:string"/>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class Voice;
        using VoicePtr = std::shared_ptr<Voice>;
        using VoiceUPtr = std::unique_ptr<Voice>;
        using VoiceSet = std::vector<VoicePtr>;
        using VoiceSetIter = VoiceSet::iterator;
        using VoiceSetIterConst = VoiceSet::const_iterator;
        inline VoicePtr makeVoice() { return std::make_shared<Voice>(); }
		inline VoicePtr makeVoice( const t::XsString& value ) { return std::make_shared<Voice>( value ); }
		inline VoicePtr makeVoice( t::XsString&& value ) { return std::make_shared<Voice>( std::move( value ) ); }
        class Voice : public ElementInterface
        {
        public:
            Voice();
            Voice( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** KeyStep ****************
         6104
         <xs:element name="key-step" type="step">   <xs:annotation>     <xs:documentation>Non-traditional key signatures can be represented using the Humdrum/Scot concept of a list of altered tones. The key-step element indicates the pitch step to be altered represented using the same names as in the step element.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class KeyStep;
        using KeyStepPtr = std::shared_ptr<KeyStep>;
        using KeyStepUPtr = std::unique_ptr<KeyStep>;
        using KeyStepSet = std::vector<KeyStepPtr>;
        using KeyStepSetIter = KeyStepSet::iterator;
        using KeyStepSetIterConst = KeyStepSet::const_iterator;
        inline KeyStepPtr makeKeyStep() { return std::make_shared<KeyStep>(); }
		inline KeyStepPtr makeKeyStep( const t::StepEnum& value ) { return std::make_shared<KeyStep>( value ); }
		inline KeyStepPtr makeKeyStep( t::StepEnum&& value ) { return std::make_shared<KeyStep>( std::move( value ) ); }
        class KeyStep : public ElementInterface
        {
        public:
            KeyStep();
            KeyStep( const t::StepEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::StepEnum getValue() const;
            void setValue( const t::StepEnum& value );
        private:
            t::StepEnum myValue;
        };
        
        
        /**************** KeyAlter ****************
         6109
         <xs:element name="key-alter" type="semitones"> <xs:annotation>     <xs:documentation>Non-traditional key signatures can be represented using the Humdrum/Scot concept of a list of altered tones. The key-alter element represents the alteration for a given pitch step represented with semitones in the same manner as the alter element.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="semitones">
         <xs:annotation>
         <xs:documentation>The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class KeyAlter;
        using KeyAlterPtr = std::shared_ptr<KeyAlter>;
        using KeyAlterUPtr = std::unique_ptr<KeyAlter>;
        using KeyAlterSet = std::vector<KeyAlterPtr>;
        using KeyAlterSetIter = KeyAlterSet::iterator;
        using KeyAlterSetIterConst = KeyAlterSet::const_iterator;
        inline KeyAlterPtr makeKeyAlter() { return std::make_shared<KeyAlter>(); }
		inline KeyAlterPtr makeKeyAlter( const t::Semitones& value ) { return std::make_shared<KeyAlter>( value ); }
		inline KeyAlterPtr makeKeyAlter( t::Semitones&& value ) { return std::make_shared<KeyAlter>( std::move( value ) ); }
        class KeyAlter : public ElementInterface
        {
        public:
            KeyAlter();
            KeyAlter( const t::Semitones& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::Semitones getValue() const;
            void setValue( const t::Semitones& value );
        private:
            t::Semitones myValue;
        };
        
        
        /**************** KeyAccidental ****************
         6114
         <xs:element name="key-accidental" type="accidental-value" minOccurs="0">   <xs:annotation>     <xs:documentation>Non-traditional key signatures can be represented using the Humdrum/Scot concept of a list of altered tones. The key-accidental element indicates the accidental to be displayed in the key signature represented in the same manner as the accidental element. It is used for disambiguating microtonal accidentals.</xs:documentation>  </xs:annotation></xs:element>
         <xs:simpleType name="accidental-value">
         <xs:annotation>
         <xs:documentation>The accidental-value type represents notated accidentals supported by MusicXML. In the MusicXML 2.0 DTD this was a string with values that could be included. The XSD strengthens the data typing to an enumerated list. The quarter- and three-quarters- accidentals are Tartini-style quarter-tone accidentals. The -down and -up accidentals are quarter-tone accidentals that include arrows pointing down or up. The slash- accidentals are used in Turkish classical music. The numbered sharp and flat accidentals are superscripted versions of the accidental signs, used in Turkish folk music. The sori and koron accidentals are microtonal sharp and flat accidentals used in Iranian and Persian music.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="sharp"/>
         <xs:enumeration value="natural"/>
         <xs:enumeration value="flat"/>
         <xs:enumeration value="double-sharp"/>
         <xs:enumeration value="sharp-sharp"/>
         <xs:enumeration value="flat-flat"/>
         <xs:enumeration value="natural-sharp"/>
         <xs:enumeration value="natural-flat"/>
         <xs:enumeration value="quarter-flat"/>
         <xs:enumeration value="quarter-sharp"/>
         <xs:enumeration value="three-quarters-flat"/>
         <xs:enumeration value="three-quarters-sharp"/>
         <xs:enumeration value="sharp-down"/>
         <xs:enumeration value="sharp-up"/>
         <xs:enumeration value="natural-down"/>
         <xs:enumeration value="natural-up"/>
         <xs:enumeration value="flat-down"/>
         <xs:enumeration value="flat-up"/>
         <xs:enumeration value="triple-sharp"/>
         <xs:enumeration value="triple-flat"/>
         <xs:enumeration value="slash-quarter-sharp"/>
         <xs:enumeration value="slash-sharp"/>
         <xs:enumeration value="slash-flat"/>
         <xs:enumeration value="double-slash-flat"/>
         <xs:enumeration value="sharp-1"/>
         <xs:enumeration value="sharp-2"/>
         <xs:enumeration value="sharp-3"/>
         <xs:enumeration value="sharp-5"/>
         <xs:enumeration value="flat-1"/>
         <xs:enumeration value="flat-2"/>
         <xs:enumeration value="flat-3"/>
         <xs:enumeration value="flat-4"/>
         <xs:enumeration value="sori"/>
         <xs:enumeration value="koron"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="accidental-value">
         <xs:annotation>
         <xs:documentation>The accidental-value type represents notated accidentals supported by MusicXML. In the MusicXML 2.0 DTD this was a string with values that could be included. The XSD strengthens the data typing to an enumerated list. The quarter- and three-quarters- accidentals are Tartini-style quarter-tone accidentals. The -down and -up accidentals are quarter-tone accidentals that include arrows pointing down or up. The slash- accidentals are used in Turkish classical music. The numbered sharp and flat accidentals are superscripted versions of the accidental signs, used in Turkish folk music. The sori and koron accidentals are microtonal sharp and flat accidentals used in Iranian and Persian music.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="sharp"/>
         <xs:enumeration value="natural"/>
         <xs:enumeration value="flat"/>
         <xs:enumeration value="double-sharp"/>
         <xs:enumeration value="sharp-sharp"/>
         <xs:enumeration value="flat-flat"/>
         <xs:enumeration value="natural-sharp"/>
         <xs:enumeration value="natural-flat"/>
         <xs:enumeration value="quarter-flat"/>
         <xs:enumeration value="quarter-sharp"/>
         <xs:enumeration value="three-quarters-flat"/>
         <xs:enumeration value="three-quarters-sharp"/>
         <xs:enumeration value="sharp-down"/>
         <xs:enumeration value="sharp-up"/>
         <xs:enumeration value="natural-down"/>
         <xs:enumeration value="natural-up"/>
         <xs:enumeration value="flat-down"/>
         <xs:enumeration value="flat-up"/>
         <xs:enumeration value="triple-sharp"/>
         <xs:enumeration value="triple-flat"/>
         <xs:enumeration value="slash-quarter-sharp"/>
         <xs:enumeration value="slash-sharp"/>
         <xs:enumeration value="slash-flat"/>
         <xs:enumeration value="double-slash-flat"/>
         <xs:enumeration value="sharp-1"/>
         <xs:enumeration value="sharp-2"/>
         <xs:enumeration value="sharp-3"/>
         <xs:enumeration value="sharp-5"/>
         <xs:enumeration value="flat-1"/>
         <xs:enumeration value="flat-2"/>
         <xs:enumeration value="flat-3"/>
         <xs:enumeration value="flat-4"/>
         <xs:enumeration value="sori"/>
         <xs:enumeration value="koron"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class KeyAccidental;
        using KeyAccidentalPtr = std::shared_ptr<KeyAccidental>;
        using KeyAccidentalUPtr = std::unique_ptr<KeyAccidental>;
        using KeyAccidentalSet = std::vector<KeyAccidentalPtr>;
        using KeyAccidentalSetIter = KeyAccidentalSet::iterator;
        using KeyAccidentalSetIterConst = KeyAccidentalSet::const_iterator;
        inline KeyAccidentalPtr makeKeyAccidental() { return std::make_shared<KeyAccidental>(); }
		inline KeyAccidentalPtr makeKeyAccidental( const t::AccidentalValue& value ) { return std::make_shared<KeyAccidental>( value ); }
		inline KeyAccidentalPtr makeKeyAccidental( t::AccidentalValue&& value ) { return std::make_shared<KeyAccidental>( std::move( value ) ); }
        class KeyAccidental : public ElementInterface
        {
        public:
            KeyAccidental();
            KeyAccidental( const t::AccidentalValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::AccidentalValue getValue() const;
            void setValue( const t::AccidentalValue& value );
        private:
            t::AccidentalValue myValue;
        };
        
        
        /**************** SlashType ****************
         6125
         <xs:element name="slash-type" type="note-type-value">  <xs:annotation>     <xs:documentation>The slash-type element indicates the graphical note type to use for the display of repetition marks.</xs:documentation>   </xs:annotation></xs:element>
         <xs:simpleType name="note-type-value">
         <xs:annotation>
         <xs:documentation>The note-type type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="1024th"/>
         <xs:enumeration value="512th"/>
         <xs:enumeration value="256th"/>
         <xs:enumeration value="128th"/>
         <xs:enumeration value="64th"/>
         <xs:enumeration value="32nd"/>
         <xs:enumeration value="16th"/>
         <xs:enumeration value="eighth"/>
         <xs:enumeration value="quarter"/>
         <xs:enumeration value="half"/>
         <xs:enumeration value="whole"/>
         <xs:enumeration value="breve"/>
         <xs:enumeration value="long"/>
         <xs:enumeration value="maxima"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="note-type-value">
         <xs:annotation>
         <xs:documentation>The note-type type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="1024th"/>
         <xs:enumeration value="512th"/>
         <xs:enumeration value="256th"/>
         <xs:enumeration value="128th"/>
         <xs:enumeration value="64th"/>
         <xs:enumeration value="32nd"/>
         <xs:enumeration value="16th"/>
         <xs:enumeration value="eighth"/>
         <xs:enumeration value="quarter"/>
         <xs:enumeration value="half"/>
         <xs:enumeration value="whole"/>
         <xs:enumeration value="breve"/>
         <xs:enumeration value="long"/>
         <xs:enumeration value="maxima"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class SlashType;
        using SlashTypePtr = std::shared_ptr<SlashType>;
        using SlashTypeUPtr = std::unique_ptr<SlashType>;
        using SlashTypeSet = std::vector<SlashTypePtr>;
        using SlashTypeSetIter = SlashTypeSet::iterator;
        using SlashTypeSetIterConst = SlashTypeSet::const_iterator;
        inline SlashTypePtr makeSlashType() { return std::make_shared<SlashType>(); }
		inline SlashTypePtr makeSlashType( const t::NoteTypeValue& value ) { return std::make_shared<SlashType>( value ); }
		inline SlashTypePtr makeSlashType( t::NoteTypeValue&& value ) { return std::make_shared<SlashType>( std::move( value ) ); }
        class SlashType : public ElementInterface
        {
        public:
            SlashType();
            SlashType( const t::NoteTypeValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::NoteTypeValue getValue() const;
            void setValue( const t::NoteTypeValue& value );
        private:
            t::NoteTypeValue myValue;
        };
        
        
        /**************** Beats ****************
         6142
         <xs:element name="beats" type="xs:string"> <xs:annotation>     <xs:documentation>The beats element indicates the number of beats as found in the numerator of a time signature.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class Beats;
        using BeatsPtr = std::shared_ptr<Beats>;
        using BeatsUPtr = std::unique_ptr<Beats>;
        using BeatsSet = std::vector<BeatsPtr>;
        using BeatsSetIter = BeatsSet::iterator;
        using BeatsSetIterConst = BeatsSet::const_iterator;
        inline BeatsPtr makeBeats() { return std::make_shared<Beats>(); }
		inline BeatsPtr makeBeats( const t::XsString& value ) { return std::make_shared<Beats>( value ); }
		inline BeatsPtr makeBeats( t::XsString&& value ) { return std::make_shared<Beats>( std::move( value ) ); }
        class Beats : public ElementInterface
        {
        public:
            Beats();
            Beats( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** BeatType ****************
         6147
         <xs:element name="beat-type" type="xs:string"> <xs:annotation>     <xs:documentation>The beat-type element indicates the beat unit as found in the denominator of a time signature.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class BeatType;
        using BeatTypePtr = std::shared_ptr<BeatType>;
        using BeatTypeUPtr = std::unique_ptr<BeatType>;
        using BeatTypeSet = std::vector<BeatTypePtr>;
        using BeatTypeSetIter = BeatTypeSet::iterator;
        using BeatTypeSetIterConst = BeatTypeSet::const_iterator;
        inline BeatTypePtr makeBeatType() { return std::make_shared<BeatType>(); }
		inline BeatTypePtr makeBeatType( const t::XsString& value ) { return std::make_shared<BeatType>( value ); }
		inline BeatTypePtr makeBeatType( t::XsString&& value ) { return std::make_shared<BeatType>( std::move( value ) ); }
        class BeatType : public ElementInterface
        {
        public:
            BeatType();
            BeatType( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** Fifths ****************
         6161
         <xs:element name="fifths" type="fifths"/>
         <xs:simpleType name="fifths">
         <xs:annotation>
         <xs:documentation>The fifths type represents the number of flats or sharps in a traditional key signature. Negative numbers are used for flats and positive numbers for sharps, reflecting the key's placement within the circle of fifths (hence the type name).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer"/>
         </xs:simpleType>
         <xs:simpleType name="fifths">
         <xs:annotation>
         <xs:documentation>The fifths type represents the number of flats or sharps in a traditional key signature. Negative numbers are used for flats and positive numbers for sharps, reflecting the key's placement within the circle of fifths (hence the type name).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer"/>
         </xs:simpleType>
         */
        class Fifths;
        using FifthsPtr = std::shared_ptr<Fifths>;
        using FifthsUPtr = std::unique_ptr<Fifths>;
        using FifthsSet = std::vector<FifthsPtr>;
        using FifthsSetIter = FifthsSet::iterator;
        using FifthsSetIterConst = FifthsSet::const_iterator;
        inline FifthsPtr makeFifths() { return std::make_shared<Fifths>(); }
		inline FifthsPtr makeFifths( const t::FifthsValue& value ) { return std::make_shared<Fifths>( value ); }
		inline FifthsPtr makeFifths( t::FifthsValue&& value ) { return std::make_shared<Fifths>( std::move( value ) ); }
        class Fifths : public ElementInterface
        {
        public:
            Fifths();
            Fifths( const t::FifthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::FifthsValue getValue() const;
            void setValue( const t::FifthsValue& value );
        private:
            t::FifthsValue myValue;
        };
        
        
        /**************** Mode ****************
         6164
         <xs:element name="mode" type="mode" minOccurs="0"/>
         <xs:simpleType name="mode">
         <xs:annotation>
         <xs:documentation>The mode type is used to specify major/minor and other mode distinctions. Valid mode values include major, minor, dorian, phrygian, lydian, mixolydian, aeolian, ionian, locrian, and none.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string"/>
         </xs:simpleType>
         <xs:simpleType name="mode">
         <xs:annotation>
         <xs:documentation>The mode type is used to specify major/minor and other mode distinctions. Valid mode values include major, minor, dorian, phrygian, lydian, mixolydian, aeolian, ionian, locrian, and none.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string"/>
         </xs:simpleType>
         */
        class Mode;
        using ModePtr = std::shared_ptr<Mode>;
        using ModeUPtr = std::unique_ptr<Mode>;
        using ModeSet = std::vector<ModePtr>;
        using ModeSetIter = ModeSet::iterator;
        using ModeSetIterConst = ModeSet::const_iterator;
        inline ModePtr makeMode() { return std::make_shared<Mode>(); }
		inline ModePtr makeMode( const t::ModeValue& value ) { return std::make_shared<Mode>( value ); }
		inline ModePtr makeMode( t::ModeValue&& value ) { return std::make_shared<Mode>( std::move( value ) ); }
        class Mode : public ElementInterface
        {
        public:
            Mode();
            Mode( const t::ModeValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::ModeValue getValue() const;
            void setValue( const t::ModeValue& value );
        private:
            t::ModeValue myValue;
        };
        
        
        /**************** BeatUnit ****************
         6173
         <xs:element name="beat-unit" type="note-type-value">   <xs:annotation>     <xs:documentation>The beat-unit element indicates the graphical note type to use in a metronome mark.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="note-type-value">
         <xs:annotation>
         <xs:documentation>The note-type type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="1024th"/>
         <xs:enumeration value="512th"/>
         <xs:enumeration value="256th"/>
         <xs:enumeration value="128th"/>
         <xs:enumeration value="64th"/>
         <xs:enumeration value="32nd"/>
         <xs:enumeration value="16th"/>
         <xs:enumeration value="eighth"/>
         <xs:enumeration value="quarter"/>
         <xs:enumeration value="half"/>
         <xs:enumeration value="whole"/>
         <xs:enumeration value="breve"/>
         <xs:enumeration value="long"/>
         <xs:enumeration value="maxima"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="note-type-value">
         <xs:annotation>
         <xs:documentation>The note-type type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="1024th"/>
         <xs:enumeration value="512th"/>
         <xs:enumeration value="256th"/>
         <xs:enumeration value="128th"/>
         <xs:enumeration value="64th"/>
         <xs:enumeration value="32nd"/>
         <xs:enumeration value="16th"/>
         <xs:enumeration value="eighth"/>
         <xs:enumeration value="quarter"/>
         <xs:enumeration value="half"/>
         <xs:enumeration value="whole"/>
         <xs:enumeration value="breve"/>
         <xs:enumeration value="long"/>
         <xs:enumeration value="maxima"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class BeatUnit;
        using BeatUnitPtr = std::shared_ptr<BeatUnit>;
        using BeatUnitUPtr = std::unique_ptr<BeatUnit>;
        using BeatUnitSet = std::vector<BeatUnitPtr>;
        using BeatUnitSetIter = BeatUnitSet::iterator;
        using BeatUnitSetIterConst = BeatUnitSet::const_iterator;
        inline BeatUnitPtr makeBeatUnit() { return std::make_shared<BeatUnit>(); }
		inline BeatUnitPtr makeBeatUnit( const t::NoteTypeValue& value ) { return std::make_shared<BeatUnit>( value ); }
		inline BeatUnitPtr makeBeatUnit( t::NoteTypeValue&& value ) { return std::make_shared<BeatUnit>( std::move( value ) ); }
        class BeatUnit : public ElementInterface
        {
        public:
            BeatUnit();
            BeatUnit( const t::NoteTypeValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::NoteTypeValue getValue() const;
            void setValue( const t::NoteTypeValue& value );
        private:
            t::NoteTypeValue myValue;
        };
        
        
        /**************** TopMargin ****************
         6222
         <xs:element name="top-margin" type="tenths"/>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class TopMargin;
        using TopMarginPtr = std::shared_ptr<TopMargin>;
        using TopMarginUPtr = std::unique_ptr<TopMargin>;
        using TopMarginSet = std::vector<TopMarginPtr>;
        using TopMarginSetIter = TopMarginSet::iterator;
        using TopMarginSetIterConst = TopMarginSet::const_iterator;
        inline TopMarginPtr makeTopMargin() { return std::make_shared<TopMargin>(); }
		inline TopMarginPtr makeTopMargin( const t::TenthsValue& value ) { return std::make_shared<TopMargin>( value ); }
		inline TopMarginPtr makeTopMargin( t::TenthsValue&& value ) { return std::make_shared<TopMargin>( std::move( value ) ); }
        class TopMargin : public ElementInterface
        {
        public:
            TopMargin();
            TopMargin( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
        };
        
        
        /**************** BottomMargin ****************
         6225
         <xs:element name="bottom-margin" type="tenths"/>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class BottomMargin;
        using BottomMarginPtr = std::shared_ptr<BottomMargin>;
        using BottomMarginUPtr = std::unique_ptr<BottomMargin>;
        using BottomMarginSet = std::vector<BottomMarginPtr>;
        using BottomMarginSetIter = BottomMarginSet::iterator;
        using BottomMarginSetIterConst = BottomMarginSet::const_iterator;
        inline BottomMarginPtr makeBottomMargin() { return std::make_shared<BottomMargin>(); }
		inline BottomMarginPtr makeBottomMargin( const t::TenthsValue& value ) { return std::make_shared<BottomMargin>( value ); }
		inline BottomMarginPtr makeBottomMargin( t::TenthsValue&& value ) { return std::make_shared<BottomMargin>( std::move( value ) ); }
        class BottomMargin : public ElementInterface
        {
        public:
            BottomMargin();
            BottomMargin( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
        };
        
        
        /**************** LeftMargin ****************
         6251
         <xs:element name="left-margin" type="tenths"/>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class LeftMargin;
        using LeftMarginPtr = std::shared_ptr<LeftMargin>;
        using LeftMarginUPtr = std::unique_ptr<LeftMargin>;
        using LeftMarginSet = std::vector<LeftMarginPtr>;
        using LeftMarginSetIter = LeftMarginSet::iterator;
        using LeftMarginSetIterConst = LeftMarginSet::const_iterator;
        inline LeftMarginPtr makeLeftMargin() { return std::make_shared<LeftMargin>(); }
		inline LeftMarginPtr makeLeftMargin( const t::TenthsValue& value ) { return std::make_shared<LeftMargin>( value ); }
		inline LeftMarginPtr makeLeftMargin( t::TenthsValue&& value ) { return std::make_shared<LeftMargin>( std::move( value ) ); }
        class LeftMargin : public ElementInterface
        {
        public:
            LeftMargin();
            LeftMargin( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
        };
        
        
        /**************** RightMargin ****************
         6254
         <xs:element name="right-margin" type="tenths"/>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         <xs:simpleType name="tenths">
         <xs:annotation>
         <xs:documentation>The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
         
         Distances in a MusicXML file are measured in tenths of staff space. TenthsValue are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:decimal"/>
         </xs:simpleType>
         */
        class RightMargin;
        using RightMarginPtr = std::shared_ptr<RightMargin>;
        using RightMarginUPtr = std::unique_ptr<RightMargin>;
        using RightMarginSet = std::vector<RightMarginPtr>;
        using RightMarginSetIter = RightMarginSet::iterator;
        using RightMarginSetIterConst = RightMarginSet::const_iterator;
        inline RightMarginPtr makeRightMargin() { return std::make_shared<RightMargin>(); }
		inline RightMarginPtr makeRightMargin( const t::TenthsValue& value ) { return std::make_shared<RightMargin>( value ); }
		inline RightMarginPtr makeRightMargin( t::TenthsValue&& value ) { return std::make_shared<RightMargin>( std::move( value ) ); }
        class RightMargin : public ElementInterface
        {
        public:
            RightMargin();
            RightMargin( const t::TenthsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::TenthsValue getValue() const;
            void setValue( const t::TenthsValue& value );
        private:
            t::TenthsValue myValue;
        };
        
        
        /**************** Duration ****************
         6262
         <xs:element name="duration" type="positive-divisions"> <xs:annotation>     <xs:documentation>Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance swing eighths vs. even eighths or differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should use the note element's attack and release attributes.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="positive-divisions">
         <xs:annotation>
         <xs:documentation>The positive-divisions type restricts divisions values to positive numbers.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="divisions">
         <xs:minExclusive value="0"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="positive-divisions">
         <xs:annotation>
         <xs:documentation>The positive-divisions type restricts divisions values to positive numbers.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="divisions">
         <xs:minExclusive value="0"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class Duration;
        using DurationPtr = std::shared_ptr<Duration>;
        using DurationUPtr = std::unique_ptr<Duration>;
        using DurationSet = std::vector<DurationPtr>;
        using DurationSetIter = DurationSet::iterator;
        using DurationSetIterConst = DurationSet::const_iterator;
        inline DurationPtr makeDuration() { return std::make_shared<Duration>(); }
		inline DurationPtr makeDuration( const t::PositiveDivisionsValue& value ) { return std::make_shared<Duration>( value ); }
		inline DurationPtr makeDuration( t::PositiveDivisionsValue&& value ) { return std::make_shared<Duration>( std::move( value ) ); }
        class Duration : public ElementInterface
        {
        public:
            Duration();
            Duration( const t::PositiveDivisionsValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::PositiveDivisionsValue getValue() const;
            void setValue( const t::PositiveDivisionsValue& value );
        private:
            t::PositiveDivisionsValue myValue;
        };
        
        
        /**************** DisplayStep ****************
         6272
         <xs:element name="display-step" type="step"/>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="step">
         <xs:annotation>
         <xs:documentation>The step type represents a step of the diatonic scale, represented using the English letters A through G.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:string">
         <xs:enumeration value="A"/>
         <xs:enumeration value="B"/>
         <xs:enumeration value="C"/>
         <xs:enumeration value="D"/>
         <xs:enumeration value="E"/>
         <xs:enumeration value="F"/>
         <xs:enumeration value="G"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class DisplayStep;
        using DisplayStepPtr = std::shared_ptr<DisplayStep>;
        using DisplayStepUPtr = std::unique_ptr<DisplayStep>;
        using DisplayStepSet = std::vector<DisplayStepPtr>;
        using DisplayStepSetIter = DisplayStepSet::iterator;
        using DisplayStepSetIterConst = DisplayStepSet::const_iterator;
        inline DisplayStepPtr makeDisplayStep() { return std::make_shared<DisplayStep>(); }
		inline DisplayStepPtr makeDisplayStep( const t::StepEnum& value ) { return std::make_shared<DisplayStep>( value ); }
		inline DisplayStepPtr makeDisplayStep( t::StepEnum&& value ) { return std::make_shared<DisplayStep>( std::move( value ) ); }
        class DisplayStep : public ElementInterface
        {
        public:
            DisplayStep();
            DisplayStep( const t::StepEnum& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::StepEnum getValue() const;
            void setValue( const t::StepEnum& value );
        private:
            t::StepEnum myValue;
        };
        
        
        /**************** DisplayOctave ****************
         6275
         <xs:element name="display-octave" type="octave"/>
         <xs:simpleType name="octave">
         <xs:annotation>
         <xs:documentation>Octaves are represented by the numbers 0 to 9, where 4 indicates the octave started by middle C.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer">
         <xs:minInclusive value="0"/>
         <xs:maxInclusive value="9"/>
         </xs:restriction>
         </xs:simpleType>
         <xs:simpleType name="octave">
         <xs:annotation>
         <xs:documentation>Octaves are represented by the numbers 0 to 9, where 4 indicates the octave started by middle C.</xs:documentation>
         </xs:annotation>
         <xs:restriction base="xs:integer">
         <xs:minInclusive value="0"/>
         <xs:maxInclusive value="9"/>
         </xs:restriction>
         </xs:simpleType>
         */
        class DisplayOctave;
        using DisplayOctavePtr = std::shared_ptr<DisplayOctave>;
        using DisplayOctaveUPtr = std::unique_ptr<DisplayOctave>;
        using DisplayOctaveSet = std::vector<DisplayOctavePtr>;
        using DisplayOctaveSetIter = DisplayOctaveSet::iterator;
        using DisplayOctaveSetIterConst = DisplayOctaveSet::const_iterator;
        inline DisplayOctavePtr makeDisplayOctave() { return std::make_shared<DisplayOctave>(); }
		inline DisplayOctavePtr makeDisplayOctave( const t::OctaveValue& value ) { return std::make_shared<DisplayOctave>( value ); }
		inline DisplayOctavePtr makeDisplayOctave( t::OctaveValue&& value ) { return std::make_shared<DisplayOctave>( std::move( value ) ); }
        class DisplayOctave : public ElementInterface
        {
        public:
            DisplayOctave();
            DisplayOctave( const t::OctaveValue& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::OctaveValue getValue() const;
            void setValue( const t::OctaveValue& value );
        private:
            t::OctaveValue myValue;
        };
        
        
        /**************** MovementNumber ****************
         6363
         <xs:element name="movement-number" type="xs:string" minOccurs="0"> <xs:annotation>     <xs:documentation>The movement-number element specifies the number of a movement.</xs:documentation>    </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class MovementNumber;
        using MovementNumberPtr = std::shared_ptr<MovementNumber>;
        using MovementNumberUPtr = std::unique_ptr<MovementNumber>;
        using MovementNumberSet = std::vector<MovementNumberPtr>;
        using MovementNumberSetIter = MovementNumberSet::iterator;
        using MovementNumberSetIterConst = MovementNumberSet::const_iterator;
        inline MovementNumberPtr makeMovementNumber() { return std::make_shared<MovementNumber>(); }
		inline MovementNumberPtr makeMovementNumber( const t::XsString& value ) { return std::make_shared<MovementNumber>( value ); }
		inline MovementNumberPtr makeMovementNumber( t::XsString&& value ) { return std::make_shared<MovementNumber>( std::move( value ) ); }
        class MovementNumber : public ElementInterface
        {
        public:
            MovementNumber();
            MovementNumber( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        /**************** MovementTitle ****************
         6369
         <xs:element name="movement-title" type="xs:string" minOccurs="0">  <xs:annotation>     <xs:documentation>The movement-title element specifies the title of a movement not including its number.</xs:documentation> </xs:annotation></xs:element>
         <xs:simpleType name="xs:string"/>
         <xs:simpleType name="xs:string"/>
         */
        class MovementTitle;
        using MovementTitlePtr = std::shared_ptr<MovementTitle>;
        using MovementTitleUPtr = std::unique_ptr<MovementTitle>;
        using MovementTitleSet = std::vector<MovementTitlePtr>;
        using MovementTitleSetIter = MovementTitleSet::iterator;
        using MovementTitleSetIterConst = MovementTitleSet::const_iterator;
        inline MovementTitlePtr makeMovementTitle() { return std::make_shared<MovementTitle>(); }
		inline MovementTitlePtr makeMovementTitle( const t::XsString& value ) { return std::make_shared<MovementTitle>( value ); }
		inline MovementTitlePtr makeMovementTitle( t::XsString&& value ) { return std::make_shared<MovementTitle>( std::move( value ) ); }
        class MovementTitle : public ElementInterface
        {
        public:
            MovementTitle();
            MovementTitle( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            t::XsString myValue;
        };
        
        
        
        
        /***************************************************************
         Empty Elements
         ***************************************************************/
        
        /*
         2997
         <xs:element name="double" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>If the double element is present, it indicates that the music is doubled one octave down from what is currently written (as is the case for mixed cello / bass parts in orchestral literature).</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class Double;
        using DoublePtr = std::shared_ptr<Double>;
        using DoubleUPtr = std::unique_ptr<Double>;
        using DoubleSet = std::vector<DoublePtr>;
        using DoubleSetIter = DoubleSet::iterator;
        using DoubleSetIterConst = DoubleSet::const_iterator;
        inline DoublePtr makeDouble() { return std::make_shared<Double>(); }
        class Double : public ElementInterface
        {
        public:
            Double();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         3120
         <xs:element name="accordion-high" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The accordion-high element indicates the presence of a dot in the high (4') section of the registration symbol.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class AccordionHigh;
        using AccordionHighPtr = std::shared_ptr<AccordionHigh>;
        using AccordionHighUPtr = std::unique_ptr<AccordionHigh>;
        using AccordionHighSet = std::vector<AccordionHighPtr>;
        using AccordionHighSetIter = AccordionHighSet::iterator;
        using AccordionHighSetIterConst = AccordionHighSet::const_iterator;
        inline AccordionHighPtr makeAccordionHigh() { return std::make_shared<AccordionHigh>(); }
        class AccordionHigh : public ElementInterface
        {
        public:
            AccordionHigh();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         3132
         <xs:element name="accordion-low" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The accordion-low element indicates the presence of a dot in the low (16') section of the registration symbol.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class AccordionLow;
        using AccordionLowPtr = std::shared_ptr<AccordionLow>;
        using AccordionLowUPtr = std::unique_ptr<AccordionLow>;
        using AccordionLowSet = std::vector<AccordionLowPtr>;
        using AccordionLowSetIter = AccordionLowSet::iterator;
        using AccordionLowSetIterConst = AccordionLowSet::const_iterator;
        inline AccordionLowPtr makeAccordionLow() { return std::make_shared<AccordionLow>(); }
        class AccordionLow : public ElementInterface
        {
        public:
            AccordionLow();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         3670
         <xs:element name="metronome-dot" type="empty" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The metronome-dot element works like the dot element in defining metric relationships.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class MetronomeDot;
        using MetronomeDotPtr = std::shared_ptr<MetronomeDot>;
        using MetronomeDotUPtr = std::unique_ptr<MetronomeDot>;
        using MetronomeDotSet = std::vector<MetronomeDotPtr>;
        using MetronomeDotSetIter = MetronomeDotSet::iterator;
        using MetronomeDotSetIterConst = MetronomeDotSet::const_iterator;
        inline MetronomeDotPtr makeMetronomeDot() { return std::make_shared<MetronomeDot>(); }
        class MetronomeDot : public ElementInterface
        {
        public:
            MetronomeDot();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         3806
         <xs:element name="timpani" type="empty"/>
         
         */
        class Timpani;
        using TimpaniPtr = std::shared_ptr<Timpani>;
        using TimpaniUPtr = std::unique_ptr<Timpani>;
        using TimpaniSet = std::vector<TimpaniPtr>;
        using TimpaniSetIter = TimpaniSet::iterator;
        using TimpaniSetIterConst = TimpaniSet::const_iterator;
        inline TimpaniPtr makeTimpani() { return std::make_shared<Timpani>(); }
        class Timpani : public ElementInterface
        {
        public:
            Timpani();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4522
         <xs:element name="pre-bend" type="empty">
         <xs:annotation>
         <xs:documentation>The pre-bend element indicates that this is a pre-bend rather than a normal bend or a release.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class PreBend;
        using PreBendPtr = std::shared_ptr<PreBend>;
        using PreBendUPtr = std::unique_ptr<PreBend>;
        using PreBendSet = std::vector<PreBendPtr>;
        using PreBendSetIter = PreBendSet::iterator;
        using PreBendSetIterConst = PreBendSet::const_iterator;
        inline PreBendPtr makePreBend() { return std::make_shared<PreBend>(); }
        class PreBend : public ElementInterface
        {
        public:
            PreBend();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4527
         <xs:element name="release" type="empty">
         <xs:annotation>
         <xs:documentation>The release element indicates that this is a release rather than a normal bend or pre-bend.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class Release;
        using ReleasePtr = std::shared_ptr<Release>;
        using ReleaseUPtr = std::unique_ptr<Release>;
        using ReleaseSet = std::vector<ReleasePtr>;
        using ReleaseSetIter = ReleaseSet::iterator;
        using ReleaseSetIterConst = ReleaseSet::const_iterator;
        inline ReleasePtr makeRelease() { return std::make_shared<Release>(); }
        class Release : public ElementInterface
        {
        public:
            Release();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4710
         <xs:element name="natural" type="empty">
         <xs:annotation>
         <xs:documentation>The natural element indicates that this is a natural harmonic. These are usually notated at base pitch rather than sounding pitch.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class Natural;
        using NaturalPtr = std::shared_ptr<Natural>;
        using NaturalUPtr = std::unique_ptr<Natural>;
        using NaturalSet = std::vector<NaturalPtr>;
        using NaturalSetIter = NaturalSet::iterator;
        using NaturalSetIterConst = NaturalSet::const_iterator;
        inline NaturalPtr makeNatural() { return std::make_shared<Natural>(); }
        class Natural : public ElementInterface
        {
        public:
            Natural();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4715
         <xs:element name="artificial" type="empty">
         <xs:annotation>
         <xs:documentation>The artificial element indicates that this is an artificial harmonic.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class Artificial;
        using ArtificialPtr = std::shared_ptr<Artificial>;
        using ArtificialUPtr = std::unique_ptr<Artificial>;
        using ArtificialSet = std::vector<ArtificialPtr>;
        using ArtificialSetIter = ArtificialSet::iterator;
        using ArtificialSetIterConst = ArtificialSet::const_iterator;
        inline ArtificialPtr makeArtificial() { return std::make_shared<Artificial>(); }
        class Artificial : public ElementInterface
        {
        public:
            Artificial();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4722
         <xs:element name="base-pitch" type="empty">
         <xs:annotation>
         <xs:documentation>The base pitch is the pitch at which the string is played before touching to create the harmonic.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class BasePitch;
        using BasePitchPtr = std::shared_ptr<BasePitch>;
        using BasePitchUPtr = std::unique_ptr<BasePitch>;
        using BasePitchSet = std::vector<BasePitchPtr>;
        using BasePitchSetIter = BasePitchSet::iterator;
        using BasePitchSetIterConst = BasePitchSet::const_iterator;
        inline BasePitchPtr makeBasePitch() { return std::make_shared<BasePitch>(); }
        class BasePitch : public ElementInterface
        {
        public:
            BasePitch();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4727
         <xs:element name="touching-pitch" type="empty">
         <xs:annotation>
         <xs:documentation>The touching-pitch is the pitch at which the string is touched lightly to produce the harmonic.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class TouchingPitch;
        using TouchingPitchPtr = std::shared_ptr<TouchingPitch>;
        using TouchingPitchUPtr = std::unique_ptr<TouchingPitch>;
        using TouchingPitchSet = std::vector<TouchingPitchPtr>;
        using TouchingPitchSetIter = TouchingPitchSet::iterator;
        using TouchingPitchSetIterConst = TouchingPitchSet::const_iterator;
        inline TouchingPitchPtr makeTouchingPitch() { return std::make_shared<TouchingPitch>(); }
        class TouchingPitch : public ElementInterface
        {
        public:
            TouchingPitch();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4732
         <xs:element name="sounding-pitch" type="empty">
         <xs:annotation>
         <xs:documentation>The sounding-pitch is the pitch which is heard when playing the harmonic.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class SoundingPitch;
        using SoundingPitchPtr = std::shared_ptr<SoundingPitch>;
        using SoundingPitchUPtr = std::unique_ptr<SoundingPitch>;
        using SoundingPitchSet = std::vector<SoundingPitchPtr>;
        using SoundingPitchSetIter = SoundingPitchSet::iterator;
        using SoundingPitchSetIterConst = SoundingPitchSet::const_iterator;
        inline SoundingPitchPtr makeSoundingPitch() { return std::make_shared<SoundingPitch>(); }
        class SoundingPitch : public ElementInterface
        {
        public:
            SoundingPitch();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4831
         <xs:element name="laughing" type="empty">
         <xs:annotation>
         <xs:documentation>The laughing element is taken from Humdrum.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class Laughing;
        using LaughingPtr = std::shared_ptr<Laughing>;
        using LaughingUPtr = std::unique_ptr<Laughing>;
        using LaughingSet = std::vector<LaughingPtr>;
        using LaughingSetIter = LaughingSet::iterator;
        using LaughingSetIterConst = LaughingSet::const_iterator;
        inline LaughingPtr makeLaughing() { return std::make_shared<Laughing>(); }
        class Laughing : public ElementInterface
        {
        public:
            Laughing();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4836
         <xs:element name="humming" type="empty">
         <xs:annotation>
         <xs:documentation>The humming element is taken from Humdrum.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class Humming;
        using HummingPtr = std::shared_ptr<Humming>;
        using HummingUPtr = std::unique_ptr<Humming>;
        using HummingSet = std::vector<HummingPtr>;
        using HummingSetIter = HummingSet::iterator;
        using HummingSetIterConst = HummingSet::const_iterator;
        inline HummingPtr makeHumming() { return std::make_shared<Humming>(); }
        class Humming : public ElementInterface
        {
        public:
            Humming();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4841
         <xs:element name="end-line" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The end-line element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric display for Karaoke and similar applications.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class EndLine;
        using EndLinePtr = std::shared_ptr<EndLine>;
        using EndLineUPtr = std::unique_ptr<EndLine>;
        using EndLineSet = std::vector<EndLinePtr>;
        using EndLineSetIter = EndLineSet::iterator;
        using EndLineSetIterConst = EndLineSet::const_iterator;
        inline EndLinePtr makeEndLine() { return std::make_shared<EndLine>(); }
        class EndLine : public ElementInterface
        {
        public:
            EndLine();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4847
         <xs:element name="end-paragraph" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The end-paragraph element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric display for Karaoke and similar applications.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class EndParagraph;
        using EndParagraphPtr = std::shared_ptr<EndParagraph>;
        using EndParagraphUPtr = std::unique_ptr<EndParagraph>;
        using EndParagraphSet = std::vector<EndParagraphPtr>;
        using EndParagraphSetIter = EndParagraphSet::iterator;
        using EndParagraphSetIterConst = EndParagraphSet::const_iterator;
        inline EndParagraphPtr makeEndParagraph() { return std::make_shared<EndParagraph>(); }
        class EndParagraph : public ElementInterface
        {
        public:
            EndParagraph();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         4976
         <xs:element name="cue" type="empty">
         <xs:annotation>
         <xs:documentation>The cue element indicates the presence of a cue note.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class Cue;
        using CuePtr = std::shared_ptr<Cue>;
        using CueUPtr = std::unique_ptr<Cue>;
        using CueSet = std::vector<CuePtr>;
        using CueSetIter = CueSet::iterator;
        using CueSetIterConst = CueSet::const_iterator;
        inline CuePtr makeCue() { return std::make_shared<Cue>(); }
        class Cue : public ElementInterface
        {
        public:
            Cue();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         5535
         <xs:element name="normal-dot" type="empty" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The normal-dot element is used to specify dotted normal tuplet types.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class NormalDot;
        using NormalDotPtr = std::shared_ptr<NormalDot>;
        using NormalDotUPtr = std::unique_ptr<NormalDot>;
        using NormalDotSet = std::vector<NormalDotPtr>;
        using NormalDotSetIter = NormalDotSet::iterator;
        using NormalDotSetIterConst = NormalDotSet::const_iterator;
        inline NormalDotPtr makeNormalDot() { return std::make_shared<NormalDot>(); }
        class NormalDot : public ElementInterface
        {
        public:
            NormalDot();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         5831
         <xs:element name="group-time" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The group-time element indicates that the displayed time signatures should stretch across all parts and staves in the group.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class GroupTime;
        using GroupTimePtr = std::shared_ptr<GroupTime>;
        using GroupTimeUPtr = std::unique_ptr<GroupTime>;
        using GroupTimeSet = std::vector<GroupTimePtr>;
        using GroupTimeSetIter = GroupTimeSet::iterator;
        using GroupTimeSetIterConst = GroupTimeSet::const_iterator;
        inline GroupTimePtr makeGroupTime() { return std::make_shared<GroupTime>(); }
        class GroupTime : public ElementInterface
        {
        public:
            GroupTime();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         5898
         <xs:element name="solo" type="empty">
         <xs:annotation>
         <xs:documentation>The solo element was added in Version 2.0. It is present if performance is intended by a solo instrument.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class Solo;
        using SoloPtr = std::shared_ptr<Solo>;
        using SoloUPtr = std::unique_ptr<Solo>;
        using SoloSet = std::vector<SoloPtr>;
        using SoloSetIter = SoloSet::iterator;
        using SoloSetIterConst = SoloSet::const_iterator;
        inline SoloPtr makeSolo() { return std::make_shared<Solo>(); }
        class Solo : public ElementInterface
        {
        public:
            Solo();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         6130
         <xs:element name="slash-dot" type="empty" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The slash-dot element is used to specify any augmentation dots in the note type used to display repetition marks.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class SlashDot;
        using SlashDotPtr = std::shared_ptr<SlashDot>;
        using SlashDotUPtr = std::unique_ptr<SlashDot>;
        using SlashDotSet = std::vector<SlashDotPtr>;
        using SlashDotSetIter = SlashDotSet::iterator;
        using SlashDotSetIterConst = SlashDotSet::const_iterator;
        inline SlashDotPtr makeSlashDot() { return std::make_shared<SlashDot>(); }
        class SlashDot : public ElementInterface
        {
        public:
            SlashDot();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         6178
         <xs:element name="beat-unit-dot" type="empty" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The beat-unit-dot element is used to specify any augmentation dots for a metronome mark note.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class BeatUnitDot;
        using BeatUnitDotPtr = std::shared_ptr<BeatUnitDot>;
        using BeatUnitDotUPtr = std::unique_ptr<BeatUnitDot>;
        using BeatUnitDotSet = std::vector<BeatUnitDotPtr>;
        using BeatUnitDotSetIter = BeatUnitDotSet::iterator;
        using BeatUnitDotSetIterConst = BeatUnitDotSet::const_iterator;
        inline BeatUnitDotPtr makeBeatUnitDot() { return std::make_shared<BeatUnitDot>(); }
        class BeatUnitDot : public ElementInterface
        {
        public:
            BeatUnitDot();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /*
         6283
         <xs:element name="chord" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The chord element indicates that this note is an additional chord tone with the preceding note. The duration of this note can be no longer than the preceding note. In MuseData, a missing duration indicates the same length as the previous note, but the MusicXML format requires a duration for chord notes too.</xs:documentation>
         </xs:annotation>
         </xs:element> */
        class Chord;
        using ChordPtr = std::shared_ptr<Chord>;
        using ChordUPtr = std::unique_ptr<Chord>;
        using ChordSet = std::vector<ChordPtr>;
        using ChordSetIter = ChordSet::iterator;
        using ChordSetIterConst = ChordSet::const_iterator;
        inline ChordPtr makeChord() { return std::make_shared<Chord>(); }
        class Chord : public ElementInterface
        {
        public:
            Chord();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
        };
        
        /***************************************************************
         Empty Elements with Attributes
         ***************************************************************/
        
        struct EmptyPrintObjectStyleAlignAttributes;
        using EmptyPrintObjectStyleAlignAttributesPtr = std::shared_ptr<EmptyPrintObjectStyleAlignAttributes>;
        
        struct EmptyPrintObjectStyleAlignAttributes : public AttributesInterface
        {
        public:
            EmptyPrintObjectStyleAlignAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
        };
        
        /*
         3030
         <xs:element name="segno" type="empty-print-style-align" minOccurs="0"/>
         <xs:complexType name="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The empty-print-style-align type represents an empty element with print-style-align attribute group.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        class Segno;
        using SegnoPtr = std::shared_ptr<Segno>;
        using SegnoUPtr = std::unique_ptr<Segno>;
        using SegnoSet = std::vector<SegnoPtr>;
        using SegnoSetIter = SegnoSet::iterator;
        using SegnoSetIterConst = SegnoSet::const_iterator;
        inline SegnoPtr makeSegno() { return std::make_shared<Segno>(); }
        class Segno : public ElementInterface
        {
        public:
            Segno();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPrintObjectStyleAlignAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPrintObjectStyleAlignAttributesPtr& attributes );
        private:
            EmptyPrintObjectStyleAlignAttributesPtr myAttributes;
        };
        
        /*
         3034
         <xs:element name="coda" type="empty-print-style-align" minOccurs="0"/>
         <xs:complexType name="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The empty-print-style-align type represents an empty element with print-style-align attribute group.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        class Coda;
        using CodaPtr = std::shared_ptr<Coda>;
        using CodaUPtr = std::unique_ptr<Coda>;
        using CodaSet = std::vector<CodaPtr>;
        using CodaSetIter = CodaSet::iterator;
        using CodaSetIterConst = CodaSet::const_iterator;
        inline CodaPtr makeCoda() { return std::make_shared<Coda>(); }
        class Coda : public ElementInterface
        {
        public:
            Coda();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPrintObjectStyleAlignAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPrintObjectStyleAlignAttributesPtr& attributes );
        private:
            EmptyPrintObjectStyleAlignAttributesPtr myAttributes;
        };
        
        /*
         3333
         <xs:element name="segno" type="empty-print-style-align" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The segno element is the visual indicator of a segno sign. A sound element is needed to guide playback applications reliably.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The empty-print-style-align type represents an empty element with print-style-align attribute group.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        
        
        /*
         3345
         <xs:element name="coda" type="empty-print-style-align" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The coda element is the visual indicator of a coda sign. A sound element is needed to guide playback applications reliably.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The empty-print-style-align type represents an empty element with print-style-align attribute group.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        
        /*
         3376
         <xs:element name="damp" type="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The damp element specifies a harp damping mark.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The empty-print-style-align type represents an empty element with print-style-align attribute group.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        class Damp;
        using DampPtr = std::shared_ptr<Damp>;
        using DampUPtr = std::unique_ptr<Damp>;
        using DampSet = std::vector<DampPtr>;
        using DampSetIter = DampSet::iterator;
        using DampSetIterConst = DampSet::const_iterator;
        inline DampPtr makeDamp() { return std::make_shared<Damp>(); }
        class Damp : public ElementInterface
        {
        public:
            Damp();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPrintObjectStyleAlignAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPrintObjectStyleAlignAttributesPtr& attributes );
        private:
            EmptyPrintObjectStyleAlignAttributesPtr myAttributes;
        };
        
        /*
         3381
         <xs:element name="damp-all" type="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The damp-all element specifies a harp damping mark for all strings.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The empty-print-style-align type represents an empty element with print-style-align attribute group.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        class DampAll;
        using DampAllPtr = std::shared_ptr<DampAll>;
        using DampAllUPtr = std::unique_ptr<DampAll>;
        using DampAllSet = std::vector<DampAllPtr>;
        using DampAllSetIter = DampAllSet::iterator;
        using DampAllSetIterConst = DampAllSet::const_iterator;
        inline DampAllPtr makeDampAll() { return std::make_shared<DampAll>(); }
        class DampAll : public ElementInterface
        {
        public:
            DampAll();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPrintObjectStyleAlignAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPrintObjectStyleAlignAttributesPtr& attributes );
        private:
            EmptyPrintObjectStyleAlignAttributesPtr myAttributes;
        };
        
        /*
         3386
         <xs:element name="eyeglasses" type="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The eyeglasses element specifies the eyeglasses symbol, common in commercial music.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The empty-print-style-align type represents an empty element with print-style-align attribute group.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        class Eyeglasses;
        using EyeglassesPtr = std::shared_ptr<Eyeglasses>;
        using EyeglassesUPtr = std::unique_ptr<Eyeglasses>;
        using EyeglassesSet = std::vector<EyeglassesPtr>;
        using EyeglassesSetIter = EyeglassesSet::iterator;
        using EyeglassesSetIterConst = EyeglassesSet::const_iterator;
        inline EyeglassesPtr makeEyeglasses() { return std::make_shared<Eyeglasses>(); }
        class Eyeglasses : public ElementInterface
        {
        public:
            Eyeglasses();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPrintObjectStyleAlignAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPrintObjectStyleAlignAttributesPtr& attributes );
        private:
            EmptyPrintObjectStyleAlignAttributesPtr myAttributes;
        };
        
        /*
         4274
         <xs:element name="left-divider" type="empty-print-object-style-align"/>
         <xs:complexType name="empty-print-object-style-align">
         <xs:annotation>
         <xs:documentation>The empty-print-style-align-object type represents an empty element with print-object and print-style-align attribute groups.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-object"/>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        class LeftDivider;
        using LeftDividerPtr = std::shared_ptr<LeftDivider>;
        using LeftDividerUPtr = std::unique_ptr<LeftDivider>;
        using LeftDividerSet = std::vector<LeftDividerPtr>;
        using LeftDividerSetIter = LeftDividerSet::iterator;
        using LeftDividerSetIterConst = LeftDividerSet::const_iterator;
        inline LeftDividerPtr makeLeftDivider() { return std::make_shared<LeftDivider>(); }
        class LeftDivider : public ElementInterface
        {
        public:
            LeftDivider();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPrintObjectStyleAlignAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPrintObjectStyleAlignAttributesPtr& attributes );
        private:
            EmptyPrintObjectStyleAlignAttributesPtr myAttributes;
        };
        
        /*
         4277
         <xs:element name="right-divider" type="empty-print-object-style-align"/>
         <xs:complexType name="empty-print-object-style-align">
         <xs:annotation>
         <xs:documentation>The empty-print-style-align-object type represents an empty element with print-object and print-style-align attribute groups.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-object"/>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        class RightDivider;
        using RightDividerPtr = std::shared_ptr<RightDivider>;
        using RightDividerUPtr = std::unique_ptr<RightDivider>;
        using RightDividerSet = std::vector<RightDividerPtr>;
        using RightDividerSetIter = RightDividerSet::iterator;
        using RightDividerSetIterConst = RightDividerSet::const_iterator;
        inline RightDividerPtr makeRightDivider() { return std::make_shared<RightDivider>(); }
        class RightDivider : public ElementInterface
        {
        public:
            RightDivider();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPrintObjectStyleAlignAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPrintObjectStyleAlignAttributesPtr& attributes );
        private:
            EmptyPrintObjectStyleAlignAttributesPtr myAttributes;
        };
        
        struct EmptyPlacementAttributes;
        using EmptyPlacementAttributesPtr = std::shared_ptr<EmptyPlacementAttributes>;
        
        struct EmptyPlacementAttributes : public AttributesInterface
        {
        public:
            EmptyPlacementAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        /*
         4384
         <xs:element name="accent" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The accent element indicates a regular horizontal accent mark.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Accent;
        using AccentPtr = std::shared_ptr<Accent>;
        using AccentUPtr = std::unique_ptr<Accent>;
        using AccentSet = std::vector<AccentPtr>;
        using AccentSetIter = AccentSet::iterator;
        using AccentSetIterConst = AccentSet::const_iterator;
        inline AccentPtr makeAccent() { return std::make_shared<Accent>(); }
        class Accent : public ElementInterface
        {
        public:
            Accent();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         4394
         <xs:element name="staccato" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The staccato element is used for a dot articulation, as opposed to a stroke or a wedge.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Staccato;
        using StaccatoPtr = std::shared_ptr<Staccato>;
        using StaccatoUPtr = std::unique_ptr<Staccato>;
        using StaccatoSet = std::vector<StaccatoPtr>;
        using StaccatoSetIter = StaccatoSet::iterator;
        using StaccatoSetIterConst = StaccatoSet::const_iterator;
        inline StaccatoPtr makeStaccato() { return std::make_shared<Staccato>(); }
        class Staccato : public ElementInterface
        {
        public:
            Staccato();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         4399
         <xs:element name="tenuto" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The tenuto element indicates a tenuto line symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Tenuto;
        using TenutoPtr = std::shared_ptr<Tenuto>;
        using TenutoUPtr = std::unique_ptr<Tenuto>;
        using TenutoSet = std::vector<TenutoPtr>;
        using TenutoSetIter = TenutoSet::iterator;
        using TenutoSetIterConst = TenutoSet::const_iterator;
        inline TenutoPtr makeTenuto() { return std::make_shared<Tenuto>(); }
        class Tenuto : public ElementInterface
        {
        public:
            Tenuto();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         4404
         <xs:element name="detached-legato" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The detached-legato element indicates the combination of a tenuto line and staccato dot symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class DetachedLegato;
        using DetachedLegatoPtr = std::shared_ptr<DetachedLegato>;
        using DetachedLegatoUPtr = std::unique_ptr<DetachedLegato>;
        using DetachedLegatoSet = std::vector<DetachedLegatoPtr>;
        using DetachedLegatoSetIter = DetachedLegatoSet::iterator;
        using DetachedLegatoSetIterConst = DetachedLegatoSet::const_iterator;
        inline DetachedLegatoPtr makeDetachedLegato() { return std::make_shared<DetachedLegato>(); }
        class DetachedLegato : public ElementInterface
        {
        public:
            DetachedLegato();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         4409
         <xs:element name="staccatissimo" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The staccatissimo element is used for a wedge articulation, as opposed to a dot or a stroke.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Staccatissimo;
        using StaccatissimoPtr = std::shared_ptr<Staccatissimo>;
        using StaccatissimoUPtr = std::unique_ptr<Staccatissimo>;
        using StaccatissimoSet = std::vector<StaccatissimoPtr>;
        using StaccatissimoSetIter = StaccatissimoSet::iterator;
        using StaccatissimoSetIterConst = StaccatissimoSet::const_iterator;
        inline StaccatissimoPtr makeStaccatissimo() { return std::make_shared<Staccatissimo>(); }
        class Staccatissimo : public ElementInterface
        {
        public:
            Staccatissimo();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         4414
         <xs:element name="spiccato" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The spiccato element is used for a stroke articulation, as opposed to a dot or a wedge.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Spiccato;
        using SpiccatoPtr = std::shared_ptr<Spiccato>;
        using SpiccatoUPtr = std::unique_ptr<Spiccato>;
        using SpiccatoSet = std::vector<SpiccatoPtr>;
        using SpiccatoSetIter = SpiccatoSet::iterator;
        using SpiccatoSetIterConst = SpiccatoSet::const_iterator;
        inline SpiccatoPtr makeSpiccato() { return std::make_shared<Spiccato>(); }
        class Spiccato : public ElementInterface
        {
        public:
            Spiccato();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        struct EmptyLineAttributes;
        using EmptyLineAttributesPtr = std::shared_ptr<EmptyLineAttributes>;
        
        struct EmptyLineAttributes : public AttributesInterface
        {
        public:
            EmptyLineAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue dashLength;
            t::TenthsValue spaceLength;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            bool hasDashLength;
            bool hasSpaceLength;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
        };
        
        /*
         4419
         <xs:element name="scoop" type="empty-line">
         <xs:annotation>
         <xs:documentation>The scoop element is an indeterminate slide attached to a single note. The scoop element appears before the main note and comes from below the main pitch.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-line">
         <xs:annotation>
         <xs:documentation>The empty-line type represents an empty element with line-shape, line-type, dashed-formatting, print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="line-shape"/>
         <xs:attributeGroup ref="line-type"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Scoop;
        using ScoopPtr = std::shared_ptr<Scoop>;
        using ScoopUPtr = std::unique_ptr<Scoop>;
        using ScoopSet = std::vector<ScoopPtr>;
        using ScoopSetIter = ScoopSet::iterator;
        using ScoopSetIterConst = ScoopSet::const_iterator;
        inline ScoopPtr makeScoop() { return std::make_shared<Scoop>(); }
        class Scoop : public ElementInterface
        {
        public:
            Scoop();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyLineAttributesPtr getAttributes() const;
            void setAttributes( const EmptyLineAttributesPtr& attributes );
        private:
            EmptyLineAttributesPtr myAttributes;
        };
        
        /*
         4424
         <xs:element name="plop" type="empty-line">
         <xs:annotation>
         <xs:documentation>The plop element is an indeterminate slide attached to a single note. The plop element appears before the main note and comes from above the main pitch.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-line">
         <xs:annotation>
         <xs:documentation>The empty-line type represents an empty element with line-shape, line-type, dashed-formatting, print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="line-shape"/>
         <xs:attributeGroup ref="line-type"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Plop;
        using PlopPtr = std::shared_ptr<Plop>;
        using PlopUPtr = std::unique_ptr<Plop>;
        using PlopSet = std::vector<PlopPtr>;
        using PlopSetIter = PlopSet::iterator;
        using PlopSetIterConst = PlopSet::const_iterator;
        inline PlopPtr makePlop() { return std::make_shared<Plop>(); }
        class Plop : public ElementInterface
        {
        public:
            Plop();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyLineAttributesPtr getAttributes() const;
            void setAttributes( const EmptyLineAttributesPtr& attributes );
        private:
            EmptyLineAttributesPtr myAttributes;
        };
        
        /*
         4429
         <xs:element name="doit" type="empty-line">
         <xs:annotation>
         <xs:documentation>The doit element is an indeterminate slide attached to a single note. The doit element appears after the main note and goes above the main pitch.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-line">
         <xs:annotation>
         <xs:documentation>The empty-line type represents an empty element with line-shape, line-type, dashed-formatting, print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="line-shape"/>
         <xs:attributeGroup ref="line-type"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Doit;
        using DoitPtr = std::shared_ptr<Doit>;
        using DoitUPtr = std::unique_ptr<Doit>;
        using DoitSet = std::vector<DoitPtr>;
        using DoitSetIter = DoitSet::iterator;
        using DoitSetIterConst = DoitSet::const_iterator;
        inline DoitPtr makeDoit() { return std::make_shared<Doit>(); }
        class Doit : public ElementInterface
        {
        public:
            Doit();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyLineAttributesPtr getAttributes() const;
            void setAttributes( const EmptyLineAttributesPtr& attributes );
        private:
            EmptyLineAttributesPtr myAttributes;
        };
        
        /*
         4434
         <xs:element name="falloff" type="empty-line">
         <xs:annotation>
         <xs:documentation>The falloff element is an indeterminate slide attached to a single note. The falloff element appears before the main note and goes below the main pitch.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-line">
         <xs:annotation>
         <xs:documentation>The empty-line type represents an empty element with line-shape, line-type, dashed-formatting, print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="line-shape"/>
         <xs:attributeGroup ref="line-type"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Falloff;
        using FalloffPtr = std::shared_ptr<Falloff>;
        using FalloffUPtr = std::unique_ptr<Falloff>;
        using FalloffSet = std::vector<FalloffPtr>;
        using FalloffSetIter = FalloffSet::iterator;
        using FalloffSetIterConst = FalloffSet::const_iterator;
        inline FalloffPtr makeFalloff() { return std::make_shared<Falloff>(); }
        class Falloff : public ElementInterface
        {
        public:
            Falloff();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyLineAttributesPtr getAttributes() const;
            void setAttributes( const EmptyLineAttributesPtr& attributes );
        private:
            EmptyLineAttributesPtr myAttributes;
        };
        
        /*
         4442
         <xs:element name="caesura" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The caesura element indicates a slight pause. It is notated using a "railroad tracks" symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Caesura;
        using CaesuraPtr = std::shared_ptr<Caesura>;
        using CaesuraUPtr = std::unique_ptr<Caesura>;
        using CaesuraSet = std::vector<CaesuraPtr>;
        using CaesuraSetIter = CaesuraSet::iterator;
        using CaesuraSetIterConst = CaesuraSet::const_iterator;
        inline CaesuraPtr makeCaesura() { return std::make_shared<Caesura>(); }
        class Caesura : public ElementInterface
        {
        public:
            Caesura();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         4447
         <xs:element name="stress" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The stress element indicates a stressed note.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Stress;
        using StressPtr = std::shared_ptr<Stress>;
        using StressUPtr = std::unique_ptr<Stress>;
        using StressSet = std::vector<StressPtr>;
        using StressSetIter = StressSet::iterator;
        using StressSetIterConst = StressSet::const_iterator;
        inline StressPtr makeStress() { return std::make_shared<Stress>(); }
        class Stress : public ElementInterface
        {
        public:
            Stress();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         4452
         <xs:element name="unstress" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The unstress element indicates an unstressed note. It is often notated using a u-shaped symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Unstress;
        using UnstressPtr = std::shared_ptr<Unstress>;
        using UnstressUPtr = std::unique_ptr<Unstress>;
        using UnstressSet = std::vector<UnstressPtr>;
        using UnstressSetIter = UnstressSet::iterator;
        using UnstressSetIterConst = UnstressSet::const_iterator;
        inline UnstressPtr makeUnstress() { return std::make_shared<Unstress>(); }
        class Unstress : public ElementInterface
        {
        public:
            Unstress();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         5005
         <xs:element name="dot" type="empty-placement" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>One dot element is used for each dot of prolongation. The placement element is used to specify whether the dot should appear above or below the staff line. It is ignored for notes that appear on a staff space.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Dot;
        using DotPtr = std::shared_ptr<Dot>;
        using DotUPtr = std::unique_ptr<Dot>;
        using DotSet = std::vector<DotPtr>;
        using DotSetIter = DotSet::iterator;
        using DotSetIterConst = DotSet::const_iterator;
        inline DotPtr makeDot() { return std::make_shared<Dot>(); }
        class Dot : public ElementInterface
        {
        public:
            Dot();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        struct EmptyTrillSoundAttributes;
        using EmptyTrillSoundAttributesPtr = std::shared_ptr<EmptyTrillSoundAttributes>;
        
        struct EmptyTrillSoundAttributes : public AttributesInterface
        {
        public:
            EmptyTrillSoundAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            t::StartNote startNote;
            t::TrillStep trillStep;
            t::TwoNoteTurn twoNoteTurn;
            t::YesNo accelerate;
            t::TrillBeats beats;
            t::Percent secondBeat;
            t::Percent lastBeat;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
            bool hasStartNote;
            bool hasTrillStep;
            bool hasTwoNoteTurn;
            bool hasAccelerate;
            bool hasBeats;
            bool hasSecondBeat;
            bool hasLastBeat;
        };
        
        /*
         5128
         <xs:element name="trill-mark" type="empty-trill-sound">
         <xs:annotation>
         <xs:documentation>The trill-mark element represents the trill-mark symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-trill-sound">
         <xs:annotation>
         <xs:documentation>The empty-trill-sound type represents an empty element with print-style, placement, and trill-sound attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="trill-sound"/>
         </xs:complexType>
         */
        class TrillMark;
        using TrillMarkPtr = std::shared_ptr<TrillMark>;
        using TrillMarkUPtr = std::unique_ptr<TrillMark>;
        using TrillMarkSet = std::vector<TrillMarkPtr>;
        using TrillMarkSetIter = TrillMarkSet::iterator;
        using TrillMarkSetIterConst = TrillMarkSet::const_iterator;
        inline TrillMarkPtr makeTrillMark() { return std::make_shared<TrillMark>(); }
        class TrillMark : public ElementInterface
        {
        public:
            TrillMark();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyTrillSoundAttributesPtr getAttributes() const;
            void setAttributes( const EmptyTrillSoundAttributesPtr& attributes );
        private:
            EmptyTrillSoundAttributesPtr myAttributes;
        };
        
        /*
         5153
         <xs:element name="vertical-turn" type="empty-trill-sound">
         <xs:annotation>
         <xs:documentation>The vertical-turn element has the turn symbol shape arranged vertically going from upper left to lower right.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-trill-sound">
         <xs:annotation>
         <xs:documentation>The empty-trill-sound type represents an empty element with print-style, placement, and trill-sound attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="trill-sound"/>
         </xs:complexType>
         */
        class VerticalTurn;
        using VerticalTurnPtr = std::shared_ptr<VerticalTurn>;
        using VerticalTurnUPtr = std::unique_ptr<VerticalTurn>;
        using VerticalTurnSet = std::vector<VerticalTurnPtr>;
        using VerticalTurnSetIter = VerticalTurnSet::iterator;
        using VerticalTurnSetIterConst = VerticalTurnSet::const_iterator;
        inline VerticalTurnPtr makeVerticalTurn() { return std::make_shared<VerticalTurn>(); }
        class VerticalTurn : public ElementInterface
        {
        public:
            VerticalTurn();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyTrillSoundAttributesPtr getAttributes() const;
            void setAttributes( const EmptyTrillSoundAttributesPtr& attributes );
        private:
            EmptyTrillSoundAttributesPtr myAttributes;
        };
        
        /*
         5158
         <xs:element name="shake" type="empty-trill-sound">
         <xs:annotation>
         <xs:documentation>The shake element has a similar appearance to an inverted-mordent element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-trill-sound">
         <xs:annotation>
         <xs:documentation>The empty-trill-sound type represents an empty element with print-style, placement, and trill-sound attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="trill-sound"/>
         </xs:complexType>
         */
        class Shake;
        using ShakePtr = std::shared_ptr<Shake>;
        using ShakeUPtr = std::unique_ptr<Shake>;
        using ShakeSet = std::vector<ShakePtr>;
        using ShakeSetIter = ShakeSet::iterator;
        using ShakeSetIterConst = ShakeSet::const_iterator;
        inline ShakePtr makeShake() { return std::make_shared<Shake>(); }
        class Shake : public ElementInterface
        {
        public:
            Shake();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyTrillSoundAttributesPtr getAttributes() const;
            void setAttributes( const EmptyTrillSoundAttributesPtr& attributes );
        private:
            EmptyTrillSoundAttributesPtr myAttributes;
        };
        
        /*
         5176
         <xs:element name="schleifer" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The name for this ornament is based on the German, to avoid confusion with the more common slide element defined earlier.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Schleifer;
        using SchleiferPtr = std::shared_ptr<Schleifer>;
        using SchleiferUPtr = std::unique_ptr<Schleifer>;
        using SchleiferSet = std::vector<SchleiferPtr>;
        using SchleiferSetIter = SchleiferSet::iterator;
        using SchleiferSetIterConst = SchleiferSet::const_iterator;
        inline SchleiferPtr makeSchleifer() { return std::make_shared<Schleifer>(); }
        class Schleifer : public ElementInterface
        {
        public:
            Schleifer();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         5339
         <xs:element name="up-bow" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The up-bow element represents the symbol that is used both for up-bowing on bowed instruments, and up-stroke on plucked instruments.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class UpBow;
        using UpBowPtr = std::shared_ptr<UpBow>;
        using UpBowUPtr = std::unique_ptr<UpBow>;
        using UpBowSet = std::vector<UpBowPtr>;
        using UpBowSetIter = UpBowSet::iterator;
        using UpBowSetIterConst = UpBowSet::const_iterator;
        inline UpBowPtr makeUpBow() { return std::make_shared<UpBow>(); }
        class UpBow : public ElementInterface
        {
        public:
            UpBow();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         5344
         <xs:element name="down-bow" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The down-bow element represents the symbol that is used both for down-bowing on bowed instruments, and down-stroke on plucked instruments.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class DownBow;
        using DownBowPtr = std::shared_ptr<DownBow>;
        using DownBowUPtr = std::unique_ptr<DownBow>;
        using DownBowSet = std::vector<DownBowPtr>;
        using DownBowSetIter = DownBowSet::iterator;
        using DownBowSetIterConst = DownBowSet::const_iterator;
        inline DownBowPtr makeDownBow() { return std::make_shared<DownBow>(); }
        class DownBow : public ElementInterface
        {
        public:
            DownBow();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         5352
         <xs:element name="open-string" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The open-string element represents the zero-shaped open string symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class OpenString;
        using OpenStringPtr = std::shared_ptr<OpenString>;
        using OpenStringUPtr = std::unique_ptr<OpenString>;
        using OpenStringSet = std::vector<OpenStringPtr>;
        using OpenStringSetIter = OpenStringSet::iterator;
        using OpenStringSetIterConst = OpenStringSet::const_iterator;
        inline OpenStringPtr makeOpenString() { return std::make_shared<OpenString>(); }
        class OpenString : public ElementInterface
        {
        public:
            OpenString();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         5357
         <xs:element name="thumb-position" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The thumb-position element represents the thumb position symbol. This is a circle with a line, where the line does not come within the circle. It is distinct from the snap pizzicato symbol, where the line comes inside the circle.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class ThumbPosition;
        using ThumbPositionPtr = std::shared_ptr<ThumbPosition>;
        using ThumbPositionUPtr = std::unique_ptr<ThumbPosition>;
        using ThumbPositionSet = std::vector<ThumbPositionPtr>;
        using ThumbPositionSetIter = ThumbPositionSet::iterator;
        using ThumbPositionSetIterConst = ThumbPositionSet::const_iterator;
        inline ThumbPositionPtr makeThumbPosition() { return std::make_shared<ThumbPosition>(); }
        class ThumbPosition : public ElementInterface
        {
        public:
            ThumbPosition();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         5370
         <xs:element name="double-tongue" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The double-tongue element represents the double tongue symbol (two dots arranged horizontally).</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class DoubleTongue;
        using DoubleTonguePtr = std::shared_ptr<DoubleTongue>;
        using DoubleTongueUPtr = std::unique_ptr<DoubleTongue>;
        using DoubleTongueSet = std::vector<DoubleTonguePtr>;
        using DoubleTongueSetIter = DoubleTongueSet::iterator;
        using DoubleTongueSetIterConst = DoubleTongueSet::const_iterator;
        inline DoubleTonguePtr makeDoubleTongue() { return std::make_shared<DoubleTongue>(); }
        class DoubleTongue : public ElementInterface
        {
        public:
            DoubleTongue();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         5375
         <xs:element name="triple-tongue" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The triple-tongue element represents the triple tongue symbol (three dots arranged horizontally).</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class TripleTongue;
        using TripleTonguePtr = std::shared_ptr<TripleTongue>;
        using TripleTongueUPtr = std::unique_ptr<TripleTongue>;
        using TripleTongueSet = std::vector<TripleTonguePtr>;
        using TripleTongueSetIter = TripleTongueSet::iterator;
        using TripleTongueSetIterConst = TripleTongueSet::const_iterator;
        inline TripleTonguePtr makeTripleTongue() { return std::make_shared<TripleTongue>(); }
        class TripleTongue : public ElementInterface
        {
        public:
            TripleTongue();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         5380
         <xs:element name="stopped" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The stopped element represents the stopped symbol, which looks like a plus sign.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Stopped;
        using StoppedPtr = std::shared_ptr<Stopped>;
        using StoppedUPtr = std::unique_ptr<Stopped>;
        using StoppedSet = std::vector<StoppedPtr>;
        using StoppedSetIter = StoppedSet::iterator;
        using StoppedSetIterConst = StoppedSet::const_iterator;
        inline StoppedPtr makeStopped() { return std::make_shared<Stopped>(); }
        class Stopped : public ElementInterface
        {
        public:
            Stopped();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         5385
         <xs:element name="snap-pizzicato" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The snap-pizzicato element represents the snap pizzicato symbol. This is a circle with a line, where the line comes inside the circle. It is distinct from the thumb-position symbol, where the line does not come inside the circle.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class SnapPizzicato;
        using SnapPizzicatoPtr = std::shared_ptr<SnapPizzicato>;
        using SnapPizzicatoUPtr = std::unique_ptr<SnapPizzicato>;
        using SnapPizzicatoSet = std::vector<SnapPizzicatoPtr>;
        using SnapPizzicatoSetIter = SnapPizzicatoSet::iterator;
        using SnapPizzicatoSetIterConst = SnapPizzicatoSet::const_iterator;
        inline SnapPizzicatoPtr makeSnapPizzicato() { return std::make_shared<SnapPizzicato>(); }
        class SnapPizzicato : public ElementInterface
        {
        public:
            SnapPizzicato();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        /*
         5416
         <xs:element name="fingernails" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The fingernails element is used in notation for harp and other plucked string instruments.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         */
        class Fingernails;
        using FingernailsPtr = std::shared_ptr<Fingernails>;
        using FingernailsUPtr = std::unique_ptr<Fingernails>;
        using FingernailsSet = std::vector<FingernailsPtr>;
        using FingernailsSetIter = FingernailsSet::iterator;
        using FingernailsSetIterConst = FingernailsSet::const_iterator;
        inline FingernailsPtr makeFingernails() { return std::make_shared<Fingernails>(); }
        class Fingernails : public ElementInterface
        {
        public:
            Fingernails();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyPlacementAttributesPtr getAttributes() const;
            void setAttributes( const EmptyPlacementAttributesPtr& attributes );
        private:
            EmptyPlacementAttributesPtr myAttributes;
        };
        
        struct EmptyFontAttributes;
        using EmptyFontAttributesPtr = std::shared_ptr<EmptyFontAttributes>;
        
        struct EmptyFontAttributes : public AttributesInterface
        {
        public:
            EmptyFontAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        /*
         5714
         <xs:element name="music-font" type="empty-font" minOccurs="0"/>
         <xs:complexType name="empty-font">
         <xs:annotation>
         <xs:documentation>The empty-font type represents an empty element with font attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="font"/>
         </xs:complexType>
         */
        class MusicFont;
        using MusicFontPtr = std::shared_ptr<MusicFont>;
        using MusicFontUPtr = std::unique_ptr<MusicFont>;
        using MusicFontSet = std::vector<MusicFontPtr>;
        using MusicFontSetIter = MusicFontSet::iterator;
        using MusicFontSetIterConst = MusicFontSet::const_iterator;
        inline MusicFontPtr makeMusicFont() { return std::make_shared<MusicFont>(); }
        class MusicFont : public ElementInterface
        {
        public:
            MusicFont();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyFontAttributesPtr getAttributes() const;
            void setAttributes( const EmptyFontAttributesPtr& attributes );
        private:
            EmptyFontAttributesPtr myAttributes;
        };
        
        /*
         5718
         <xs:element name="word-font" type="empty-font" minOccurs="0"/>
         <xs:complexType name="empty-font">
         <xs:annotation>
         <xs:documentation>The empty-font type represents an empty element with font attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="font"/>
         </xs:complexType>
         */
        class WordFont;
        using WordFontPtr = std::shared_ptr<WordFont>;
        using WordFontUPtr = std::unique_ptr<WordFont>;
        using WordFontSet = std::vector<WordFontPtr>;
        using WordFontSetIter = WordFontSet::iterator;
        using WordFontSetIterConst = WordFontSet::const_iterator;
        inline WordFontPtr makeWordFont() { return std::make_shared<WordFont>(); }
        class WordFont : public ElementInterface
        {
        public:
            WordFont();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            EmptyFontAttributesPtr getAttributes() const;
            void setAttributes( const EmptyFontAttributesPtr& attributes );
        private:
            EmptyFontAttributesPtr myAttributes;
        };
        
        /****************************************************************************
         MORE Empty Elements with Attributes
         ****************************************************************************/
        /*
         3026 [ equivalents 3026, 5163 ]
         <xs:element name="wavy-line" type="wavy-line" minOccurs="0"/>
         <xs:complexType name="wavy-line">
         <xs:annotation>
         <xs:documentation>Wavy lines are one way to indicate trills. When used with a measure element, they should always have type="continue" set.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop-continue" use="required"/>
         <xs:attribute name="number" type="number-level"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="color"/>
         <xs:attributeGroup ref="trill-sound"/>
         </xs:complexType>
         */
        
        struct WavyLineAttributes;
        using WavyLineAttributesPtr = std::shared_ptr<WavyLineAttributes>;
        
        struct WavyLineAttributes : public AttributesInterface
        {
        public:
            WavyLineAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStopContinue type;
            t::NumberLevel number;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::AboveBelow placement;
            t::StartNote startNote;
            t::TrillStep trillStep;
            t::TwoNoteTurn twoNoteTurn;
            t::YesNo accelerate;
            t::TrillBeats beats;
            t::Percent secondBeat;
            t::Percent lastBeat;
            const   bool hasType;
            bool hasNumber;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasPlacement;
            bool hasStartNote;
            bool hasTrillStep;
            bool hasTwoNoteTurn;
            bool hasAccelerate;
            bool hasBeats;
            bool hasSecondBeat;
            bool hasLastBeat;
        };
        
        class WavyLine;
        using WavyLinePtr = std::shared_ptr<WavyLine>;
        using WavyLineUPtr = std::unique_ptr<WavyLine>;
        using WavyLineSet = std::vector<WavyLinePtr>;
        using WavyLineSetIter = WavyLineSet::iterator;
        using WavyLineSetIterConst = WavyLineSet::const_iterator;
        inline WavyLinePtr makeWavyLine() { return std::make_shared<WavyLine>(); }
        class WavyLine : public ElementInterface
        {
        public:
            WavyLine();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            WavyLineAttributesPtr getAttributes() const;
            void setAttributes( const WavyLineAttributesPtr& attributes );
        private:
            WavyLineAttributesPtr myAttributes;
        };
        
        /*
         3047
         <xs:element name="repeat" type="repeat" minOccurs="0"/>
         <xs:complexType name="repeat">
         <xs:annotation>
         <xs:documentation>The repeat type represents repeat marks. The start of the repeat has a forward direction while the end of the repeat has a backward direction. Backward repeats that are not part of an ending can use the times attribute to indicate the number of times the repeated section is played.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="direction" type="backward-forward" use="required"/>
         <xs:attribute name="times" type="xs:nonNegativeInteger"/>
         <xs:attribute name="winged" type="winged"/>
         </xs:complexType>
         */
        
        struct RepeatAttributes;
        using RepeatAttributesPtr = std::shared_ptr<RepeatAttributes>;
        
        struct RepeatAttributes : public AttributesInterface
        {
        public:
            RepeatAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::BackwardForward direction;
            t::NonNegativeInteger times;
            t::Winged winged;
            const   bool hasDirection;
            bool hasTimes;
            bool hasWinged;
        };
        
        class Repeat;
        using RepeatPtr = std::shared_ptr<Repeat>;
        using RepeatUPtr = std::unique_ptr<Repeat>;
        using RepeatSet = std::vector<RepeatPtr>;
        using RepeatSetIter = RepeatSet::iterator;
        using RepeatSetIterConst = RepeatSet::const_iterator;
        inline RepeatPtr makeRepeat() { return std::make_shared<Repeat>(); }
        class Repeat : public ElementInterface
        {
        public:
            Repeat();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            RepeatAttributesPtr getAttributes() const;
            void setAttributes( const RepeatAttributesPtr& attributes );
        private:
            RepeatAttributesPtr myAttributes;
        };
        
        /*
         3351
         <xs:element name="wedge" type="wedge"/>
         <xs:complexType name="wedge">
         <xs:annotation>
         <xs:documentation>The wedge type represents crescendo and diminuendo wedge symbols. The type attribute is crescendo for the start of a wedge that is closed at the left side, and diminuendo for the start of a wedge that is closed on the right side. Spread values are measured in tenths; those at the start of a crescendo wedge or end of a diminuendo wedge are ignored. The niente attribute is yes if a circle appears at the point of the wedge, indicating a crescendo from nothing or diminuendo to nothing. It is no by default, and used only when the type is crescendo, or the type is stop for a wedge that began with a diminuendo type. The line-type is solid by default.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="wedge-type" use="required"/>
         <xs:attribute name="number" type="number-level"/>
         <xs:attribute name="spread" type="tenths"/>
         <xs:attribute name="niente" type="yes-no"/>
         <xs:attributeGroup ref="line-type"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="color"/>
         </xs:complexType>
         */
        
        struct WedgeAttributes;
        using WedgeAttributesPtr = std::shared_ptr<WedgeAttributes>;
        
        struct WedgeAttributes : public AttributesInterface
        {
        public:
            WedgeAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::WedgeType type;
            t::NumberLevel number;
            t::TenthsValue spread;
            t::YesNo niente;
            t::TenthsValue dashLength;
            t::TenthsValue spaceLength;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            const   bool hasType;
            bool hasNumber;
            bool hasSpread;
            bool hasNiente;
            bool hasDashLength;
            bool hasSpaceLength;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
        };
        
        class Wedge;
        using WedgePtr = std::shared_ptr<Wedge>;
        using WedgeUPtr = std::unique_ptr<Wedge>;
        using WedgeSet = std::vector<WedgePtr>;
        using WedgeSetIter = WedgeSet::iterator;
        using WedgeSetIterConst = WedgeSet::const_iterator;
        inline WedgePtr makeWedge() { return std::make_shared<Wedge>(); }
        class Wedge : public ElementInterface
        {
        public:
            Wedge();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            WedgeAttributesPtr getAttributes() const;
            void setAttributes( const WedgeAttributesPtr& attributes );
        private:
            WedgeAttributesPtr myAttributes;
        };
        
        /*
         3358
         <xs:element name="dashes" type="dashes"/>
         <xs:complexType name="dashes">
         <xs:annotation>
         <xs:documentation>The dashes type represents dashes, used for instance with cresc. and dim. marks.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop-continue" use="required"/>
         <xs:attribute name="number" type="number-level"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="color"/>
         </xs:complexType>
         */
        
        struct DashesAttributes;
        using DashesAttributesPtr = std::shared_ptr<DashesAttributes>;
        
        struct DashesAttributes : public AttributesInterface
        {
        public:
            DashesAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStopContinue type;
            t::NumberLevel number;
            t::TenthsValue dashLength;
            t::TenthsValue spaceLength;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            const   bool hasType;
            bool hasNumber;
            bool hasDashLength;
            bool hasSpaceLength;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
        };
        
        class Dashes;
        using DashesPtr = std::shared_ptr<Dashes>;
        using DashesUPtr = std::unique_ptr<Dashes>;
        using DashesSet = std::vector<DashesPtr>;
        using DashesSetIter = DashesSet::iterator;
        using DashesSetIterConst = DashesSet::const_iterator;
        inline DashesPtr makeDashes() { return std::make_shared<Dashes>(); }
        class Dashes : public ElementInterface
        {
        public:
            Dashes();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DashesAttributesPtr getAttributes() const;
            void setAttributes( const DashesAttributesPtr& attributes );
        private:
            DashesAttributesPtr myAttributes;
        };
        
        /*
         3361
         <xs:element name="bracket" type="bracket"/>
         <xs:complexType name="bracket">
         <xs:annotation>
         <xs:documentation>Brackets are combined with words in a variety of modern directions. The line-end attribute specifies if there is a jog up or down (or both), an arrow, or nothing at the start or end of the bracket. If the line-end is up or down, the length of the jog can be specified using the end-length attribute. The line-type is solid by default.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop-continue" use="required"/>
         <xs:attribute name="number" type="number-level"/>
         <xs:attribute name="line-end" type="line-end" use="required"/>
         <xs:attribute name="end-length" type="tenths"/>
         <xs:attributeGroup ref="line-type"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="color"/>
         </xs:complexType>
         */
        
        struct BracketAttributes;
        using BracketAttributesPtr = std::shared_ptr<BracketAttributes>;
        
        struct BracketAttributes : public AttributesInterface
        {
        public:
            BracketAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo bracket;
            bool hasBracket;
        };
        
        class Bracket;
        using BracketPtr = std::shared_ptr<Bracket>;
        using BracketUPtr = std::unique_ptr<Bracket>;
        using BracketSet = std::vector<BracketPtr>;
        using BracketSetIter = BracketSet::iterator;
        using BracketSetIterConst = BracketSet::const_iterator;
        inline BracketPtr makeBracket() { return std::make_shared<Bracket>(); }
        class Bracket : public ElementInterface
        {
        public:
            Bracket();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BracketAttributesPtr getAttributes() const;
            void setAttributes( const BracketAttributesPtr& attributes );
        private:
            BracketAttributesPtr myAttributes;
        };
        
        /*
         3364
         <xs:element name="pedal" type="pedal"/>
         <xs:complexType name="pedal">
         <xs:annotation>
         <xs:documentation>The pedal type represents piano pedal marks. The line attribute is yes if pedal lines are used. The sign attribute is yes if Ped and * signs are used. For MusicXML 2.0 compatibility, the sign attribute is yes by default if the line attribute is no, and is no by default if the line attribute is yes. The change and continue types are used when the line attribute is yes. The change type indicates a pedal lift and retake indicated with an inverted V marking. The continue type allows more precise formatting across system breaks and for more complex pedaling lines. The alignment attributes are ignored if the line attribute is yes.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop-change-continue" use="required"/>
         <xs:attribute name="line" type="yes-no"/>
         <xs:attribute name="sign" type="yes-no"/>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        
        struct PedalAttributes;
        using PedalAttributesPtr = std::shared_ptr<PedalAttributes>;
        
        struct PedalAttributes : public AttributesInterface
        {
        public:
            PedalAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStopChangeContinue type;
            t::YesNo line;
            t::YesNo sign;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            const   bool hasType;
            bool hasLine;
            bool hasSign;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
        };
        
        class Pedal;
        using PedalPtr = std::shared_ptr<Pedal>;
        using PedalUPtr = std::unique_ptr<Pedal>;
        using PedalSet = std::vector<PedalPtr>;
        using PedalSetIter = PedalSet::iterator;
        using PedalSetIterConst = PedalSet::const_iterator;
        inline PedalPtr makePedal() { return std::make_shared<Pedal>(); }
        class Pedal : public ElementInterface
        {
        public:
            Pedal();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PedalAttributesPtr getAttributes() const;
            void setAttributes( const PedalAttributesPtr& attributes );
        private:
            PedalAttributesPtr myAttributes;
        };
        
        /*
         3370
         <xs:element name="octave-shift" type="octave-shift"/>
         <xs:complexType name="octave-shift">
         <xs:annotation>
         <xs:documentation>The octave shift type indicates where notes are shifted up or down from their true pitched values because of printing difficulty. Thus a treble clef line noted with 8va will be indicated with an octave-shift down from the pitch data indicated in the notes. A size of 8 indicates one octave; a size of 15 indicates two octaves.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="up-down-stop-continue" use="required"/>
         <xs:attribute name="number" type="number-level"/>
         <xs:attribute name="size" type="xs:positiveInteger" default="8"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:complexType>
         */
        
        struct OctaveShiftAttributes;
        using OctaveShiftAttributesPtr = std::shared_ptr<OctaveShiftAttributes>;
        
        struct OctaveShiftAttributes : public AttributesInterface
        {
        public:
            OctaveShiftAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::UpDownStopContinue type;
            t::NumberLevel number;
            t::PositiveInteger size;
            t::TenthsValue dashLength;
            t::TenthsValue spaceLength;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            const   bool hasType;
            bool hasNumber;
            bool hasSize;
            bool hasDashLength;
            bool hasSpaceLength;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class OctaveShift;
        using OctaveShiftPtr = std::shared_ptr<OctaveShift>;
        using OctaveShiftUPtr = std::unique_ptr<OctaveShift>;
        using OctaveShiftSet = std::vector<OctaveShiftPtr>;
        using OctaveShiftSetIter = OctaveShiftSet::iterator;
        using OctaveShiftSetIterConst = OctaveShiftSet::const_iterator;
        inline OctaveShiftPtr makeOctaveShift() { return std::make_shared<OctaveShift>(); }
        class OctaveShift : public ElementInterface
        {
        public:
            OctaveShift();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            OctaveShiftAttributesPtr getAttributes() const;
            void setAttributes( const OctaveShiftAttributesPtr& attributes );
        private:
            OctaveShiftAttributesPtr myAttributes;
        };
        
        /*
         3391
         <xs:element name="string-mute" type="string-mute"/>
         <xs:complexType name="string-mute">
         <xs:annotation>
         <xs:documentation>The string-mute type represents string mute on and mute off symbols.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="on-off" use="required"/>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        
        struct StringMuteAttributes;
        using StringMuteAttributesPtr = std::shared_ptr<StringMuteAttributes>;
        
        struct StringMuteAttributes : public AttributesInterface
        {
        public:
            StringMuteAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::OnOff type;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::LeftCenterRight halign;
            const   bool hasType;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasHalign;
        };
        
        class StringMute;
        using StringMutePtr = std::shared_ptr<StringMute>;
        using StringMuteUPtr = std::unique_ptr<StringMute>;
        using StringMuteSet = std::vector<StringMutePtr>;
        using StringMuteSetIter = StringMuteSet::iterator;
        using StringMuteSetIterConst = StringMuteSet::const_iterator;
        inline StringMutePtr makeStringMute() { return std::make_shared<StringMute>(); }
        class StringMute : public ElementInterface
        {
        public:
            StringMute();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            StringMuteAttributesPtr getAttributes() const;
            void setAttributes( const StringMuteAttributesPtr& attributes );
        private:
            StringMuteAttributesPtr myAttributes;
        };
        
        /*
         3397
         <xs:element name="image" type="image"/>
         <xs:complexType name="image">
         <xs:annotation>
         <xs:documentation>The image type is used to include graphical images in a score.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="image-attributes"/>
         </xs:complexType>
         */
        
        struct ImageAttributes;
        using ImageAttributesPtr = std::shared_ptr<ImageAttributes>;
        
        struct ImageAttributes : public AttributesInterface
        {
        public:
            ImageAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsAnyUri source;
            t::XsToken type;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::LeftCenterRight halign;
            const   bool hasSource;
            const   bool hasType;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasHalign;
        };
        
        class Image;
        using ImagePtr = std::shared_ptr<Image>;
        using ImageUPtr = std::unique_ptr<Image>;
        using ImageSet = std::vector<ImagePtr>;
        using ImageSetIter = ImageSet::iterator;
        using ImageSetIterConst = ImageSet::const_iterator;
        inline ImagePtr makeImage() { return std::make_shared<Image>(); }
        class Image : public ElementInterface
        {
        public:
            Image();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            ImageAttributesPtr getAttributes() const;
            void setAttributes( const ImageAttributesPtr& attributes );
        private:
            ImageAttributesPtr myAttributes;
        };
        
        /*
         3491
         <xs:element name="barre" type="barre" minOccurs="0"/>
         <xs:complexType name="barre">
         <xs:annotation>
         <xs:documentation>The barre element indicates placing a finger over multiple strings on a single fret. The type is "start" for the lowest pitched string (e.g., the string with the highest MusicXML number) and is "stop" for the highest pitched string.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attributeGroup ref="color"/>
         </xs:complexType>
         */
        
        struct BarreAttributes;
        using BarreAttributesPtr = std::shared_ptr<BarreAttributes>;
        
        struct BarreAttributes : public AttributesInterface
        {
        public:
            BarreAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            const   bool hasType;
        };
        
        class Barre;
        using BarrePtr = std::shared_ptr<Barre>;
        using BarreUPtr = std::unique_ptr<Barre>;
        using BarreSet = std::vector<BarrePtr>;
        using BarreSetIter = BarreSet::iterator;
        using BarreSetIterConst = BarreSet::const_iterator;
        inline BarrePtr makeBarre() { return std::make_shared<Barre>(); }
        class Barre : public ElementInterface
        {
        public:
            Barre();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BarreAttributesPtr getAttributes() const;
            void setAttributes( const BarreAttributesPtr& attributes );
        private:
            BarreAttributesPtr myAttributes;
        };
        
        /*
         4057
         <xs:element name="supports" type="supports"/>
         <xs:complexType name="supports">
         <xs:annotation>
         <xs:documentation>The supports type indicates if a MusicXML encoding supports a particular MusicXML element. This is recommended for elements like beam, stem, and accidental, where the absence of an element is ambiguous if you do not know if the encoding supports that element. For Version 2.0, the supports element is expanded to allow programs to indicate support for particular attributes or particular values. This lets applications communicate, for example, that all system and/or page breaks are contained in the MusicXML file.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="yes-no" use="required"/>
         <xs:attribute name="element" type="xs:NMTOKEN" use="required"/>
         <xs:attribute name="attribute" type="xs:NMTOKEN"/>
         <xs:attribute name="value" type="xs:token"/>
         </xs:complexType>
         */
        
        struct SupportsAttributes;
        using SupportsAttributesPtr = std::shared_ptr<SupportsAttributes>;
        
        struct SupportsAttributes : public AttributesInterface
        {
        public:
            SupportsAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo type;
            t::XsNMToken element;
            t::XsNMToken attribute;
            t::XsToken value;
            const   bool hasType;
            const   bool hasElement;
            bool hasAttribute;
            bool hasValue;
        };
        
        class Supports;
        using SupportsPtr = std::shared_ptr<Supports>;
        using SupportsUPtr = std::unique_ptr<Supports>;
        using SupportsSet = std::vector<SupportsPtr>;
        using SupportsSetIter = SupportsSet::iterator;
        using SupportsSetIterConst = SupportsSet::const_iterator;
        inline SupportsPtr makeSupports() { return std::make_shared<Supports>(); }
        class Supports : public ElementInterface
        {
        public:
            Supports();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            SupportsAttributesPtr getAttributes() const;
            void setAttributes( const SupportsAttributesPtr& attributes );
        private:
            SupportsAttributesPtr myAttributes;
        };
        
        /*
         4599 [ equivalents 4599, 4824, 4828 ]
         <xs:element name="extend" type="extend" minOccurs="0"/>
         <xs:complexType name="extend">
         <xs:annotation>
         <xs:documentation>The extend type represents lyric word extension / melisma lines as well as figured bass extensions. The optional type and position attributes are added in Version 3.0 to provide better formatting control.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop-continue"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:complexType>
         */
        
        struct ExtendAttributes;
        using ExtendAttributesPtr = std::shared_ptr<ExtendAttributes>;
        
        struct ExtendAttributes : public AttributesInterface
        {
        public:
            ExtendAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStopContinue type;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasType;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class Extend;
        using ExtendPtr = std::shared_ptr<Extend>;
        using ExtendUPtr = std::unique_ptr<Extend>;
        using ExtendSet = std::vector<ExtendPtr>;
        using ExtendSetIter = ExtendSet::iterator;
        using ExtendSetIterConst = ExtendSet::const_iterator;
        inline ExtendPtr makeExtend() { return std::make_shared<Extend>(); }
        class Extend : public ElementInterface
        {
        public:
            Extend();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            ExtendAttributesPtr getAttributes() const;
            void setAttributes( const ExtendAttributesPtr& attributes );
        private:
            ExtendAttributesPtr myAttributes;
        };
        
        /*
         4824 [ equivalents 4599, 4824, 4828 ]
         <xs:element name="extend" type="extend" minOccurs="0"/>
         <xs:complexType name="extend">
         <xs:annotation>
         <xs:documentation>The extend type represents lyric word extension / melisma lines as well as figured bass extensions. The optional type and position attributes are added in Version 3.0 to provide better formatting control.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop-continue"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:complexType>
         */
        
        /*
         4828 [ equivalents 4599, 4824, 4828 ]
         <xs:element name="extend" type="extend"/>
         <xs:complexType name="extend">
         <xs:annotation>
         <xs:documentation>The extend type represents lyric word extension / melisma lines as well as figured bass extensions. The optional type and position attributes are added in Version 3.0 to provide better formatting control.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop-continue"/>
         <xs:attributeGroup ref="print-style"/>
         </xs:complexType>
         */
        
        /*
         4914
         <xs:element name="tied" type="tied"/>
         <xs:complexType name="tied">
         <xs:annotation>
         <xs:documentation>The tied type represents the notated tie. The tie element represents the tie sound.
         
         The number attribute is rarely needed to disambiguate ties, since note pitches will usually suffice. The attribute is implied rather than defaulting to 1 as with most elements. It is available for use in more complex tied notation situations.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop-continue" use="required"/>
         <xs:attribute name="number" type="number-level"/>
         <xs:attributeGroup ref="line-type"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="orientation"/>
         <xs:attributeGroup ref="bezier"/>
         <xs:attributeGroup ref="color"/>
         </xs:complexType>
         */
        
        struct TiedAttributes;
        using TiedAttributesPtr = std::shared_ptr<TiedAttributes>;
        
        struct TiedAttributes : public AttributesInterface
        {
        public:
            TiedAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStopContinue type;
            t::NumberLevel number;
            t::TenthsValue dashLength;
            t::TenthsValue spaceLength;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::AboveBelow placement;
            t::OverUnder orientation;
            t::DivisionsValue bezierOffset;
            t::DivisionsValue bezierOffset2;
            t::TenthsValue bezierX;
            t::TenthsValue bezierY;
            t::TenthsValue bezierX2;
            t::TenthsValue bezierY2;
            const   bool hasType;
            bool hasNumber;
            bool hasDashLength;
            bool hasSpaceLength;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasPlacement;
            bool hasOrientation;
            bool hasBezierOffset;
            bool hasBezierOffset2;
            bool hasBezierX;
            bool hasBezierY;
            bool hasBezierX2;
            bool hasBezierY2;
        };
        
        class Tied;
        using TiedPtr = std::shared_ptr<Tied>;
        using TiedUPtr = std::unique_ptr<Tied>;
        using TiedSet = std::vector<TiedPtr>;
        using TiedSetIter = TiedSet::iterator;
        using TiedSetIterConst = TiedSet::const_iterator;
        inline TiedPtr makeTied() { return std::make_shared<Tied>(); }
        class Tied : public ElementInterface
        {
        public:
            Tied();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TiedAttributesPtr getAttributes() const;
            void setAttributes( const TiedAttributesPtr& attributes );
        private:
            TiedAttributesPtr myAttributes;
        };
        
        /*
         4917
         <xs:element name="slur" type="slur"/>
         <xs:complexType name="slur">
         <xs:annotation>
         <xs:documentation>Slur types are empty. Most slurs are represented with two elements: one with a start type, and one with a stop type. Slurs can add more elements using a continue type. This is typically used to specify the formatting of cross-system slurs, or to specify the shape of very complex slurs.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop-continue" use="required"/>
         <xs:attribute name="number" type="number-level" default="1"/>
         <xs:attributeGroup ref="line-type"/>
         <xs:attributeGroup ref="dashed-formatting"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="orientation"/>
         <xs:attributeGroup ref="bezier"/>
         <xs:attributeGroup ref="color"/>
         </xs:complexType>
         */
        
        struct SlurAttributes;
        using SlurAttributesPtr = std::shared_ptr<SlurAttributes>;
        
        struct SlurAttributes : public AttributesInterface
        {
        public:
            SlurAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStopContinue type;
            t::NumberLevel number;
            t::TenthsValue dashLength;
            t::TenthsValue spaceLength;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::AboveBelow placement;
            t::OverUnder orientation;
            t::DivisionsValue bezierOffset;
            t::DivisionsValue bezierOffset2;
            t::TenthsValue bezierX;
            t::TenthsValue bezierY;
            t::TenthsValue bezierX2;
            t::TenthsValue bezierY2;
            const   bool hasType;
            bool hasNumber;
            bool hasDashLength;
            bool hasSpaceLength;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasPlacement;
            bool hasOrientation;
            bool hasBezierOffset;
            bool hasBezierOffset2;
            bool hasBezierX;
            bool hasBezierY;
            bool hasBezierX2;
            bool hasBezierY2;
        };
        
        class Slur;
        using SlurPtr = std::shared_ptr<Slur>;
        using SlurUPtr = std::unique_ptr<Slur>;
        using SlurSet = std::vector<SlurPtr>;
        using SlurSetIter = SlurSet::iterator;
        using SlurSetIterConst = SlurSet::const_iterator;
        inline SlurPtr makeSlur() { return std::make_shared<Slur>(); }
        class Slur : public ElementInterface
        {
        public:
            Slur();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            SlurAttributesPtr getAttributes() const;
            void setAttributes( const SlurAttributesPtr& attributes );
        private:
            SlurAttributesPtr myAttributes;
        };
        
        /*
         4944
         <xs:element name="arpeggiate" type="arpeggiate"/>
         <xs:complexType name="arpeggiate">
         <xs:annotation>
         <xs:documentation>The arpeggiate type indicates that this note is part of an arpeggiated chord. The number attribute can be used to distinguish between two simultaneous chords arpeggiated separately (different numbers) or together (same number). The up-down attribute is used if there is an arrow on the arpeggio sign. By default, arpeggios go from the lowest to highest note.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="number" type="number-level"/>
         <xs:attribute name="direction" type="up-down"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="color"/>
         </xs:complexType>
         */
        
        struct ArpeggiateAttributes;
        using ArpeggiateAttributesPtr = std::shared_ptr<ArpeggiateAttributes>;
        
        struct ArpeggiateAttributes : public AttributesInterface
        {
        public:
            ArpeggiateAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::NumberLevel number;
            t::UpDown direction;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::AboveBelow placement;
            bool hasNumber;
            bool hasDirection;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasPlacement;
        };
        
        class Arpeggiate;
        using ArpeggiatePtr = std::shared_ptr<Arpeggiate>;
        using ArpeggiateUPtr = std::unique_ptr<Arpeggiate>;
        using ArpeggiateSet = std::vector<ArpeggiatePtr>;
        using ArpeggiateSetIter = ArpeggiateSet::iterator;
        using ArpeggiateSetIterConst = ArpeggiateSet::const_iterator;
        inline ArpeggiatePtr makeArpeggiate() { return std::make_shared<Arpeggiate>(); }
        class Arpeggiate : public ElementInterface
        {
        public:
            Arpeggiate();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            ArpeggiateAttributesPtr getAttributes() const;
            void setAttributes( const ArpeggiateAttributesPtr& attributes );
        private:
            ArpeggiateAttributesPtr myAttributes;
        };
        
        /*
         4947
         <xs:element name="non-arpeggiate" type="non-arpeggiate"/>
         <xs:complexType name="non-arpeggiate">
         <xs:annotation>
         <xs:documentation>The non-arpeggiate type indicates that this note is at the top or bottom of a bracket indicating to not arpeggiate these notes. Since this does not involve playback, it is only used on the top or bottom notes, not on each note as for the arpeggiate type.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="top-bottom" use="required"/>
         <xs:attribute name="number" type="number-level"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="color"/>
         </xs:complexType>
         */
        
        struct NonArpeggiateAttributes;
        using NonArpeggiateAttributesPtr = std::shared_ptr<NonArpeggiateAttributes>;
        
        struct NonArpeggiateAttributes : public AttributesInterface
        {
        public:
            NonArpeggiateAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TopBottom type;
            t::NumberLevel number;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::AboveBelow placement;
            const   bool hasType;
            bool hasNumber;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasPlacement;
        };
        
        class NonArpeggiate;
        using NonArpeggiatePtr = std::shared_ptr<NonArpeggiate>;
        using NonArpeggiateUPtr = std::unique_ptr<NonArpeggiate>;
        using NonArpeggiateSet = std::vector<NonArpeggiatePtr>;
        using NonArpeggiateSetIter = NonArpeggiateSet::iterator;
        using NonArpeggiateSetIterConst = NonArpeggiateSet::const_iterator;
        inline NonArpeggiatePtr makeNonArpeggiate() { return std::make_shared<NonArpeggiate>(); }
        class NonArpeggiate : public ElementInterface
        {
        public:
            NonArpeggiate();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            NonArpeggiateAttributesPtr getAttributes() const;
            void setAttributes( const NonArpeggiateAttributesPtr& attributes );
        private:
            NonArpeggiateAttributesPtr myAttributes;
        };
        
        /*
         4965
         <xs:element name="grace" type="grace"/>
         <xs:complexType name="grace">
         <xs:annotation>
         <xs:documentation>The grace type indicates the presence of a grace note. The slash attribute for a grace note is yes for slashed eighth notes. The other grace note attributes come from MuseData sound suggestions. The steal-time-previous attribute indicates the percentage of time to steal from the previous note for the grace note. The steal-time-following attribute indicates the percentage of time to steal from the following note for the grace note, as for appoggiaturas. The make-time attribute indicates to make time, not steal time; the units are in real-time divisions for the grace note.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="steal-time-previous" type="percent"/>
         <xs:attribute name="steal-time-following" type="percent"/>
         <xs:attribute name="make-time" type="divisions"/>
         <xs:attribute name="slash" type="yes-no"/>
         </xs:complexType>
         */
        
        struct GraceAttributes;
        using GraceAttributesPtr = std::shared_ptr<GraceAttributes>;
        
        struct GraceAttributes : public AttributesInterface
        {
        public:
            GraceAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::Percent stealTimePrevious;
            t::Percent stealTimeFollowing;
            t::DivisionsValue makeTime;
            t::YesNo slash;
            bool hasStealTimePrevious;
            bool hasStealTimeFollowing;
            bool hasMakeTime;
            bool hasSlash;
        };
        
        class Grace;
        using GracePtr = std::shared_ptr<Grace>;
        using GraceUPtr = std::unique_ptr<Grace>;
        using GraceSet = std::vector<GracePtr>;
        using GraceSetIter = GraceSet::iterator;
        using GraceSetIterConst = GraceSet::const_iterator;
        inline GracePtr makeGrace() { return std::make_shared<Grace>(); }
        class Grace : public ElementInterface
        {
        public:
            Grace();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            GraceAttributesPtr getAttributes() const;
            void setAttributes( const GraceAttributesPtr& attributes );
        private:
            GraceAttributesPtr myAttributes;
        };
        
        /*
         4970 [ equivalents 4970, 4990 ]
         <xs:element name="tie" type="tie" minOccurs="0" maxOccurs="2"/>
         <xs:complexType name="tie">
         <xs:annotation>
         <xs:documentation>The tie element indicates that a tie begins or ends with this note. If the tie element applies only particular times through a repeat, the time-only attribute indicates which times to apply it. The tie element indicates sound; the tied element indicates notation.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="time-only" type="time-only"/>
         </xs:complexType>
         */
        
        struct TieAttributes;
        using TieAttributesPtr = std::shared_ptr<TieAttributes>;
        
        struct TieAttributes : public AttributesInterface
        {
        public:
            TieAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            t::TimeOnly timeOnly;
            const   bool hasType;
            bool hasTimeOnly;
        };
        
        class Tie;
        using TiePtr = std::shared_ptr<Tie>;
        using TieUPtr = std::unique_ptr<Tie>;
        using TieSet = std::vector<TiePtr>;
        using TieSetIter = TieSet::iterator;
        using TieSetIterConst = TieSet::const_iterator;
        inline TiePtr makeTie() { return std::make_shared<Tie>(); }
        class Tie : public ElementInterface
        {
        public:
            Tie();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TieAttributesPtr getAttributes() const;
            void setAttributes( const TieAttributesPtr& attributes );
        private:
            TieAttributesPtr myAttributes;
        };
        
        /*
         4990 [ equivalents 4970, 4990 ]
         <xs:element name="tie" type="tie" minOccurs="0" maxOccurs="2"/>
         <xs:complexType name="tie">
         <xs:annotation>
         <xs:documentation>The tie element indicates that a tie begins or ends with this note. If the tie element applies only particular times through a repeat, the time-only attribute indicates which times to apply it. The tie element indicates sound; the tied element indicates notation.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="time-only" type="time-only"/>
         </xs:complexType>
         */
        
        /*
         4995
         <xs:element name="instrument" type="instrument" minOccurs="0"/>
         <xs:complexType name="instrument">
         <xs:annotation>
         <xs:documentation>The instrument type distinguishes between score-instrument elements in a score-part. The id attribute is an IDREF back to the score-instrument ID. If multiple score-instruments are specified on a score-part, there should be an instrument element for each note in the part.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="id" type="xs:IDREF" use="required"/>
         </xs:complexType>
         */
        
        struct InstrumentAttributes;
        using InstrumentAttributesPtr = std::shared_ptr<InstrumentAttributes>;
        
        struct InstrumentAttributes : public AttributesInterface
        {
        public:
            InstrumentAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsIDREF id;
            const   bool hasId;
        };
        
        class Instrument;
        using InstrumentPtr = std::shared_ptr<Instrument>;
        using InstrumentUPtr = std::unique_ptr<Instrument>;
        using InstrumentSet = std::vector<InstrumentPtr>;
        using InstrumentSetIter = InstrumentSet::iterator;
        using InstrumentSetIterConst = InstrumentSet::const_iterator;
        inline InstrumentPtr makeInstrument() { return std::make_shared<Instrument>(); }
        class Instrument : public ElementInterface
        {
        public:
            Instrument();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            InstrumentAttributesPtr getAttributes() const;
            void setAttributes( const InstrumentAttributesPtr& attributes );
        private:
            InstrumentAttributesPtr myAttributes;
        };
        
        /*
         5133
         <xs:element name="turn" type="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The turn element is the normal turn shape which goes up then down.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The horizontal-turn type represents turn elements that are horizontal rather than vertical. These are empty elements with print-style, placement, trill-sound, and slash attributes. If the slash attribute is yes, then a vertical line is used to slash the turn; it is no by default.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="trill-sound"/>
         <xs:attribute name="slash" type="yes-no"/>
         </xs:complexType>
         */
        
        struct TurnAttributes;
        using TurnAttributesPtr = std::shared_ptr<TurnAttributes>;
        
        struct TurnAttributes : public AttributesInterface
        {
        public:
            TurnAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            t::StartNote startNote;
            t::TrillStep trillStep;
            t::TwoNoteTurn twoNoteTurn;
            t::YesNo accelerate;
            t::TrillBeats beats;
            t::Percent secondBeat;
            t::Percent lastBeat;
            t::YesNo slash;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
            bool hasStartNote;
            bool hasTrillStep;
            bool hasTwoNoteTurn;
            bool hasAccelerate;
            bool hasBeats;
            bool hasSecondBeat;
            bool hasLastBeat;
            bool hasSlash;
        };
        
        class Turn;
        using TurnPtr = std::shared_ptr<Turn>;
        using TurnUPtr = std::unique_ptr<Turn>;
        using TurnSet = std::vector<TurnPtr>;
        using TurnSetIter = TurnSet::iterator;
        using TurnSetIterConst = TurnSet::const_iterator;
        inline TurnPtr makeTurn() { return std::make_shared<Turn>(); }
        class Turn : public ElementInterface
        {
        public:
            Turn();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TurnAttributesPtr getAttributes() const;
            void setAttributes( const TurnAttributesPtr& attributes );
        private:
            TurnAttributesPtr myAttributes;
        };
        
        /*
         5138
         <xs:element name="delayed-turn" type="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The delayed-turn element indicates a normal turn that is delayed until the end of the current note.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The horizontal-turn type represents turn elements that are horizontal rather than vertical. These are empty elements with print-style, placement, trill-sound, and slash attributes. If the slash attribute is yes, then a vertical line is used to slash the turn; it is no by default.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="trill-sound"/>
         <xs:attribute name="slash" type="yes-no"/>
         </xs:complexType>
         */
        
        struct DelayedTurnAttributes;
        using DelayedTurnAttributesPtr = std::shared_ptr<DelayedTurnAttributes>;
        
        struct DelayedTurnAttributes : public AttributesInterface
        {
        public:
            DelayedTurnAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            t::StartNote startNote;
            t::TrillStep trillStep;
            t::TwoNoteTurn twoNoteTurn;
            t::YesNo accelerate;
            t::TrillBeats beats;
            t::Percent secondBeat;
            t::Percent lastBeat;
            t::YesNo slash;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
            bool hasStartNote;
            bool hasTrillStep;
            bool hasTwoNoteTurn;
            bool hasAccelerate;
            bool hasBeats;
            bool hasSecondBeat;
            bool hasLastBeat;
            bool hasSlash;
        };
        
        class DelayedTurn;
        using DelayedTurnPtr = std::shared_ptr<DelayedTurn>;
        using DelayedTurnUPtr = std::unique_ptr<DelayedTurn>;
        using DelayedTurnSet = std::vector<DelayedTurnPtr>;
        using DelayedTurnSetIter = DelayedTurnSet::iterator;
        using DelayedTurnSetIterConst = DelayedTurnSet::const_iterator;
        inline DelayedTurnPtr makeDelayedTurn() { return std::make_shared<DelayedTurn>(); }
        class DelayedTurn : public ElementInterface
        {
        public:
            DelayedTurn();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DelayedTurnAttributesPtr getAttributes() const;
            void setAttributes( const DelayedTurnAttributesPtr& attributes );
        private:
            DelayedTurnAttributesPtr myAttributes;
        };
        
        /*
         5143
         <xs:element name="inverted-turn" type="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The inverted-turn element has the shape which goes down and then up.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The horizontal-turn type represents turn elements that are horizontal rather than vertical. These are empty elements with print-style, placement, trill-sound, and slash attributes. If the slash attribute is yes, then a vertical line is used to slash the turn; it is no by default.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="trill-sound"/>
         <xs:attribute name="slash" type="yes-no"/>
         </xs:complexType>
         */
        
        struct InvertedTurnAttributes;
        using InvertedTurnAttributesPtr = std::shared_ptr<InvertedTurnAttributes>;
        
        struct InvertedTurnAttributes : public AttributesInterface
        {
        public:
            InvertedTurnAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            t::StartNote startNote;
            t::TrillStep trillStep;
            t::TwoNoteTurn twoNoteTurn;
            t::YesNo accelerate;
            t::TrillBeats beats;
            t::Percent secondBeat;
            t::Percent lastBeat;
            t::YesNo slash;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
            bool hasStartNote;
            bool hasTrillStep;
            bool hasTwoNoteTurn;
            bool hasAccelerate;
            bool hasBeats;
            bool hasSecondBeat;
            bool hasLastBeat;
            bool hasSlash;
        };
        
        class InvertedTurn;
        using InvertedTurnPtr = std::shared_ptr<InvertedTurn>;
        using InvertedTurnUPtr = std::unique_ptr<InvertedTurn>;
        using InvertedTurnSet = std::vector<InvertedTurnPtr>;
        using InvertedTurnSetIter = InvertedTurnSet::iterator;
        using InvertedTurnSetIterConst = InvertedTurnSet::const_iterator;
        inline InvertedTurnPtr makeInvertedTurn() { return std::make_shared<InvertedTurn>(); }
        class InvertedTurn : public ElementInterface
        {
        public:
            InvertedTurn();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            InvertedTurnAttributesPtr getAttributes() const;
            void setAttributes( const InvertedTurnAttributesPtr& attributes );
        private:
            InvertedTurnAttributesPtr myAttributes;
        };
        
        /*
         5148
         <xs:element name="delayed-inverted-turn" type="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The delayed-inverted-turn element indicates an inverted turn that is delayed until the end of the current note.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The horizontal-turn type represents turn elements that are horizontal rather than vertical. These are empty elements with print-style, placement, trill-sound, and slash attributes. If the slash attribute is yes, then a vertical line is used to slash the turn; it is no by default.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="trill-sound"/>
         <xs:attribute name="slash" type="yes-no"/>
         </xs:complexType>
         */
        
        struct DelayedInvertedTurnAttributes;
        using DelayedInvertedTurnAttributesPtr = std::shared_ptr<DelayedInvertedTurnAttributes>;
        
        struct DelayedInvertedTurnAttributes : public AttributesInterface
        {
        public:
            DelayedInvertedTurnAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::AboveBelow placement;
            t::StartNote startNote;
            t::TrillStep trillStep;
            t::TwoNoteTurn twoNoteTurn;
            t::YesNo accelerate;
            t::TrillBeats beats;
            t::Percent secondBeat;
            t::Percent lastBeat;
            t::YesNo slash;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPlacement;
            bool hasStartNote;
            bool hasTrillStep;
            bool hasTwoNoteTurn;
            bool hasAccelerate;
            bool hasBeats;
            bool hasSecondBeat;
            bool hasLastBeat;
            bool hasSlash;
        };
        
        class DelayedInvertedTurn;
        using DelayedInvertedTurnPtr = std::shared_ptr<DelayedInvertedTurn>;
        using DelayedInvertedTurnUPtr = std::unique_ptr<DelayedInvertedTurn>;
        using DelayedInvertedTurnSet = std::vector<DelayedInvertedTurnPtr>;
        using DelayedInvertedTurnSetIter = DelayedInvertedTurnSet::iterator;
        using DelayedInvertedTurnSetIterConst = DelayedInvertedTurnSet::const_iterator;
        inline DelayedInvertedTurnPtr makeDelayedInvertedTurn() { return std::make_shared<DelayedInvertedTurn>(); }
        class DelayedInvertedTurn : public ElementInterface
        {
        public:
            DelayedInvertedTurn();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DelayedInvertedTurnAttributesPtr getAttributes() const;
            void setAttributes( const DelayedInvertedTurnAttributesPtr& attributes );
        private:
            DelayedInvertedTurnAttributesPtr myAttributes;
        };
        
        /*
         5163 [ equivalents 3026, 5163 ]
         <xs:element name="wavy-line" type="wavy-line"/>
         <xs:complexType name="wavy-line">
         <xs:annotation>
         <xs:documentation>Wavy lines are one way to indicate trills. When used with a measure element, they should always have type="continue" set.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="type" type="start-stop-continue" use="required"/>
         <xs:attribute name="number" type="number-level"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="color"/>
         <xs:attributeGroup ref="trill-sound"/>
         </xs:complexType>
         */
        
        /*
         5628
         <xs:element name="tuplet-dot" type="tuplet-dot" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="tuplet-dot">
         <xs:annotation>
         <xs:documentation>The tuplet-dot type is used to specify dotted normal tuplet types.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         </xs:complexType>
         */
        
        struct TupletDotAttributes;
        using TupletDotAttributesPtr = std::shared_ptr<TupletDotAttributes>;
        
        struct TupletDotAttributes : public AttributesInterface
        {
        public:
            TupletDotAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class TupletDot;
        using TupletDotPtr = std::shared_ptr<TupletDot>;
        using TupletDotUPtr = std::unique_ptr<TupletDot>;
        using TupletDotSet = std::vector<TupletDotPtr>;
        using TupletDotSetIter = TupletDotSet::iterator;
        using TupletDotSetIterConst = TupletDotSet::const_iterator;
        inline TupletDotPtr makeTupletDot() { return std::make_shared<TupletDot>(); }
        class TupletDot : public ElementInterface
        {
        public:
            TupletDot();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TupletDotAttributesPtr getAttributes() const;
            void setAttributes( const TupletDotAttributesPtr& attributes );
        private:
            TupletDotAttributesPtr myAttributes;
        };
        
        /*
         5662 [ equivalents 5662, 5683, 6340 ]
         <xs:element name="link" type="link" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="link">
         <xs:annotation>
         <xs:documentation>The link type serves as an outgoing simple XLink. It is also used to connect a MusicXML score with a MusicXML opus. If a relative link is used within a document that is part of a compressed MusicXML file, the link is relative to the  root folder of the zip file.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="link-attributes"/>
         <xs:attribute name="name" type="xs:token"/>
         <xs:attributeGroup ref="element-position"/>
         <xs:attributeGroup ref="position"/>
         </xs:complexType>
         */
        
        struct LinkAttributes;
        using LinkAttributesPtr = std::shared_ptr<LinkAttributes>;
        
        struct LinkAttributes : public AttributesInterface
        {
        public:
            LinkAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XlinkHref href;
            const t::XlinkType type;
            t::XlinkRole role;
            t::XlinkTitle title;
            t::XlinkShow show;
            t::XlinkActuate actuate;
            t::XsToken name;
            t::XsNMToken element;
            t::PositiveInteger position;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            const   bool hasHref;
            bool hasType;
            bool hasRole;
            bool hasTitle;
            bool hasShow;
            bool hasActuate;
            bool hasName;
            bool hasElement;
            bool hasPosition;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
        };
        
        class Link;
        using LinkPtr = std::shared_ptr<Link>;
        using LinkUPtr = std::unique_ptr<Link>;
        using LinkSet = std::vector<LinkPtr>;
        using LinkSetIter = LinkSet::iterator;
        using LinkSetIterConst = LinkSet::const_iterator;
        inline LinkPtr makeLink() { return std::make_shared<Link>(); }
        class Link : public ElementInterface
        {
        public:
            Link();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            LinkAttributesPtr getAttributes() const;
            void setAttributes( const LinkAttributesPtr& attributes );
        private:
            LinkAttributesPtr myAttributes;
        };
        
        /*
         5667 [ equivalents 5667, 5688, 6343 ]
         <xs:element name="bookmark" type="bookmark" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="bookmark">
         <xs:annotation>
         <xs:documentation>The bookmark type serves as a well-defined target for an incoming simple XLink.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="id" type="xs:ID" use="required"/>
         <xs:attribute name="name" type="xs:token"/>
         <xs:attributeGroup ref="element-position"/>
         </xs:complexType>
         */
        
        struct BookmarkAttributes;
        using BookmarkAttributesPtr = std::shared_ptr<BookmarkAttributes>;
        
        struct BookmarkAttributes : public AttributesInterface
        {
        public:
            BookmarkAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsID id;
            t::XsToken name;
            t::XsNMToken element;
            t::PositiveInteger position;
            const   bool hasId;
            bool hasName;
            bool hasElement;
            bool hasPosition;
        };
        
        class Bookmark;
        using BookmarkPtr = std::shared_ptr<Bookmark>;
        using BookmarkUPtr = std::unique_ptr<Bookmark>;
        using BookmarkSet = std::vector<BookmarkPtr>;
        using BookmarkSetIter = BookmarkSet::iterator;
        using BookmarkSetIterConst = BookmarkSet::const_iterator;
        inline BookmarkPtr makeBookmark() { return std::make_shared<Bookmark>(); }
        class Bookmark : public ElementInterface
        {
        public:
            Bookmark();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BookmarkAttributesPtr getAttributes() const;
            void setAttributes( const BookmarkAttributesPtr& attributes );
        private:
            BookmarkAttributesPtr myAttributes;
        };
        
        /*
         5673
         <xs:element name="credit-image" type="image"/>
         <xs:complexType name="image">
         <xs:annotation>
         <xs:documentation>The image type is used to include graphical images in a score.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="image-attributes"/>
         </xs:complexType>
         */
        
        struct CreditImageAttributes;
        using CreditImageAttributesPtr = std::shared_ptr<CreditImageAttributes>;
        
        struct CreditImageAttributes : public AttributesInterface
        {
        public:
            CreditImageAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsAnyUri source;
            t::XsToken type;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::LeftCenterRight halign;
            const   bool hasSource;
            const   bool hasType;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasHalign;
        };
        
        class CreditImage;
        using CreditImagePtr = std::shared_ptr<CreditImage>;
        using CreditImageUPtr = std::unique_ptr<CreditImage>;
        using CreditImageSet = std::vector<CreditImagePtr>;
        using CreditImageSetIter = CreditImageSet::iterator;
        using CreditImageSetIterConst = CreditImageSet::const_iterator;
        inline CreditImagePtr makeCreditImage() { return std::make_shared<CreditImage>(); }
        class CreditImage : public ElementInterface
        {
        public:
            CreditImage();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            CreditImageAttributesPtr getAttributes() const;
            void setAttributes( const CreditImageAttributesPtr& attributes );
        private:
            CreditImageAttributesPtr myAttributes;
        };
        
        /*
         5683 [ equivalents 5662, 5683, 6340 ]
         <xs:element name="link" type="link" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="link">
         <xs:annotation>
         <xs:documentation>The link type serves as an outgoing simple XLink. It is also used to connect a MusicXML score with a MusicXML opus. If a relative link is used within a document that is part of a compressed MusicXML file, the link is relative to the  root folder of the zip file.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="link-attributes"/>
         <xs:attribute name="name" type="xs:token"/>
         <xs:attributeGroup ref="element-position"/>
         <xs:attributeGroup ref="position"/>
         </xs:complexType>
         */
        
        /*
         5688 [ equivalents 5667, 5688, 6343 ]
         <xs:element name="bookmark" type="bookmark" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="bookmark">
         <xs:annotation>
         <xs:documentation>The bookmark type serves as a well-defined target for an incoming simple XLink.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="id" type="xs:ID" use="required"/>
         <xs:attribute name="name" type="xs:token"/>
         <xs:attributeGroup ref="element-position"/>
         </xs:complexType>
         */
        
        /*
         5722
         <xs:element name="lyric-font" type="lyric-font" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="lyric-font">
         <xs:annotation>
         <xs:documentation>The lyric-font type specifies the default font for a particular name and number of lyric.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="number" type="xs:NMTOKEN"/>
         <xs:attribute name="name" type="xs:token"/>
         <xs:attributeGroup ref="font"/>
         </xs:complexType>
         */
        
        struct LyricFontAttributes;
        using LyricFontAttributesPtr = std::shared_ptr<LyricFontAttributes>;
        
        struct LyricFontAttributes : public AttributesInterface
        {
        public:
            LyricFontAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsNMToken number;
            t::XsToken name;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            bool hasNumber;
            bool hasName;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
        };
        
        class LyricFont;
        using LyricFontPtr = std::shared_ptr<LyricFont>;
        using LyricFontUPtr = std::unique_ptr<LyricFont>;
        using LyricFontSet = std::vector<LyricFontPtr>;
        using LyricFontSetIter = LyricFontSet::iterator;
        using LyricFontSetIterConst = LyricFontSet::const_iterator;
        inline LyricFontPtr makeLyricFont() { return std::make_shared<LyricFont>(); }
        class LyricFont : public ElementInterface
        {
        public:
            LyricFont();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            LyricFontAttributesPtr getAttributes() const;
            void setAttributes( const LyricFontAttributesPtr& attributes );
        private:
            LyricFontAttributesPtr myAttributes;
        };
        
        /*
         5727
         <xs:element name="lyric-language" type="lyric-language" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="lyric-language">
         <xs:annotation>
         <xs:documentation>The lyric-language type specifies the default language for a particular name and number of lyric.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="number" type="xs:NMTOKEN"/>
         <xs:attribute name="name" type="xs:token"/>
         <xs:attribute ref="xml:lang" use="required"/>
         </xs:complexType>
         */
        
        struct LyricLanguageAttributes;
        using LyricLanguageAttributesPtr = std::shared_ptr<LyricLanguageAttributes>;
        
        struct LyricLanguageAttributes : public AttributesInterface
        {
        public:
            LyricLanguageAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsNMToken number;
            t::XsToken name;
            t::XmlLang lang;
            bool hasNumber;
            bool hasName;
            const   bool hasLang;
        };
        
        class LyricLanguage;
        using LyricLanguagePtr = std::shared_ptr<LyricLanguage>;
        using LyricLanguageUPtr = std::unique_ptr<LyricLanguage>;
        using LyricLanguageSet = std::vector<LyricLanguagePtr>;
        using LyricLanguageSetIter = LyricLanguageSet::iterator;
        using LyricLanguageSetIterConst = LyricLanguageSet::const_iterator;
        inline LyricLanguagePtr makeLyricLanguage() { return std::make_shared<LyricLanguage>(); }
        class LyricLanguage : public ElementInterface
        {
        public:
            LyricLanguage();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            LyricLanguageAttributesPtr getAttributes() const;
            void setAttributes( const LyricLanguageAttributesPtr& attributes );
        private:
            LyricLanguageAttributesPtr myAttributes;
        };
        
        /*
         6001
         <xs:element name="opus" type="opus" minOccurs="0"/>
         <xs:complexType name="opus">
         <xs:annotation>
         <xs:documentation>The opus type represents a link to a MusicXML opus document that composes multiple MusicXML scores into a collection.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="link-attributes"/>
         </xs:complexType>
         */
        
        struct OpusAttributes;
        using OpusAttributesPtr = std::shared_ptr<OpusAttributes>;
        
        struct OpusAttributes : public AttributesInterface
        {
        public:
            OpusAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XlinkHref href;
            const t::XlinkType type;
            t::XlinkRole role;
            t::XlinkTitle title;
            t::XlinkShow show;
            t::XlinkActuate actuate;
            const   bool hasHref;
            bool hasType;
            bool hasRole;
            bool hasTitle;
            bool hasShow;
            bool hasActuate;
        };
        
        class Opus;
        using OpusPtr = std::shared_ptr<Opus>;
        using OpusUPtr = std::unique_ptr<Opus>;
        using OpusSet = std::vector<OpusPtr>;
        using OpusSetIter = OpusSet::iterator;
        using OpusSetIterConst = OpusSet::const_iterator;
        inline OpusPtr makeOpus() { return std::make_shared<Opus>(); }
        class Opus : public ElementInterface
        {
        public:
            Opus();
            virtual bool hasAttributes() const;
            virtual bool hasContents() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            OpusAttributesPtr getAttributes() const;
            void setAttributes( const OpusAttributesPtr& attributes );
        private:
            OpusAttributesPtr myAttributes;
        };
        
        /*
         6340 [ equivalents 5662, 5683, 6340 ]
         <xs:element name="link" type="link"/>
         <xs:complexType name="link">
         <xs:annotation>
         <xs:documentation>The link type serves as an outgoing simple XLink. It is also used to connect a MusicXML score with a MusicXML opus. If a relative link is used within a document that is part of a compressed MusicXML file, the link is relative to the  root folder of the zip file.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="link-attributes"/>
         <xs:attribute name="name" type="xs:token"/>
         <xs:attributeGroup ref="element-position"/>
         <xs:attributeGroup ref="position"/>
         </xs:complexType>
         */
        
        /*
         6343 [ equivalents 5667, 5688, 6343 ]
         <xs:element name="bookmark" type="bookmark"/>
         <xs:complexType name="bookmark">
         <xs:annotation>
         <xs:documentation>The bookmark type serves as a well-defined target for an incoming simple XLink.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="id" type="xs:ID" use="required"/>
         <xs:attribute name="name" type="xs:token"/>
         <xs:attributeGroup ref="element-position"/>
         </xs:complexType>
         */
        
        /*************************** COMPOSITE ELEMENTS ***************************/
        /*
         <xs:group name="traditional-key">
         <xs:annotation>
         <xs:documentation>The traditional-key group represents a traditional key signature using the cycle of fifths.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="cancel" type="cancel" minOccurs="0"/>
         <xs:element name="fifths" type="fifths"/>
         <xs:element name="mode" type="mode" minOccurs="0"/>
         </xs:sequence>
         </xs:group>
         */
        class TraditionalKey;
        using TraditionalKeyPtr = std::shared_ptr<TraditionalKey>;
        using TraditionalKeyUPtr = std::unique_ptr<TraditionalKey>;
        using TraditionalKeySet = std::vector<TraditionalKey>;
        using TraditionalKeySetIter = TraditionalKeySet::iterator;
        using TraditionalKeySetIterConst = TraditionalKeySet::const_iterator;
        inline TraditionalKeyPtr makeTraditionalKey() { return std::make_shared<TraditionalKey>(); }
        class TraditionalKey : public ElementInterface
        {
        public:
            TraditionalKey();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            CancelPtr getCancel() const;
            void setCancel( const CancelPtr& value );
            bool getHasCancel() const;
            void setHasCancel( const bool value );
            FifthsPtr getFifths() const;
            void setFifths( const FifthsPtr& value );
            ModePtr getMode() const;
            void setMode( const ModePtr& value );
            bool getHasMode() const;
            void setHasMode( const bool value );
        private:
            CancelPtr myCancel;
            FifthsPtr myFifths;
            ModePtr myMode;
            bool myHasCancel;
            bool myHasMode;
        };
        
        /*
         <xs:group name="non-traditional-key">
         <xs:annotation>
         <xs:documentation>The non-traditional-key group represents a single alteration within a non-traditional key signature. A sequence of these groups makes up a non-traditional key signature</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="key-step" type="step">
         <xs:annotation>
         <xs:documentation>Non-traditional key signatures can be represented using the Humdrum/Scot concept of a list of altered tones. The key-step element indicates the pitch step to be altered, represented using the same names as in the step element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="key-alter" type="semitones">
         <xs:annotation>
         <xs:documentation>Non-traditional key signatures can be represented using the Humdrum/Scot concept of a list of altered tones. The key-alter element represents the alteration for a given pitch step, represented with semitones in the same manner as the alter element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="key-accidental" type="accidental-value" minOccurs="0">
         <xs:annotation>
         <xs:documentation>Non-traditional key signatures can be represented using the Humdrum/Scot concept of a list of altered tones. The key-accidental element indicates the accidental to be displayed in the key signature, represented in the same manner as the accidental element. It is used for disambiguating microtonal accidentals.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         */
        class NonTraditionalKey;
        using NonTraditionalKeyPtr = std::shared_ptr<NonTraditionalKey>;
        using NonTraditionalKeyUPtr = std::shared_ptr<NonTraditionalKey>;
        using NonTraditionalKeySet = std::vector<NonTraditionalKeyPtr>;
        using NonTraditionalKeySetIter = NonTraditionalKeySet::iterator;
        using NonTraditionalKeySetIterConst = NonTraditionalKeySet::const_iterator;
        inline NonTraditionalKeyPtr makeNonTraditionalKey() { return std::make_shared<NonTraditionalKey>(); }
        class NonTraditionalKey : public ElementInterface
        {
        public:
            NonTraditionalKey();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            KeyStepPtr getKeyStep() const;
            void setKeyStep( const KeyStepPtr& value );
            KeyAlterPtr getKeyAlter() const;
            void setKeyAlter( const KeyAlterPtr& value );
            KeyAccidentalPtr getKeyAccidental() const;
            void setKeyAccidental( const KeyAccidentalPtr& value );
            bool getHasKeyAccidental() const;
            void setHasKeyAccivental( const bool value );
        private:
            KeyStepPtr myKeyStep;
            KeyAlterPtr myKeyAlter;
            KeyAccidentalPtr myKeyAccidental;
            bool myHasKeyAccidental;
        };
        
        /*
         <xs:complexType name="key">
         <xs:annotation>
         <xs:documentation>The key type represents a key signature. Both traditional and non-traditional key signatures are supported. The optional number attribute refers to staff numbers. If absent, the key signature applies to all staves in the part. Key signatures appear at the start of each system unless the print-object attribute has been set to "no".</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice>
         <xs:group ref="traditional-key"/>
         <xs:group ref="non-traditional-key" minOccurs="0" maxOccurs="unbounded"/>
         </xs:choice>
         <xs:element name="key-octave" type="key-octave" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The optional list of key-octave elements is used to specify in which octave each element of the key signature appears.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         <xs:attribute name="number" type="staff-number"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="print-object"/>
         </xs:complexType>
         */
        
        class KeyChoice;
        using KeyChoicePtr = std::shared_ptr<KeyChoice>;
        using KeyChoiceUPtr = std::unique_ptr<KeyChoice>;
        using KeyChoiceSet = std::vector<KeyChoice>;
        using KeyChoiceSetIter = KeyChoiceSet::iterator;
        using KeyChoiceSetIterConst = KeyChoiceSet::const_iterator;
        inline KeyChoicePtr makeKeyChoice() { return std::make_shared<KeyChoice>(); }
        class KeyChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                traditionalKey = 0,
                nonTraditionalKey = 1
            };
            KeyChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            Choice getChoice() const;
            void setChoice( const Choice value );
            TraditionalKeyPtr getTraditionalKey() const;
            void setTraditionalKey( const TraditionalKeyPtr& value );
            
            const NonTraditionalKeySet& getNonTraditionalKeySet() const;
            void removeNonTraditionalKey( const NonTraditionalKeySetIterConst& value );
            void addNonTraditionalKey( const NonTraditionalKeyPtr& value );
            void clearNonTraditionalKeySet();
            
        private:
            Choice myChoice;
            TraditionalKeyPtr myTraditionalKey;
            NonTraditionalKeySet myNonTraditionalKeySet;
        };
        
        /*
         2614
         <xs:element name="key" type="key" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The key element represents a key signature. Both traditional and non-traditional key signatures are supported. The optional number attribute refers to staff numbers. If absent, the key signature applies to all staves in the part.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="key">
         <xs:annotation>
         <xs:documentation>The key type represents a key signature. Both traditional and non-traditional key signatures are supported. The optional number attribute refers to staff numbers. If absent, the key signature applies to all staves in the part. Key signatures appear at the start of each system unless the print-object attribute has been set to "no".</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice>
         <xs:group ref="traditional-key"/>
         <xs:group ref="non-traditional-key" minOccurs="0" maxOccurs="unbounded"/>
         </xs:choice>
         <xs:element name="key-octave" type="key-octave" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The optional list of key-octave elements is used to specify in which octave each element of the key signature appears.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         <xs:attribute name="number" type="staff-number"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="print-object"/>
         </xs:complexType>
         */
        
        struct KeyAttributes;
        using KeyAttributesPtr = std::shared_ptr<KeyAttributes>;
        struct KeyAttributes : public AttributesInterface
        {
        public:
            KeyAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StaffNumber number;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::YesNo printObject;
            bool hasNumber;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPrintObject;
        };
        
        class Key;
        using KeyPtr = std::shared_ptr<Key>;
        using KeyUPtr = std::unique_ptr<Key>;
        using KeySet = std::vector<KeyPtr>;
        using KeySetIter = KeySet::iterator;
        using KeySetIterConst = KeySet::const_iterator;
        inline KeyPtr makeKey() { return std::make_shared<Key>(); }
        class Key : public ElementInterface
        {
        public:
            Key();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            KeyAttributesPtr getAttributes() const;
            void setAttributes( const KeyAttributesPtr& value );
            KeyChoicePtr getKeyChoice() const;
            void setKeyChoice( const KeyChoicePtr& value );
            const KeyOctaveSet& getKeyOctaveSet() const;
            void removeKeyOctave( const KeyOctaveSetIterConst& value );
            void addKeyOctave( const KeyOctavePtr& value );
            void clearKeyOctaveSet();
        private:
            KeyAttributesPtr myAttributes;
            KeyChoicePtr myKeyChoice;
            KeyOctaveSet myKeyOctaveSet;
        };
        
        /*
         2646
         <xs:element name="clef" type="clef" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>Clefs are represented by a combination of sign, line, and clef-octave-change elements.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="clef">
         <xs:annotation>
         <xs:documentation>Clefs are represented by a combination of sign, line, and clef-octave-change elements. The optional number attribute refers to staff numbers within the part. A value of 1 is assumed if not present.
         
         Sometimes clefs are added to the staff in non-standard line positions, either to indicate cue passages, or when there are multiple clefs present simultaneously on one staff. In this situation, the additional attribute is set to "yes" and the line value is ignored. The size attribute is used for clefs where the additional attribute is "yes". It is typically used to indicate cue clefs.
         
         Sometimes clefs at the start of a measure need to appear after the barline rather than before, as for cues or for use after a repeated section. The after-barline attribute is set to "yes" in this situation. The attribute is ignored for mid-measure clefs.
         
         Clefs appear at the start of each system unless the print-object attribute has been set to "no" or the additional attribute has been set to "yes".</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="sign" type="clef-sign">
         <xs:annotation>
         <xs:documentation>The sign element represents the clef symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="line" type="staff-line" minOccurs="0">
         <xs:annotation>
         <xs:documentation>Line numbers are counted from the bottom of the staff. Standard values are 2 for the G sign (treble clef), 4 for the F sign (bass clef), 3 for the C sign (alto clef) and 5 for TAB (on a 6-line staff).</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="clef-octave-change" type="xs:integer" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The clef-octave-change element is used for transposing clefs. A treble clef for tenors would have a value of -1.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         <xs:attribute name="number" type="staff-number"/>
         <xs:attribute name="additional" type="yes-no"/>
         <xs:attribute name="size" type="symbol-size"/>
         <xs:attribute name="after-barline" type="yes-no"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="print-object"/>
         </xs:complexType>
         */
        
        struct ClefAttributes;
        using ClefAttributesPtr = std::shared_ptr<ClefAttributes>;
        
        struct ClefAttributes : public AttributesInterface
        {
        public:
            ClefAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StaffNumber number;
            t::YesNo additional;
            t::SymbolSize size;
            t::YesNo afterBarline;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::YesNo printObject;
            bool hasNumber;
            bool hasAdditional;
            bool hasSize;
            bool hasAfterBarline;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasPrintObject;
        };
        
        class Clef;
        using ClefPtr = std::shared_ptr<Clef>;
        using ClefUPtr = std::unique_ptr<Clef>;
        using ClefSet = std::vector<ClefPtr>;
        using ClefSetIter = ClefSet::iterator;
        using ClefSetIterConst = ClefSet::const_iterator;
        inline ClefPtr makeClef() { return std::make_shared<Clef>(); }
        class Clef : public ElementInterface
        {
        public:
            Clef();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            ClefAttributesPtr getAttributes() const;
            void setAttributes( const ClefAttributesPtr& value );
            /* _________ Sign minOccurs = 1, maxOccurs = 1 _________ */
            SignPtr getSign() const;
            void setSign( const SignPtr& value );
            /* _________ Line minOccurs = 0, maxOccurs = 1 _________ */
            LinePtr getLine() const;
            void setLine( const LinePtr& value );
            bool getHasLine() const;
            void setHasLine( const bool value );
            /* _________ ClefOctaveChange minOccurs = 0, maxOccurs = 1 _________ */
            ClefOctaveChangePtr getClefOctaveChange() const;
            void setClefOctaveChange( const ClefOctaveChangePtr& value );
            bool getHasClefOctaveChange() const;
            void setHasClefOctaveChange( const bool value );
        private:
            ClefAttributesPtr myAttributes;
            SignPtr mySign;
            LinePtr myLine;
            bool myHasLine;
            ClefOctaveChangePtr myClefOctaveChange;
            bool myHasClefOctaveChange;
        };
        /*
         2660
         <xs:element name="transpose" type="transpose" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>If the part is being encoded for a transposing instrument in written vs. concert pitch, the transposition must be encoded in the transpose element using the transpose type.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="transpose">
         <xs:annotation>
         <xs:documentation>The transpose type represents what must be added to a written pitch to get a correct sounding pitch. The optional number attribute refers to staff numbers, from top to bottom on the system. If absent, the transposition applies to all staves in the part. Per-staff transposition is most often used in parts that represent multiple instruments.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="diatonic" type="xs:integer" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The diatonic element specifies the number of pitch steps needed to go from written to sounding pitch. This allows for correct spelling of enharmonic transpositions.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="chromatic" type="semitones">
         <xs:annotation>
         <xs:documentation>The chromatic element represents the number of semitones needed to get from written to sounding pitch. This value does not include octave-change values; the values for both elements need to be added to the written pitch to get the correct sounding pitch.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="octave-change" type="xs:integer" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The octave-change element indicates how many octaves to add to get from written pitch to sounding pitch.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="double" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>If the double element is present, it indicates that the music is doubled one octave down from what is currently written (as is the case for mixed cello / bass parts in orchestral literature).</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         <xs:attribute name="number" type="staff-number"/>
         </xs:complexType>
         */
        
        struct TransposeAttributes;
        using TransposeAttributesPtr = std::shared_ptr<TransposeAttributes>;
        
        struct TransposeAttributes : public AttributesInterface
        {
        public:
            TransposeAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StaffNumber number;
            bool hasNumber;
        };
        
        class Transpose;
        using TransposePtr = std::shared_ptr<Transpose>;
        using TransposeUPtr = std::unique_ptr<Transpose>;
        using TransposeSet = std::vector<TransposePtr>;
        using TransposeSetIter = TransposeSet::iterator;
        using TransposeSetIterConst = TransposeSet::const_iterator;
        inline TransposePtr makeTranspose() { return std::make_shared<Transpose>(); }
        class Transpose : public ElementInterface
        {
        public:
            Transpose();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TransposeAttributesPtr getAttributes() const;
            void setAttributes( const TransposeAttributesPtr& value );
            /* _________ Diatonic minOccurs = 0, maxOccurs = 1 _________ */
            DiatonicPtr getDiatonic() const;
            void setDiatonic( const DiatonicPtr& value );
            bool getHasDiatonic() const;
            void setHasDiatonic( const bool value );
            /* _________ Chromatic minOccurs = 1, maxOccurs = 1 _________ */
            ChromaticPtr getChromatic() const;
            void setChromatic( const ChromaticPtr& value );
            /* _________ OctaveChange minOccurs = 0, maxOccurs = 1 _________ */
            OctaveChangePtr getOctaveChange() const;
            void setOctaveChange( const OctaveChangePtr& value );
            bool getHasOctaveChange() const;
            void setHasOctaveChange( const bool value );
            /* _________ Double minOccurs = 0, maxOccurs = 1 _________ */
            DoublePtr getDouble() const;
            void setDouble( const DoublePtr& value );
            bool getHasDouble() const;
            void setHasDouble( const bool value );
        private:
            TransposeAttributesPtr myAttributes;
            DiatonicPtr myDiatonic;
            bool myHasDiatonic;
            ChromaticPtr myChromatic;
            OctaveChangePtr myOctaveChange;
            bool myHasOctaveChange;
            DoublePtr myDouble;
            bool myHasDouble;
        };
        
        /*
         2667
         <xs:element name="directive" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>Directives are like directions, but can be grouped together with attributes for convenience. This is typically used for tempo markings at the beginning of a piece of music. This element has been deprecated in Version 2.0 in favor of the directive attribute for direction elements. Language names come from ISO 639, with optional country subcodes from ISO 3166.</xs:documentation>
         </xs:annotation>
         <xs:complexType>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         <xs:attribute ref="xml:lang"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         </xs:element>
         */
        
        struct DirectiveAttributes;
        using DirectiveAttributesPtr = std::shared_ptr<DirectiveAttributes>;
        
        struct DirectiveAttributes : public AttributesInterface
        {
        public:
            DirectiveAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::XmlLang lang;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasLang;
        };
        
        class Directive;
        using DirectivePtr = std::shared_ptr<Directive>;
        using DirectiveUPtr = std::unique_ptr<Directive>;
        using DirectiveSet = std::vector<DirectivePtr>;
        using DirectiveSetIter = DirectiveSet::iterator;
        using DirectiveSetIterConst = DirectiveSet::const_iterator;
        inline DirectivePtr makeDirective() { return std::make_shared<Directive>(); }
        inline DirectivePtr makeDirective( const t::XsString& value ) { return std::make_shared<Directive>( value ); }
        inline DirectivePtr makeDirective( t::XsString&& value ) { return std::make_shared<Directive>( std::move( value ) ); }
        class Directive : public ElementInterface
        {
        public:
            Directive();
            Directive( const t::XsString& value );
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DirectiveAttributesPtr getAttributes() const;
            void setAttributes( const DirectiveAttributesPtr& value );
            t::XsString getValue() const;
            void setValue( const t::XsString& value );
        private:
            DirectiveAttributesPtr myAttributes;
            t::XsString myValue;
        };
        /*
         <!--  ID = 2836 [2836] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- RecursiveSubElementCount = 2 -->
         <xs:element name="beat-repeat" type="beat-repeat"/>
         <xs:complexType name="beat-repeat">
         <xs:annotation>
         <xs:documentation>The beat-repeat type is used to indicate that a single beat (but possibly many notes) is repeated. Both the start and stop of the beat being repeated should be specified. The slashes attribute specifies the number of slashes to use in the symbol. The use-dots attribute indicates whether or not to use dots as well (for instance, with mixed rhythm patterns). By default, the value for slashes is 1 and the value for use-dots is no.
         
         The beat-repeat element specifies a notation style for repetitions. The actual music being repeated needs to be repeated within the MusicXML file. This element specifies the notation that indicates the repeat.</xs:documentation>
         </xs:annotation>
         <xs:group ref="slash" minOccurs="0"/>
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="slashes" type="xs:positiveInteger"/>
         <xs:attribute name="use-dots" type="yes-no"/>
         </xs:complexType>
         <xs:group name="slash">
         <xs:annotation>
         <xs:documentation>The slash group combines elements used for more complete specification of the slash and beat-repeat measure-style elements. They have the same values as the type and dot elements, and define what the beat is for the display of repetition marks. If not present, the beat is based on the current time signature.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="slash-type" type="note-type-value">
         <xs:annotation>
         <xs:documentation>The slash-type element indicates the graphical note type to use for the display of repetition marks.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="slash-dot" type="empty" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The slash-dot element is used to specify any augmentation dots in the note type used to display repetition marks.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         */
        
        struct BeatRepeatAttributes;
        using BeatRepeatAttributesPtr = std::shared_ptr<BeatRepeatAttributes>;
        
        struct BeatRepeatAttributes : public AttributesInterface
        {
        public:
            BeatRepeatAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            // t::YesNo slash;
            t::StartStop type;
            t::PositiveInteger slashes;
            t::YesNo useDots;
            bool hasSlash;
            const bool hasType;
            bool hasSlashes;
            bool hasUseDots;
        };
        
        class BeatRepeat;
        using BeatRepeatPtr = std::shared_ptr<BeatRepeat>;
        using BeatRepeatUPtr = std::unique_ptr<BeatRepeat>;
        using BeatRepeatSet = std::vector<BeatRepeatPtr>;
        using BeatRepeatSetIter = BeatRepeatSet::iterator;
        using BeatRepeatSetIterConst = BeatRepeatSet::const_iterator;
        inline BeatRepeatPtr makeBeatRepeat() { return std::make_shared<BeatRepeat>(); }
        class BeatRepeat : public ElementInterface
        {
        public:
            BeatRepeat();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BeatRepeatAttributesPtr getAttributes() const;
            void setAttributes( const BeatRepeatAttributesPtr& value );
            /* _________ SlashType minOccurs = 1, maxOccurs = 1 _________ */
            SlashTypePtr getSlashType() const;
            void setSlashType( const SlashTypePtr& value );
            /* _________ SlashDot minOccurs = 0, maxOccurs = unbounded _________ */
            const SlashDotSet& getSlashDotSet() const;
            void addSlashDot( const SlashDotPtr& value );
            void removeSlashDot( const SlashDotSetIterConst& value );
            void clearSlashDotSet();
        private:
            BeatRepeatAttributesPtr myAttributes;
            SlashTypePtr mySlashType;
            SlashDotSet mySlashDotSet;
        };
        /*
         2839
         <!--  ID = 2839 [2839] ------------------------->
         <!-- RecursiveSubElementCount = 2 -->
         <xs:element name="slash" type="slash"/>
         <xs:complexType name="slash">
         <xs:annotation>
         <xs:documentation>The slash type is used to indicate that slash notation is to be used. If the slash is on every beat, use-stems is no (the default). To indicate rhythms but not pitches, use-stems is set to yes. The type attribute indicates whether this is the start or stop of a slash notation style. The use-dots attribute works as for the beat-repeat element, and only has effect if use-stems is no.</xs:documentation>
         </xs:annotation>
         <xs:group ref="slash" minOccurs="0"/>
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="use-dots" type="yes-no"/>
         <xs:attribute name="use-stems" type="yes-no"/>
         </xs:complexType>
         <xs:group name="slash">
         <xs:annotation>
         <xs:documentation>The slash group combines elements used for more complete specification of the slash and beat-repeat measure-style elements. They have the same values as the type and dot elements, and define what the beat is for the display of repetition marks. If not present, the beat is based on the current time signature.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="slash-type" type="note-type-value">
         <xs:annotation>
         <xs:documentation>The slash-type element indicates the graphical note type to use for the display of repetition marks.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="slash-dot" type="empty" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The slash-dot element is used to specify any augmentation dots in the note type used to display repetition marks.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         */
        
        struct SlashAttributes;
        using SlashAttributesPtr = std::shared_ptr<SlashAttributes>;
        
        struct SlashAttributes : public AttributesInterface
        {
        public:
            SlashAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            t::YesNo useDots;
            t::YesNo useStems;
            const 	bool hasType;
            bool hasUseDots;
            bool hasUseStems;
        };
        
        class Slash;
        using SlashPtr = std::shared_ptr<Slash>;
        using SlashUPtr = std::unique_ptr<Slash>;
        using SlashSet = std::vector<SlashPtr>;
        using SlashSetIter = SlashSet::iterator;
        using SlashSetIterConst = SlashSet::const_iterator;
        inline SlashPtr makeSlash() { return std::make_shared<Slash>(); }
        class Slash : public ElementInterface
        {
        public:
            Slash();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            SlashAttributesPtr getAttributes() const;
            void setAttributes( const SlashAttributesPtr& value );
            /* _________ SlashType minOccurs = 1, maxOccurs = 1 _________ */
            SlashTypePtr getSlashType() const;
            void setSlashType( const SlashTypePtr& value );
            /* _________ SlashDot minOccurs = 0, maxOccurs = unbounded _________ */
            const SlashDotSet& getSlashDotSet() const;
            void addSlashDot( const SlashDotPtr& value );
            void removeSlashDot( const SlashDotSetIterConst& value );
            void clearSlashDotSet();
        private:
            SlashAttributesPtr myAttributes;
            SlashTypePtr mySlashType;
            SlashDotSet mySlashDotSet;
        };
        
        /*
         2908
         <!--  ID = 2908 [2908] ------------------------->
         <!-- min=0 max=4294967295 ZeroOrMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 3 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="staff-tuning" type="staff-tuning" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="staff-tuning">
         <xs:annotation>
         <xs:documentation>The staff-tuning type specifies the open, non-capo tuning of the lines on a tablature staff.</xs:documentation>
         </xs:annotation>
         <xs:group ref="tuning"/>
         <xs:attribute name="line" type="staff-line"/>
         </xs:complexType>
         <xs:group name="tuning">
         <xs:annotation>
         <xs:documentation>The tuning group contains the sequence of elements common to the staff-tuning and accord elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="tuning-step" type="step">
         <xs:annotation>
         <xs:documentation>The tuning-step element is represented like the step element, with a different name to reflect is different function.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="tuning-alter" type="semitones" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The tuning-alter element is represented like the alter element, with a different name to reflect is different function.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="tuning-octave" type="octave">
         <xs:annotation>
         <xs:documentation>The tuning-octave element is represented like the octave element, with a different name to reflect is different function.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         */
        
        struct StaffTuningAttributes;
        using StaffTuningAttributesPtr = std::shared_ptr<StaffTuningAttributes>;
        
        struct StaffTuningAttributes : public AttributesInterface
        {
        public:
            StaffTuningAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StaffLine line;
            bool hasLine;
        };
        
        class StaffTuning;
        using StaffTuningPtr = std::shared_ptr<StaffTuning>;
        using StaffTuningUPtr = std::unique_ptr<StaffTuning>;
        using StaffTuningSet = std::vector<StaffTuningPtr>;
        using StaffTuningSetIter = StaffTuningSet::iterator;
        using StaffTuningSetIterConst = StaffTuningSet::const_iterator;
        inline StaffTuningPtr makeStaffTuning() { return std::make_shared<StaffTuning>(); }
        class StaffTuning : public ElementInterface
        {
        public:
            StaffTuning();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            StaffTuningAttributesPtr getAttributes() const;
            void setAttributes( const StaffTuningAttributesPtr& value );
            /* _________ TuningStep minOccurs = 1, maxOccurs = 1 _________ */
            TuningStepPtr getTuningStep() const;
            void setTuningStep( const TuningStepPtr& value );
            /* _________ TuningAlter minOccurs = 0, maxOccurs = 1 _________ */
            TuningAlterPtr getTuningAlter() const;
            void setTuningAlter( const TuningAlterPtr& value );
            bool getHasTuningAlter() const;
            void setHasTuningAlter( const bool value );
            /* _________ TuningOctave minOccurs = 1, maxOccurs = 1 _________ */
            TuningOctavePtr getTuningOctave() const;
            void setTuningOctave( const TuningOctavePtr& value );
        private:
            StaffTuningAttributesPtr myAttributes;
            TuningStepPtr myTuningStep;
            TuningAlterPtr myTuningAlter;
            bool myHasTuningAlter;
            TuningOctavePtr myTuningOctave;
        };
        /*
         2653
         <!--  ID = 2653 [2653] ------------------------->
         <!-- min=0 max=4294967295 ZeroOrMany  -->
         <!-- RecursiveSubElementCount = 8 -->
         <xs:element name="staff-details" type="staff-details" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The staff-details element is used to indicate different types of staves.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="staff-details">
         <xs:annotation>
         <xs:documentation>The staff-details element is used to indicate different types of staves. The optional number attribute specifies the staff number from top to bottom on the system, as with clef. The print-object attribute is used to indicate when a staff is not printed in a part, usually in large scores where empty parts are omitted. It is yes by default. If print-spacing is yes while print-object is no, the score is printed in cutaway format where vertical space is left for the empty part.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="staff-type" type="staff-type" minOccurs="0"/>
         <xs:element name="staff-lines" type="xs:nonNegativeInteger" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The staff-lines element specifies the number of lines for a non 5-line staff.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="staff-tuning" type="staff-tuning" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="capo" type="xs:nonNegativeInteger" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The capo element indicates at which fret a capo should be placed on a fretted instrument. This changes the open tuning of the strings specified by staff-tuning by the specified number of half-steps.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="staff-size" type="non-negative-decimal" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The staff-size element indicates how large a staff space is on this staff, expressed as a percentage of the work's default scaling. Values less than 100 make the staff space smaller while values over 100 make the staff space larger. A staff-type of cue, ossia, or editorial implies a staff-size of less than 100, but the exact value is implementation-dependent unless specified here. Staff size affects staff height only, not the relationship of the staff to the left and right margins.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         <xs:attribute name="number" type="staff-number"/>
         <xs:attribute name="show-frets" type="show-frets"/>
         <xs:attributeGroup ref="print-object"/>
         <xs:attributeGroup ref="print-spacing"/>
         </xs:complexType>
         */
        
        struct StaffDetailsAttributes;
        using StaffDetailsAttributesPtr = std::shared_ptr<StaffDetailsAttributes>;
        
        struct StaffDetailsAttributes : public AttributesInterface
        {
        public:
            StaffDetailsAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StaffNumber number;
            t::ShowFrets showFrets;
            t::YesNo printObject;
            t::YesNo printSpacing;
            bool hasNumber;
            bool hasShowFrets;
            bool hasPrintObject;
            bool hasPrintSpacing;
        };
        
        class StaffDetails;
        using StaffDetailsPtr = std::shared_ptr<StaffDetails>;
        using StaffDetailsUPtr = std::unique_ptr<StaffDetails>;
        using StaffDetailsSet = std::vector<StaffDetailsPtr>;
        using StaffDetailsSetIter = StaffDetailsSet::iterator;
        using StaffDetailsSetIterConst = StaffDetailsSet::const_iterator;
        inline StaffDetailsPtr makeStaffDetails() { return std::make_shared<StaffDetails>(); }
        class StaffDetails : public ElementInterface
        {
        public:
            StaffDetails();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            StaffDetailsAttributesPtr getAttributes() const;
            void setAttributes( const StaffDetailsAttributesPtr& value );
            /* _________ StaffType minOccurs = 0, maxOccurs = 1 _________ */
            StaffTypePtr getStaffType() const;
            void setStaffType( const StaffTypePtr& value );
            bool getHasStaffType() const;
            void setHasStaffType( const bool value );
            /* _________ StaffLines minOccurs = 0, maxOccurs = 1 _________ */
            StaffLinesPtr getStaffLines() const;
            void setStaffLines( const StaffLinesPtr& value );
            bool getHasStaffLines() const;
            void setHasStaffLines( const bool value );
            /* _________ StaffTuning minOccurs = 0, maxOccurs = unbounded _________ */
            const StaffTuningSet& getStaffTuningSet() const;
            void addStaffTuning( const StaffTuningPtr& value );
            void removeStaffTuning( const StaffTuningSetIterConst& value );
            bool getHasStaffTuning() const;
            void setHasStaffTuning( const bool value );
            void clearStaffTuningSet();
            /* _________ Capo minOccurs = 0, maxOccurs = 1 _________ */
            CapoPtr getCapo() const;
            void setCapo( const CapoPtr& value );
            bool getHasCapo() const;
            void setHasCapo( const bool value );
            /* _________ StaffSize minOccurs = 0, maxOccurs = 1 _________ */
            StaffSizePtr getStaffSize() const;
            void setStaffSize( const StaffSizePtr& value );
            bool getHasStaffSize() const;
            void setHasStaffSize( const bool value );
        private:
            StaffDetailsAttributesPtr myAttributes;
            StaffTypePtr myStaffType;
            bool myHasStaffType;
            StaffLinesPtr myStaffLines;
            bool myHasStaffLines;
            StaffTuningSet myStaffTuningSet;
            CapoPtr myCapo;
            bool myHasCapo;
            StaffSizePtr myStaffSize;
            bool myHasStaffSize;
        };
        /*
         2681
         <!--  ID = 2681 [2681] ------------------------->
         <!-- min=0 max=4294967295 ZeroOrMany  -->
         <!-- RecursiveSubElementCount = 8 -->
         <xs:element name="measure-style" type="measure-style" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>A measure-style indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="measure-style">
         <xs:annotation>
         <xs:documentation>A measure-style indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.
         
         The multiple-rest and measure-repeat symbols indicate the number of measures covered in the element content. The beat-repeat and slash elements can cover partial measures. All but the multiple-rest element use a type attribute to indicate starting and stopping the use of the style. The optional number attribute specifies the staff number from top to bottom on the system, as with clef.</xs:documentation>
         </xs:annotation>
         <xs:choice>
         <xs:element name="multiple-rest" type="multiple-rest"/>
         <xs:element name="measure-repeat" type="measure-repeat"/>
         <xs:element name="beat-repeat" type="beat-repeat"/>
         <xs:element name="slash" type="slash"/>
         </xs:choice>
         <xs:attribute name="number" type="staff-number"/>
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         </xs:complexType>         */
        
        class MeasureStyleChoice;
        using MeasureStyleChoicePtr = std::shared_ptr<MeasureStyleChoice>;
        using MeasureStyleChoiceUPtr = std::unique_ptr<MeasureStyleChoice>;
        using MeasureStyleChoiceSet = std::vector<MeasureStyleChoicePtr>;
        using MeasureStyleChoiceSetIter = MeasureStyleChoiceSet::iterator;
        using MeasureStyleChoiceSetIterConst = MeasureStyleChoiceSet::const_iterator;
        inline MeasureStyleChoicePtr makeMeasureStyleChoice() { return std::make_shared<MeasureStyleChoice>(); }
        class MeasureStyleChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                multipleRest = 0,
                measureRepeat = 1,
                beatRepeat = 2,
                slash = 3
            };
            MeasureStyleChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            Choice getChoice() const;
            void setChoice( const Choice value );
            MultipleRestPtr getMultipleRest() const;
            void setMultipleRest( const MultipleRestPtr& value );
            MeasureRepeatPtr getMeasureRepeat() const;
            void setMeasureRepeat( const MeasureRepeatPtr& value );
            BeatRepeatPtr getBeatRepeat() const;
            void setBeatRepeat( const BeatRepeatPtr& value );
            SlashPtr getSlash() const;
            void setSlash( const SlashPtr& value );
        private:
            Choice myChoice;
            MultipleRestPtr myMultipleRest;
            MeasureRepeatPtr myMeasureRepeat;
            BeatRepeatPtr myBeatRepeat;
            SlashPtr mySlash;
        };
        
        struct MeasureStyleAttributes;
        using MeasureStyleAttributesPtr = std::shared_ptr<MeasureStyleAttributes>;
        
        struct MeasureStyleAttributes : public AttributesInterface
        {
        public:
            MeasureStyleAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StaffNumber number;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            bool hasNumber;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
        };
        
        class MeasureStyle;
        using MeasureStylePtr = std::shared_ptr<MeasureStyle>;
        using MeasureStyleUPtr = std::unique_ptr<MeasureStyle>;
        using MeasureStyleSet = std::vector<MeasureStylePtr>;
        using MeasureStyleSetIter = MeasureStyleSet::iterator;
        using MeasureStyleSetIterConst = MeasureStyleSet::const_iterator;
        inline MeasureStylePtr makeMeasureStyle() { return std::make_shared<MeasureStyle>(); }
        class MeasureStyle : public ElementInterface
        {
        public:
            MeasureStyle();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MeasureStyleAttributesPtr getAttributes() const;
            void setAttributes( const MeasureStyleAttributesPtr& value );
            MeasureStyleChoicePtr getMeasureStyleChoice() const;
            void setMeasureStyleChoice( const MeasureStyleChoicePtr& value );
        private:
            MeasureStyleAttributesPtr myAttributes;
            MeasureStyleChoicePtr myChoice;
        };
        
        /*
         2953
         <!--  ID = 2953 [2953] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- RecursiveSubElementCount = 3 -->
         <xs:element name="interchangeable" type="interchangeable" minOccurs="0"/>
         <xs:complexType name="interchangeable">
         <xs:annotation>
         <xs:documentation>The interchangeable type is used to represent the second in a pair of interchangeable dual time signatures, such as the 6/8 in 3/4 (6/8). A separate symbol attribute value is available compared to the time element's symbol attribute, which applies to the first of the dual time signatures. The parentheses attribute value is yes by default.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="time-relation" type="time-relation" minOccurs="0"/>
         <xs:group ref="time-signature" maxOccurs="unbounded"/>
         </xs:sequence>
         <xs:attribute name="symbol" type="time-symbol"/>
         <xs:attribute name="separator" type="time-separator"/>
         </xs:complexType>
         <xs:group name="time-signature">
         <xs:annotation>
         <xs:documentation>Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="beats" type="xs:string">
         <xs:annotation>
         <xs:documentation>The beats element indicates the number of beats, as found in the numerator of a time signature.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="beat-type" type="xs:string">
         <xs:annotation>
         <xs:documentation>The beat-type element indicates the beat unit, as found in the denominator of a time signature.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         */
        
        struct InterchangeableAttributes;
        using InterchangeableAttributesPtr = std::shared_ptr<InterchangeableAttributes>;
        
        struct InterchangeableAttributes : public AttributesInterface
        {
        public:
            InterchangeableAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TimeSymbol symbol;
            t::TimeSeparator separator;
            bool hasSymbol;
            bool hasSeparator;
        };
        
        class Interchangeable;
        using InterchangeablePtr = std::shared_ptr<Interchangeable>;
        using InterchangeableUPtr = std::unique_ptr<Interchangeable>;
        using InterchangeableSet = std::vector<InterchangeablePtr>;
        using InterchangeableSetIter = InterchangeableSet::iterator;
        using InterchangeableSetIterConst = InterchangeableSet::const_iterator;
        inline InterchangeablePtr makeInterchangeable() { return std::make_shared<Interchangeable>(); }
        class Interchangeable : public ElementInterface
        {
        public:
            Interchangeable();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            InterchangeableAttributesPtr getAttributes() const;
            void setAttributes( const InterchangeableAttributesPtr& value );
            /* _________ TimeRelation minOccurs = 0, maxOccurs = 1 _________ */
            TimeRelationPtr getTimeRelation() const;
            void setTimeRelation( const TimeRelationPtr& value );
            bool getHasTimeRelation() const;
            void setHasTimeRelation( const bool value );
            /* _________ Beats minOccurs = 1, maxOccurs = 1 _________ */
            BeatsPtr getBeats() const;
            void setBeats( const BeatsPtr& value );
            /* _________ BeatType minOccurs = 1, maxOccurs = 1 _________ */
            BeatTypePtr getBeatType() const;
            void setBeatType( const BeatTypePtr& value );
        private:
            InterchangeableAttributesPtr myAttributes;
            TimeRelationPtr myTimeRelation;
            bool myHasTimeRelation;
            BeatsPtr myBeats;
            BeatTypePtr myBeatType;
        };
        /*
         3403<!--  ID = 3403 [3403] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- RecursiveSubElementCount = 3 -->
         <xs:element name="accordion-registration" type="accordion-registration"/>
         <xs:complexType name="accordion-registration">
         <xs:annotation>
         <xs:documentation>The accordion-registration type is use for accordion registration symbols. These are circular symbols divided horizontally into high, middle, and low sections that correspond to 4', 8', and 16' pipes. Each accordion-high, accordion-middle, and accordion-low element represents the presence of one or more dots in the registration diagram. An accordion-registration element needs to have at least one of the child elements present.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="accordion-high" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The accordion-high element indicates the presence of a dot in the high (4') section of the registration symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="accordion-middle" type="accordion-middle" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The accordion-middle element indicates the presence of 1 to 3 dots in the middle (8') section of the registration symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="accordion-low" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The accordion-low element indicates the presence of a dot in the low (16') section of the registration symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        
        struct AccordionRegistrationAttributes;
        using AccordionRegistrationAttributesPtr = std::shared_ptr<AccordionRegistrationAttributes>;
        
        struct AccordionRegistrationAttributes : public AttributesInterface
        {
        public:
            AccordionRegistrationAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::LeftCenterRight halign;
            t::Valign valign;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasHalign;
            bool hasValign;
        };
        
        class AccordionRegistration;
        using AccordionRegistrationPtr = std::shared_ptr<AccordionRegistration>;
        using AccordionRegistrationUPtr = std::unique_ptr<AccordionRegistration>;
        using AccordionRegistrationSet = std::vector<AccordionRegistrationPtr>;
        using AccordionRegistrationSetIter = AccordionRegistrationSet::iterator;
        using AccordionRegistrationSetIterConst = AccordionRegistrationSet::const_iterator;
        inline AccordionRegistrationPtr makeAccordionRegistration() { return std::make_shared<AccordionRegistration>(); }
        class AccordionRegistration : public ElementInterface
        {
        public:
            AccordionRegistration();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            AccordionRegistrationAttributesPtr getAttributes() const;
            void setAttributes( const AccordionRegistrationAttributesPtr& value );
            /* _________ AccordionHigh minOccurs = 0, maxOccurs = 1 _________ */
            AccordionHighPtr getAccordionHigh() const;
            void setAccordionHigh( const AccordionHighPtr& value );
            bool getHasAccordionHigh() const;
            void setHasAccordionHigh( const bool value );
            /* _________ AccordionMiddle minOccurs = 0, maxOccurs = 1 _________ */
            AccordionMiddlePtr getAccordionMiddle() const;
            void setAccordionMiddle( const AccordionMiddlePtr& value );
            bool getHasAccordionMiddle() const;
            void setHasAccordionMiddle( const bool value );
            /* _________ AccordionLow minOccurs = 0, maxOccurs = 1 _________ */
            AccordionLowPtr getAccordionLow() const;
            void setAccordionLow( const AccordionLowPtr& value );
            bool getHasAccordionLow() const;
            void setHasAccordionLow( const bool value );
        private:
            AccordionRegistrationAttributesPtr myAttributes;
            AccordionHighPtr myAccordionHigh;
            bool myHasAccordionHigh;
            AccordionMiddlePtr myAccordionMiddle;
            bool myHasAccordionMiddle;
            AccordionLowPtr myAccordionLow;
            bool myHasAccordionLow;
        };
        
        /*
         2621
         <!--  ID = 2621 [2621] ------------------------->
         <!-- min=0 max=4294967295 ZeroOrMany  -->
         <!-- RecursiveSubElementCount = 7 -->
         <xs:element name="time" type="time" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="time">
         <xs:annotation>
         <xs:documentation>Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator. The symbol attribute is used indicate common and cut time symbols as well as a single number display. Multiple pairs of beat and beat-type elements are used for composite time signatures with multiple denominators, such as 2/4 + 3/8. A composite such as 3+2/8 requires only one beat/beat-type pair.
         
         The print-object attribute allows a time signature to be specified but not printed, as is the case for excerpts from the middle of a score. The value is "yes" if not present. The optional number attribute refers to staff numbers within the part. If absent, the time signature applies to all staves in the part.</xs:documentation>
         </xs:annotation>
         <xs:choice>
         <xs:sequence>
         <xs:group ref="time-signature" maxOccurs="unbounded"/>
         <xs:element name="interchangeable" type="interchangeable" minOccurs="0"/>
         </xs:sequence>
         <xs:element name="senza-misura" type="xs:string">
         <xs:annotation>
         <xs:documentation>A senza-misura element explicitly indicates that no time signature is present. The optional element content indicates the symbol to be used, if any, such as an X. The time element's symbol attribute is not used when a senza-misura element is present.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:choice>
         <xs:attribute name="number" type="staff-number"/>
         <xs:attribute name="symbol" type="time-symbol"/>
         <xs:attribute name="separator" type="time-separator"/>
         <xs:attributeGroup ref="print-style-align"/>
         <xs:attributeGroup ref="print-object"/>
         </xs:complexType>
         <xs:group name="time-signature">
         <xs:annotation>
         <xs:documentation>Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="beats" type="xs:string">
         <xs:annotation>
         <xs:documentation>The beats element indicates the number of beats, as found in the numerator of a time signature.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="beat-type" type="xs:string">
         <xs:annotation>
         <xs:documentation>The beat-type element indicates the beat unit, as found in the denominator of a time signature.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         */
        class TimeSignature;
        using TimeSignaturePtr = std::shared_ptr<TimeSignature>;
        using TimeSignatureUPtr = std::unique_ptr<TimeSignature>;
        using TimeSignatureSet = std::vector<TimeSignaturePtr>;
        using TimeSignatureSetIter = TimeSignatureSet::iterator;
        using TimeSignatureSetIterConst = TimeSignatureSet::const_iterator;
        inline TimeSignaturePtr makeTimeSignature() { return std::make_shared<TimeSignature>(); }
        class TimeSignature : public ElementInterface
        {
        public:
            TimeSignature();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BeatsPtr getBeats() const;
            void setBeats( const BeatsPtr& value );
            BeatTypePtr getBeatType() const;
            void setBeatType( const BeatTypePtr& value );
            InterchangeablePtr getInterchangeable() const;
            void setInterchangeable( const InterchangeablePtr& value );
            bool getHasInterchangeable() const;
            void setHasInterchangeable( const bool value );
        private:
            BeatsPtr myBeats;
            BeatTypePtr myBeatType;
            InterchangeablePtr myInterchangeable;
            bool myHasInterchangeable;
        };
        
        class TimeChoice;
        using TimeChoicePtr = std::shared_ptr<TimeChoice>;
        using TimeChoiceUPtr = std::unique_ptr<TimeChoice>;
        using TimeChoiceSet = std::vector<TimeChoicePtr>;
        using TimeChoiceSetIter = TimeChoiceSet::iterator;
        using TimeChoiceSetIterConst = TimeChoiceSet::const_iterator;
        inline TimeChoicePtr makeTimeChoice() { return std::make_shared<TimeChoice>(); }
        class TimeChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                timeSignature = 0,
                senzaMisura = 1
            };
            TimeChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            Choice getChoice() const;
            void setChoice( const Choice value );
            TimeSignaturePtr getTimeSignature() const;
            void setTimeSignature( const TimeSignaturePtr& value );
            SenzaMisuraPtr getSenzaMisura() const;
            void setSenzaMisura( const SenzaMisuraPtr& value );
        private:
            Choice myChoice;
            TimeSignaturePtr myTimeSignature;
            SenzaMisuraPtr mySenzaMisura;
        };
        
        struct TimeAttributes;
        using TimeAttributesPtr = std::shared_ptr<TimeAttributes>;
        
        struct TimeAttributes : public AttributesInterface
        {
        public:
            TimeAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StaffNumber number;
            t::TimeSymbol symbol;
            t::TimeSeparator separator;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::LeftCenterRight halign;
            t::Valign valign;
            t::YesNo printObject;
            bool hasNumber;
            bool hasSymbol;
            bool hasSeparator;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasHalign;
            bool hasValign;
            bool hasPrintObject;
        };
        
        class Time;
        using TimePtr = std::shared_ptr<Time>;
        using TimeUPtr = std::unique_ptr<Time>;
        using TimeSet = std::vector<TimePtr>;
        using TimeSetIter = TimeSet::iterator;
        using TimeSetIterConst = TimeSet::const_iterator;
        inline TimePtr makeTime() { return std::make_shared<Time>(); }
        class Time : public ElementInterface
        {
        public:
            Time();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TimeAttributesPtr getAttributes() const;
            void setAttributes( const TimeAttributesPtr& value );
            TimeChoicePtr getTimeChoice() const;
            void setTimeChoice( const TimeChoicePtr& value );
        private:
            TimeAttributesPtr myAttributes;
            TimeChoicePtr myChoice;
        };
        /*
         3481 [ equivalents 3481, 5393 ]
         <!--  ID = 3481 [3481, 5393] ------------------------->
         <xs:element name="string" type="string"/>
         <xs:complexType name="string">
         <xs:annotation>
         <xs:documentation>The string type is used with tablature notation, regular notation (where it is often circled), and chord diagrams. String numbers start with 1 for the highest string.</xs:documentation>
         </xs:annotation>
         <xs:simpleContent>
         <xs:extension base="string-number">
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         */
        
        struct StringAttributes;
        using StringAttributesPtr = std::shared_ptr<StringAttributes>;
        
        struct StringAttributes : public AttributesInterface
        {
        public:
            StringAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasPlacement;
        };
        
        class String;
        using StringPtr = std::shared_ptr<String>;
        using StringUPtr = std::unique_ptr<String>;
        using StringSet = std::vector<StringPtr>;
        using StringSetIter = StringSet::iterator;
        using StringSetIterConst = StringSet::const_iterator;
        inline StringPtr makeString() { return std::make_shared<String>(); }
        inline StringPtr makeString( const t::StringNumber& value ) { return std::make_shared<String>( value ); }
		inline StringPtr makeString( t::StringNumber&& value ) { return std::make_shared<String>( std::move( value ) ); }
        
        class String : public ElementInterface
        {
        public:
            String();
            String( const t::StringNumber& value );
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            StringAttributesPtr getAttributes() const;
            void setAttributes( const StringAttributesPtr& value );
            t::StringNumber getValue() const;
            void setValue( const t::StringNumber& value );
        private:
            StringAttributesPtr myAttributes;
            t::StringNumber myValue;
        };
        /*
         3455
         <!--  ID = 3455 [3455] ------------------------->
         <!-- min=1 max=4294967295 OneOrMMany  -->
         <!-- RecursiveSubElementCount = 4 -->
         <xs:element name="frame-note" type="frame-note" maxOccurs="unbounded"/>
         <xs:complexType name="frame-note">
         <xs:annotation>
         <xs:documentation>The frame-note type represents each note included in the frame. An open string will have a fret value of 0, while a muted string will not be associated with a frame-note element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="string" type="string"/>
         <xs:element name="fret" type="fret"/>
         <xs:element name="fingering" type="fingering" minOccurs="0"/>
         <xs:element name="barre" type="barre" minOccurs="0"/>
         </xs:sequence>
         </xs:complexType>
         */
        
        class FrameNote;
        using FrameNotePtr = std::shared_ptr<FrameNote>;
        using FrameNoteUPtr = std::unique_ptr<FrameNote>;
        using FrameNoteSet = std::vector<FrameNotePtr>;
        using FrameNoteSetIter = FrameNoteSet::iterator;
        using FrameNoteSetIterConst = FrameNoteSet::const_iterator;
        inline FrameNotePtr makeFrameNote() { return std::make_shared<FrameNote>(); }
        class FrameNote : public ElementInterface
        {
        public:
            FrameNote();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ String minOccurs = 1, maxOccurs = 1 _________ */
            StringPtr getString() const;
            void setString( const StringPtr& value );
            /* _________ Fret minOccurs = 1, maxOccurs = 1 _________ */
            FretPtr getFret() const;
            void setFret( const FretPtr& value );
            /* _________ Fingering minOccurs = 0, maxOccurs = 1 _________ */
            FingeringPtr getFingering() const;
            void setFingering( const FingeringPtr& value );
            bool getHasFingering() const;
            void setHasFingering( const bool value );
            /* _________ Barre minOccurs = 0, maxOccurs = 1 _________ */
            BarrePtr getBarre() const;
            void setBarre( const BarrePtr& value );
            bool getHasBarre() const;
            void setHasBarre( const bool value );
        private:
            StringPtr myString;
            FretPtr myFret;
            FingeringPtr myFingering;
            bool myHasFingering;
            BarrePtr myBarre;
            bool myHasBarre;
        };
        /*
         3524
         <!--  ID = 3524 [3524] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- RecursiveSubElementCount = 8 -->
         <xs:element name="frame" type="frame" minOccurs="0"/>
         <xs:complexType name="frame">
         <xs:annotation>
         <xs:documentation>The frame type represents a frame or fretboard diagram used together with a chord symbol. The representation is based on the NIFF guitar grid with additional information. The frame type's unplayed attribute indicates what to display above a string that has no associated frame-note element. Typical values are x and the empty string. If the attribute is not present, the display of the unplayed string is application-defined.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="frame-strings" type="xs:positiveInteger">
         <xs:annotation>
         <xs:documentation>The frame-strings element gives the overall size of the frame in vertical lines (strings).</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="frame-frets" type="xs:positiveInteger">
         <xs:annotation>
         <xs:documentation>The frame-frets element gives the overall size of the frame in horizontal spaces (frets).</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="first-fret" type="first-fret" minOccurs="0"/>
         <xs:element name="frame-note" type="frame-note" maxOccurs="unbounded"/>
         </xs:sequence>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="color"/>
         <xs:attributeGroup ref="halign"/>
         <xs:attributeGroup ref="valign-image"/>
         <xs:attribute name="height" type="tenths"/>
         <xs:attribute name="width" type="tenths"/>
         <xs:attribute name="unplayed" type="xs:token"/>
         </xs:complexType>
         */
        
        struct FrameAttributes;
        using FrameAttributesPtr = std::shared_ptr<FrameAttributes>;
        
        struct FrameAttributes : public AttributesInterface
        {
        public:
            FrameAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::Color color;
            t::LeftCenterRight halign;
            t::ValignImage valign;
            t::TenthsValue height;
            t::TenthsValue width;
            t::XsToken unplayed;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasColor;
            bool hasHalign;
            bool hasValign;
            bool hasHeight;
            bool hasWidth;
            bool hasUnplayed;
        };
        
        class Frame;
        using FramePtr = std::shared_ptr<Frame>;
        using FrameUPtr = std::unique_ptr<Frame>;
        using FrameSet = std::vector<FramePtr>;
        using FrameSetIter = FrameSet::iterator;
        using FrameSetIterConst = FrameSet::const_iterator;
        inline FramePtr makeFrame() { return std::make_shared<Frame>(); }
        class Frame : public ElementInterface
        {
        public:
            Frame();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            FrameAttributesPtr getAttributes() const;
            void setAttributes( const FrameAttributesPtr& value );
            /* _________ FrameStrings minOccurs = 1, maxOccurs = 1 _________ */
            FrameStringsPtr getFrameStrings() const;
            void setFrameStrings( const FrameStringsPtr& value );
            /* _________ FrameFrets minOccurs = 1, maxOccurs = 1 _________ */
            FrameFretsPtr getFrameFrets() const;
            void setFrameFrets( const FrameFretsPtr& value );
            /* _________ FirstFret minOccurs = 0, maxOccurs = 1 _________ */
            FirstFretPtr getFirstFret() const;
            void setFirstFret( const FirstFretPtr& value );
            bool getHasFirstFret() const;
            void setHasFirstFret( const bool value );
            /* _________ FrameNote minOccurs = 1, maxOccurs = unbounded _________ */
            const FrameNoteSet& getFrameNoteSet() const;
            void addFrameNote( const FrameNotePtr& value );
            void removeFrameNote( const FrameNoteSetIterConst& value );
            void clearFrameNoteSet();
            FrameNotePtr getFrameNote( const FrameNoteSetIterConst& setIterator ) const;
        private:
            FrameAttributesPtr myAttributes;
            FrameStringsPtr myFrameStrings;
            FrameFretsPtr myFrameFrets;
            FirstFretPtr myFirstFret;
            bool myHasFirstFret;
            FrameNoteSet myFrameNoteSet;
        };
        /*
         3554
         <!--  ID = 3554 [3554] ------------------------->
         <!-- min=1 max=4294967295 OneOrMMany  -->
         <!-- RecursiveSubElementCount = 2 -->
         <xs:element name="pedal-tuning" type="pedal-tuning" maxOccurs="unbounded"/>
         <xs:complexType name="pedal-tuning">
         <xs:annotation>
         <xs:documentation>The pedal-tuning type specifies the tuning of a single harp pedal.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="pedal-step" type="step">
         <xs:annotation>
         <xs:documentation>The pedal-step element defines the pitch step for a single harp pedal.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="pedal-alter" type="semitones">
         <xs:annotation>
         <xs:documentation>The pedal-alter element defines the chromatic alteration for a single harp pedal.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:complexType>
         */
        
        class PedalTuning;
        using PedalTuningPtr = std::shared_ptr<PedalTuning>;
        using PedalTuningUPtr = std::unique_ptr<PedalTuning>;
        using PedalTuningSet = std::vector<PedalTuningPtr>;
        using PedalTuningSetIter = PedalTuningSet::iterator;
        using PedalTuningSetIterConst = PedalTuningSet::const_iterator;
        inline PedalTuningPtr makePedalTuning() { return std::make_shared<PedalTuning>(); }
        class PedalTuning : public ElementInterface
        {
        public:
            PedalTuning();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ PedalStep minOccurs = 1, maxOccurs = 1 _________ */
            PedalStepPtr getPedalStep() const;
            void setPedalStep( const PedalStepPtr& value );
            /* _________ PedalAlter minOccurs = 1, maxOccurs = 1 _________ */
            PedalAlterPtr getPedalAlter() const;
            void setPedalAlter( const PedalAlterPtr& value );
        private:
            PedalStepPtr myPedalStep;
            PedalAlterPtr myPedalAlter;
        };
        /*
         3373
         <!--  ID = 3373 [3373] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- RecursiveSubElementCount = 3 -->
         <xs:element name="harp-pedals" type="harp-pedals"/>
         <xs:complexType name="harp-pedals">
         <xs:annotation>
         <xs:documentation>The harp-pedals type is used to create harp pedal diagrams. The pedal-step and pedal-alter elements use the same values as the step and alter elements. For easiest reading, the pedal-tuning elements should follow standard harp pedal order, with pedal-step values of D, C, B, E, F, G, and A.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="pedal-tuning" type="pedal-tuning" maxOccurs="unbounded"/>
         </xs:sequence>
         <xs:attributeGroup ref="print-style-align"/>
         </xs:complexType>
         */
        struct HarpPedalsAttributes;
        using HarpPedalsAttributesPtr = std::shared_ptr<HarpPedalsAttributes>;
        
        struct HarpPedalsAttributes : public AttributesInterface
        {
        public:
            HarpPedalsAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::LeftCenterRight halign;
            t::Valign valign;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasHalign;
            bool hasValign;
        };
        
        class HarpPedals;
        using HarpPedalsPtr = std::shared_ptr<HarpPedals>;
        using HarpPedalsUPtr = std::unique_ptr<HarpPedals>;
        using HarpPedalsSet = std::vector<HarpPedalsPtr>;
        using HarpPedalsSetIter = HarpPedalsSet::iterator;
        using HarpPedalsSetIterConst = HarpPedalsSet::const_iterator;
        inline HarpPedalsPtr makeHarpPedals() { return std::make_shared<HarpPedals>(); }
        class HarpPedals : public ElementInterface
        {
        public:
            HarpPedals();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            HarpPedalsAttributesPtr getAttributes() const;
            void setAttributes( const HarpPedalsAttributesPtr& value );
            /* _________ PedalTuning minOccurs = 1, maxOccurs = unbounded _________ */
            const PedalTuningSet& getPedalTuningSet() const;
            void addPedalTuning( const PedalTuningPtr& value );
            void removePedalTuning( const PedalTuningSetIterConst& value );
            void clearPedalTuningSet();
            PedalTuningPtr getPedalTuning( const PedalTuningSetIterConst& setIterator ) const;
        private:
            HarpPedalsAttributesPtr myAttributes;
            PedalTuningSet myPedalTuningSet;
        };
        /*
         3682
         
         
         <!--  ID = 3682 [3682] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 4 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="metronome-tuplet" type="metronome-tuplet" minOccurs="0"/>
         <xs:complexType name="metronome-tuplet">
         <xs:annotation>
         <xs:documentation>The metronome-tuplet type uses the same element structure as the time-modification element along with some attributes from the tuplet element.</xs:documentation>
         </xs:annotation>
         <xs:complexContent>
         <xs:extension base="time-modification">
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="bracket" type="yes-no"/>
         <xs:attribute name="show-number" type="show-tuplet"/>
         </xs:extension>
         </xs:complexContent>
         </xs:complexType>
         <xs:complexType name="time-modification">
         <xs:annotation>
         <xs:documentation>Time modification indicates tuplets, double-note tremolos, and other durational changes. A time-modification element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note type represented by the type and dot elements. Nested tuplets and other notations that use more detailed information need both the time-modification and tuplet elements to be represented accurately.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="actual-notes" type="xs:nonNegativeInteger">
         <xs:annotation>
         <xs:documentation>The actual-notes element describes how many notes are played in the time usually occupied by the number in the normal-notes element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="normal-notes" type="xs:nonNegativeInteger">
         <xs:annotation>
         <xs:documentation>The normal-notes element describes how many notes are usually played in the time occupied by the number in the actual-notes element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:sequence minOccurs="0">
         <xs:element name="normal-type" type="note-type-value">
         <xs:annotation>
         <xs:documentation>If the type associated with the number in the normal-notes element is different than the current note type (e.g., a quarter note within an eighth note triplet), then the normal-notes type (e.g. eighth) is specified in the normal-type and normal-dot elements.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="normal-dot" type="empty" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The normal-dot element is used to specify dotted normal tuplet types.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:sequence>
         </xs:complexType>
         */
        
        
        
        class TimeModificationNormalTypeNormalDot;
        using TimeModificationNormalTypeNormalDotPtr = std::shared_ptr<TimeModificationNormalTypeNormalDot>;
        using TimeModificationNormalTypeNormalDotUPtr = std::unique_ptr<TimeModificationNormalTypeNormalDot>;
        using TimeModificationNormalTypeNormalDotSet = std::vector<TimeModificationNormalTypeNormalDotPtr>;
        using TimeModificationNormalTypeNormalDotSetIter = TimeModificationNormalTypeNormalDotSet::iterator;
        using TimeModificationNormalTypeNormalDotSetIterConst = TimeModificationNormalTypeNormalDotSet::const_iterator;
        inline TimeModificationNormalTypeNormalDotPtr makeTimeModificationNormalTypeNormalDot() { return std::make_shared<TimeModificationNormalTypeNormalDot>(); }
        class TimeModificationNormalTypeNormalDot : public ElementInterface
        {
        public:
            TimeModificationNormalTypeNormalDot();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ NormalType minOccurs = 1, maxOccurs = 1 _________ */
            NormalTypePtr getNormalType() const;
            void setNormalType( const NormalTypePtr& value );
            /* _________ NormalDot minOccurs = 0, maxOccurs = unbounded _________ */
            const NormalDotSet& getNormalDotSet() const;
            void addNormalDot( const NormalDotPtr& value );
            void removeNormalDot( const NormalDotSetIterConst& value );
            void clearNormalDotSet();
            NormalDotPtr getNormalDot( const NormalDotSetIterConst& setIterator ) const;
        private:
            NormalTypePtr myNormalType;
            NormalDotSet myNormalDotSet;
        };
        
        struct MetronomeTupletAttributes;
        using MetronomeTupletAttributesPtr = std::shared_ptr<MetronomeTupletAttributes>;
        
        struct MetronomeTupletAttributes : public AttributesInterface
        {
        public:
            MetronomeTupletAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            t::YesNo bracket;
            t::ShowTuplet showNumber;
            const 	bool hasType;
            bool hasBracket;
            bool hasShowNumber;
        };
        
        class MetronomeTuplet;
        using MetronomeTupletPtr = std::shared_ptr<MetronomeTuplet>;
        using MetronomeTupletUPtr = std::unique_ptr<MetronomeTuplet>;
        using MetronomeTupletSet = std::vector<MetronomeTupletPtr>;
        using MetronomeTupletSetIter = MetronomeTupletSet::iterator;
        using MetronomeTupletSetIterConst = MetronomeTupletSet::const_iterator;
        inline MetronomeTupletPtr makeMetronomeTuplet() { return std::make_shared<MetronomeTuplet>(); }
        
        class MetronomeTuplet : public ElementInterface
        {
        public:
            MetronomeTuplet();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MetronomeTupletAttributesPtr getAttributes() const;
            void setAttributes( const MetronomeTupletAttributesPtr& value );
            /* _________ ActualNotes minOccurs = 1, maxOccurs = 1 _________ */
            ActualNotesPtr getActualNotes() const;
            void setActualNotes( const ActualNotesPtr& value );
            /* _________ NormalNotes minOccurs = 1, maxOccurs = 1 _________ */
            NormalNotesPtr getNormalNotes() const;
            void setNormalNotes( const NormalNotesPtr& value );
            /* _________ TimeModificationNormalTypeNormalDot minOccurs = 0, maxOccurs = 1 _________ */
            TimeModificationNormalTypeNormalDotPtr getTimeModificationNormalTypeNormalDot() const;
            void setTimeModificationNormalTypeNormalDot( const TimeModificationNormalTypeNormalDotPtr& value );
            bool getHasTimeModificationNormalTypeNormalDot() const;
            void setHasTimeModificationNormalTypeNormalDot( const bool value );
        private:
            MetronomeTupletAttributesPtr myAttributes;
            ActualNotesPtr myActualNotes;
            NormalNotesPtr myNormalNotes;
            TimeModificationNormalTypeNormalDotPtr myTimeModificationNormalTypeNormalDot;
            bool myHasTimeModificationNormalTypeNormalDot;
        };
        /*
         3627 [ equivalents 3627, 3638 ]
         <!--  ID = 3627 [3627, 3638] ------------------------->
         <!-- min=1 max=4294967295 OneOrMMany  -->
         <xs:element name="metronome-note" type="metronome-note" maxOccurs="unbounded"/>
         <xs:complexType name="metronome-note">
         <xs:annotation>
         <xs:documentation>The metronome-note type defines the appearance of a note within a metric relationship mark.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="metronome-type" type="note-type-value">
         <xs:annotation>
         <xs:documentation>The metronome-type element works like the type element in defining metric relationships.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="metronome-dot" type="empty" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The metronome-dot element works like the dot element in defining metric relationships.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="metronome-beam" type="metronome-beam" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="metronome-tuplet" type="metronome-tuplet" minOccurs="0"/>
         </xs:sequence>
         </xs:complexType>
         */
        
        class MetronomeNote;
        using MetronomeNotePtr = std::shared_ptr<MetronomeNote>;
        using MetronomeNoteUPtr = std::unique_ptr<MetronomeNote>;
        using MetronomeNoteSet = std::vector<MetronomeNotePtr>;
        using MetronomeNoteSetIter = MetronomeNoteSet::iterator;
        using MetronomeNoteSetIterConst = MetronomeNoteSet::const_iterator;
        inline MetronomeNotePtr makeMetronomeNote() { return std::make_shared<MetronomeNote>(); }
        class MetronomeNote : public ElementInterface
        {
        public:
            MetronomeNote();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ MetronomeType minOccurs = 1, maxOccurs = 1 _________ */
            MetronomeTypePtr getMetronomeType() const;
            void setMetronomeType( const MetronomeTypePtr& value );
            /* _________ MetronomeDot minOccurs = 0, maxOccurs = unbounded _________ */
            const MetronomeDotSet& getMetronomeDotSet() const;
            void addMetronomeDot( const MetronomeDotPtr& value );
            void removeMetronomeDot( const MetronomeDotSetIterConst& value );
            void clearMetronomeDotSet();
            MetronomeDotPtr getMetronomeDot( const MetronomeDotSetIterConst& setIterator ) const;
            /* _________ MetronomeBeam minOccurs = 0, maxOccurs = unbounded _________ */
            const MetronomeBeamSet& getMetronomeBeamSet() const;
            void addMetronomeBeam( const MetronomeBeamPtr& value );
            void removeMetronomeBeam( const MetronomeBeamSetIterConst& value );
            void clearMetronomeBeamSet();
            MetronomeBeamPtr getMetronomeBeam( const MetronomeBeamSetIterConst& setIterator ) const;
            /* _________ MetronomeTuplet minOccurs = 0, maxOccurs = 1 _________ */
            MetronomeTupletPtr getMetronomeTuplet() const;
            void setMetronomeTuplet( const MetronomeTupletPtr& value );
            bool getHasMetronomeTuplet() const;
            void setHasMetronomeTuplet( const bool value );
        private:
            MetronomeTypePtr myMetronomeType;
            MetronomeDotSet myMetronomeDotSet;
            MetronomeBeamSet myMetronomeBeamSet;
            MetronomeTupletPtr myMetronomeTuplet;
            bool myHasMetronomeTuplet;
        };
        
        class BeatUnitGroup;
        using BeatUnitGroupPtr = std::shared_ptr<BeatUnitGroup>;
        using BeatUnitGroupUPtr = std::unique_ptr<BeatUnitGroup>;
        using BeatUnitGroupSet = std::vector<BeatUnitGroupPtr>;
        using BeatUnitGroupSetIter = BeatUnitGroupSet::iterator;
        using BeatUnitGroupSetIterConst = BeatUnitGroupSet::const_iterator;
        inline BeatUnitGroupPtr makeBeatUnitGroup() { return std::make_shared<BeatUnitGroup>(); }
        class BeatUnitGroup : public ElementInterface
        {
        public:
            BeatUnitGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ BeatUnit minOccurs = 1, maxOccurs = 1 _________ */
            BeatUnitPtr getBeatUnit() const;
            void setBeatUnit( const BeatUnitPtr& value );
            /* _________ BeatUnitDot minOccurs = 0, maxOccurs = unbounded _________ */
            const BeatUnitDotSet& getBeatUnitDotSet() const;
            void addBeatUnitDot( const BeatUnitDotPtr& value );
            void removeBeatUnitDot( const BeatUnitDotSetIterConst& setIterator );
            void clearBeatUnitDotSet();
        private:
            BeatUnitPtr myBeatUnit;
            BeatUnitDotSet myBeatUnitDotSet;
        };
        
        class MetronomeRelationGroup;
        using MetronomeRelationGroupPtr = std::shared_ptr<MetronomeRelationGroup>;
        using MetronomeRelationGroupUPtr = std::unique_ptr<MetronomeRelationGroup>;
        using MetronomeRelationGroupSet = std::vector<MetronomeRelationGroupPtr>;
        using MetronomeRelationGroupSetIter = MetronomeRelationGroupSet::iterator;
        using MetronomeRelationGroupSetIterConst = MetronomeRelationGroupSet::const_iterator;
        inline MetronomeRelationGroupPtr makeMetronomeRelationGroup() { return std::make_shared<MetronomeRelationGroup>(); }
        class MetronomeRelationGroup : public ElementInterface
        {
        public:
            MetronomeRelationGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ MetronomeRelation minOccurs = 1, maxOccurs = 1 _________ */
            MetronomeRelationPtr getMetronomeRelation() const;
            void setMetronomeRelation( const MetronomeRelationPtr& value );
            /* _________ MetronomeNote minOccurs = 1, maxOccurs = 1 _________ */
            MetronomeNotePtr getMetronomeNote() const;
            void setMetronomeNote( const MetronomeNotePtr& value );
        private:
            MetronomeRelationPtr myMetronomeRelation;
            MetronomeNotePtr myMetronomeNote;
        };
        
        class NoteRelationNote;
        using NoteRelationNotePtr = std::shared_ptr<NoteRelationNote>;
        using NoteRelationNoteUPtr = std::unique_ptr<NoteRelationNote>;
        using NoteRelationNoteSet = std::vector<NoteRelationNotePtr>;
        using NoteRelationNoteSetIter = NoteRelationNoteSet::iterator;
        using NoteRelationNoteSetIterConst = NoteRelationNoteSet::const_iterator;
        inline NoteRelationNotePtr makeNoteRelationNote() { return std::make_shared<NoteRelationNote>(); }
        class NoteRelationNote : public ElementInterface
        {
        public:
            NoteRelationNote();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ MetronomeNote minOccurs = 1, maxOccurs = unbounded _________ */
            const MetronomeNoteSet& getMetronomeNoteSet() const;
            void addMetronomeNote( const MetronomeNotePtr& value );
            void removeMetronomeNote( const MetronomeNoteSetIterConst& setIterator );
            void clearMetronomeNoteSet();
            /* _________ MetronomeRelationGroup minOccurs = 0, maxOccurs = 1 _________ */
            MetronomeRelationGroupPtr getMetronomeRelationGroup() const;
            void setMetronomeRelationGroup( const MetronomeRelationGroupPtr& value );
            bool getHasMetronomeRelationGroup() const;
            void setHasMetronomeRelationGroup( const bool value );
        private:
            MetronomeNoteSet myMetronomeNoteSet;
            MetronomeRelationGroupPtr myMetronomeRelationGroup;
            bool myHasMetronomeRelationGroup;
        };
        
        class PerMinuteOrBeatUnitChoice;
        using PerMinuteOrBeatUnitChoicePtr = std::shared_ptr<PerMinuteOrBeatUnitChoice>;
        using PerMinuteOrBeatUnitChoiceUPtr = std::unique_ptr<PerMinuteOrBeatUnitChoice>;
        using PerMinuteOrBeatUnitChoiceSet = std::vector<PerMinuteOrBeatUnitChoicePtr>;
        using PerMinuteOrBeatUnitChoiceSetIter = PerMinuteOrBeatUnitChoiceSet::iterator;
        using PerMinuteOrBeatUnitChoiceSetIterConst = PerMinuteOrBeatUnitChoiceSet::const_iterator;
        inline PerMinuteOrBeatUnitChoicePtr makePerMinuteOrBeatUnitChoice() { return std::make_shared<PerMinuteOrBeatUnitChoice>(); }
        class PerMinuteOrBeatUnitChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                perMinute = 0,
                beatUnitGroup = 1
            };
            PerMinuteOrBeatUnitChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PerMinuteOrBeatUnitChoice::Choice getChoice() const;
            void setChoice( const PerMinuteOrBeatUnitChoice::Choice value );
            PerMinutePtr getPerMinute() const;
            void setPerMinute( const PerMinutePtr& value );
            BeatUnitGroupPtr getBeatUnitGroup() const;
            void setBeatUnitGroup( const BeatUnitGroupPtr& value );
        private:
            Choice myChoice;
            PerMinutePtr myPerMinute;
            BeatUnitGroupPtr myBeatUnitGroup;
        };
        
        class BeatUnitPer;
        using BeatUnitPerPtr = std::shared_ptr<BeatUnitPer>;
        using BeatUnitPerUPtr = std::unique_ptr<BeatUnitPer>;
        using BeatUnitPerSet = std::vector<BeatUnitPerPtr>;
        using BeatUnitPerSetIter = BeatUnitPerSet::iterator;
        using BeatUnitPerSetIterConst = BeatUnitPerSet::const_iterator;
        inline BeatUnitPerPtr makeBeatUnitPer() { return std::make_shared<BeatUnitPer>(); }
        class BeatUnitPer : public ElementInterface
        {
        public:
            BeatUnitPer();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BeatUnitGroupPtr getBeatUnitGroup() const;
            void setBeatUnitGroup( const BeatUnitGroupPtr& value );
            PerMinuteOrBeatUnitChoicePtr getPerMinuteOrBeatUnitChoice() const;
            void setPerMinuteOtBeatUnitChoice( const PerMinuteOrBeatUnitChoicePtr& value );
        private:
            BeatUnitGroupPtr myBeatUnitGroup;
            PerMinuteOrBeatUnitChoicePtr myPerMinuteOrBeatUnitChoice;
        };
        
        
        
        class BeatUnitPerOrNoteRelationNoteChoice;
        using BeatUnitPerOrNoteRelationNoteChoicePtr = std::shared_ptr<BeatUnitPerOrNoteRelationNoteChoice>;
        using BeatUnitPerOrNoteRelationNoteChoiceUPtr = std::unique_ptr<BeatUnitPerOrNoteRelationNoteChoice>;
        using BeatUnitPerOrNoteRelationNoteChoiceSet = std::vector<BeatUnitPerOrNoteRelationNoteChoicePtr>;
        using BeatUnitPerOrNoteRelationNoteChoiceSetIter = BeatUnitPerOrNoteRelationNoteChoiceSet::iterator;
        using BeatUnitPerOrNoteRelationNoteChoiceSetIterConst = BeatUnitPerOrNoteRelationNoteChoiceSet::const_iterator;
        inline BeatUnitPerOrNoteRelationNoteChoicePtr makeBeatUnitPerOrNoteRelationNoteChoice() { return std::make_shared<BeatUnitPerOrNoteRelationNoteChoice>(); }
        class BeatUnitPerOrNoteRelationNoteChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                beatUnitPer = 0,
                noteRelationNote = 1
            };
            BeatUnitPerOrNoteRelationNoteChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BeatUnitPerOrNoteRelationNoteChoice::Choice getChoice() const;
            void setChoice( const BeatUnitPerOrNoteRelationNoteChoice::Choice value );
            BeatUnitPerPtr getBeatUnitPer() const;
            void setBeatUnitPer( const BeatUnitPerPtr& value );
            NoteRelationNotePtr getNoteRelationNote() const;
            void setNoteRelationNote( const NoteRelationNotePtr& value );
        private:
            Choice myChoice;
            BeatUnitPerPtr myBeatUnitPer;
            NoteRelationNotePtr myNoteRelationNote;
        };
        /*
         <!--  ID = 3367 [3367] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 24 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="metronome" type="metronome"/>
         <xs:complexType name="metronome">
         <xs:annotation>
         <xs:documentation>The metronome type represents metronome marks and other metric relationships. The beat-unit group and per-minute element specify regular metronome marks. The metronome-note and metronome-relation elements allow for the specification of more complicated metric relationships, such as swing tempo marks where two eighths are equated to a quarter note / eighth note triplet. The parentheses attribute indicates whether or not to put the metronome mark in parentheses; its value is no if not specified.</xs:documentation>
         </xs:annotation>
         <xs:choice> <!-- BeatUnitPerOrNoteRelationNoteChoice -->
         <xs:sequence> <!-- BeatUnitPer -->
         <xs:group ref="beat-unit"/> <!-- BeatUnitGroup -->
         <xs:choice> <!-- PerMinuteOrBeatUnitChoice -->
         <xs:element name="per-minute" type="per-minute"/>
         <xs:group ref="beat-unit"/> <!-- BeatUnitGroup -->
         </xs:choice>
         </xs:sequence>
         <xs:sequence> <!-- NoteRelationNote -->
         <xs:element name="metronome-note" type="metronome-note" maxOccurs="unbounded"/>
         <xs:sequence minOccurs="0"> <!-- MetronomeRelationGroup -->
         <xs:element name="metronome-relation" type="xs:string">
         <xs:annotation>
         <xs:documentation>The metronome-relation element describes the relationship symbol that goes between the two sets of metronome-note elements. The currently allowed value is equals, but this may expand in future versions. If the element is empty, the equals value is used.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="metronome-note" type="metronome-note" maxOccurs="unbounded"/>
         </xs:sequence>
         </xs:sequence>
         </xs:choice>
         <xs:attributeGroup ref="print-style-align"/>
         <xs:attributeGroup ref="justify"/>
         <xs:attribute name="parentheses" type="yes-no"/>
         </xs:complexType>
         <xs:group name="beat-unit">
         <xs:annotation>
         <xs:documentation>The beat-unit group combines elements used repeatedly in the metronome element to specify a note within a metronome mark.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="beat-unit" type="note-type-value">
         <xs:annotation>
         <xs:documentation>The beat-unit element indicates the graphical note type to use in a metronome mark.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="beat-unit-dot" type="empty" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The beat-unit-dot element is used to specify any augmentation dots for a metronome mark note.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group> */
        
        struct MetronomeAttributes;
        using MetronomeAttributesPtr = std::shared_ptr<MetronomeAttributes>;
        
        struct MetronomeAttributes : public AttributesInterface
        {
        public:
            MetronomeAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::LeftCenterRight halign;
            t::Valign valign;
            t::LeftCenterRight justify;
            t::YesNo parentheses;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasHalign;
            bool hasValign;
            bool hasJustify;
            bool hasParentheses;
        };
        
        class Metronome;
        using MetronomePtr = std::shared_ptr<Metronome>;
        using MetronomeUPtr = std::unique_ptr<Metronome>;
        using MetronomeSet = std::vector<MetronomePtr>;
        using MetronomeSetIter = MetronomeSet::iterator;
        using MetronomeSetIterConst = MetronomeSet::const_iterator;
        inline MetronomePtr makeMetronome() { return std::make_shared<Metronome>(); }
        class Metronome : public ElementInterface
        {
        public:
            Metronome();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MetronomeAttributesPtr getAttributes() const;
            void setAttributes( const MetronomeAttributesPtr& value );
            BeatUnitPerOrNoteRelationNoteChoicePtr getBeatUnitPerOrNoteRelationNoteChoice() const;
            void setBeatUnitPerOrNoteRelationNoteChoice( const BeatUnitPerOrNoteRelationNoteChoicePtr& value );
        private:
            MetronomeAttributesPtr myAttributes;
            BeatUnitPerOrNoteRelationNoteChoicePtr myBeatUnitPerOrNoteRelationNoteChoice;
        };
        /*
         3812
         <!--  ID = 3812 [3812] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- RecursiveSubElementCount = 2 -->
         <xs:element name="stick" type="stick"/>
         <xs:complexType name="stick">
         <xs:annotation>
         <xs:documentation>The stick type represents pictograms where the material of the stick, mallet, or beater is included.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="stick-type" type="stick-type"/>
         <xs:element name="stick-material" type="stick-material"/>
         </xs:sequence>
         <xs:attribute name="tip" type="tip-direction"/>
         </xs:complexType> */
        
        struct StickAttributes;
        using StickAttributesPtr = std::shared_ptr<StickAttributes>;
        
        struct StickAttributes : public AttributesInterface
        {
        public:
            StickAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TipDirection tip;
            bool hasTip;
        };
        
        class Stick;
        using StickPtr = std::shared_ptr<Stick>;
        using StickUPtr = std::unique_ptr<Stick>;
        using StickSet = std::vector<StickPtr>;
        using StickSetIter = StickSet::iterator;
        using StickSetIterConst = StickSet::const_iterator;
        inline StickPtr makeStick() { return std::make_shared<Stick>(); }
        class Stick : public ElementInterface
        {
        public:
            Stick();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            StickAttributesPtr getAttributes() const;
            void setAttributes( const StickAttributesPtr& value );
            /* _________ StickType minOccurs = 1, maxOccurs = 1 _________ */
            StickTypePtr getStickType() const;
            void setStickType( const StickTypePtr& value );
            /* _________ StickMaterial minOccurs = 1, maxOccurs = 1 _________ */
            StickMaterialPtr getStickMaterial() const;
            void setStickMaterial( const StickMaterialPtr& value );
        private:
            StickAttributesPtr myAttributes;
            StickTypePtr myStickType;
            StickMaterialPtr myStickMaterial;
        };
        /*
         <!--  ID = 3849 [3849] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 1 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="measure-layout" type="measure-layout" minOccurs="0"/>
         <xs:complexType name="measure-layout">
         <xs:annotation>
         <xs:documentation>The measure-layout type includes the horizontal distance from the previous measure.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="measure-distance" type="tenths" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The measure-distance element specifies the horizontal distance from the previous measure. This value is only used for systems where there is horizontal whitespace in the middle of a system, as in systems with codas. To specify the measure width, use the width attribute of the measure element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:complexType> */
        
        class MeasureLayout;
        using MeasureLayoutPtr = std::shared_ptr<MeasureLayout>;
        using MeasureLayoutUPtr = std::unique_ptr<MeasureLayout>;
        using MeasureLayoutSet = std::vector<MeasureLayoutPtr>;
        using MeasureLayoutSetIter = MeasureLayoutSet::iterator;
        using MeasureLayoutSetIterConst = MeasureLayoutSet::const_iterator;
        inline MeasureLayoutPtr makeMeasureLayout() { return std::make_shared<MeasureLayout>(); }
        class MeasureLayout : public ElementInterface
        {
        public:
            MeasureLayout();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ MeasureDistance minOccurs = 0, maxOccurs = 1 _________ */
            MeasureDistancePtr getMeasureDistance() const;
            void setMeasureDistance( const MeasureDistancePtr& value );
            bool getHasMeasureDistance() const;
            void setHasMeasureDistance( const bool value );
        private:
            MeasureDistancePtr myMeasureDistance;
            bool myHasMeasureDistance;
        };
        /*
         <!--  ID = 3857 [3857, 5928] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="part-name-display" type="name-display" minOccurs="0"/>
         <xs:complexType name="name-display">
         <xs:annotation>
         <xs:documentation>The name-display type is used for exact formatting of multi-font text in part and group names to the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the start of each system. Enclosure for the display-text element is none by default. Language for the display-text element is Italian ("it") by default.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="display-text" type="formatted-text"/>
         <xs:element name="accidental-text" type="accidental-text"/>
         </xs:choice>
         </xs:sequence>
         <xs:attributeGroup ref="print-object"/>
         </xs:complexType> */
        
        class DisplayTextOrAccidentalText;
        using DisplayTextOrAccidentalTextPtr = std::shared_ptr<DisplayTextOrAccidentalText>;
        using DisplayTextOrAccidentalTextUPtr = std::unique_ptr<DisplayTextOrAccidentalText>;
        using DisplayTextOrAccidentalTextSet = std::vector<DisplayTextOrAccidentalTextPtr>;
        using DisplayTextOrAccidentalTextSetIter = DisplayTextOrAccidentalTextSet::iterator;
        using DisplayTextOrAccidentalTextSetIterConst = DisplayTextOrAccidentalTextSet::const_iterator;
        inline DisplayTextOrAccidentalTextPtr makeDisplayTextOrAccidentalText() { return std::make_shared<DisplayTextOrAccidentalText>(); }
        class DisplayTextOrAccidentalText : public ElementInterface
        {
        public:
            enum class Choice
            {
                displayText = 1,
                accidentalText = 2
            };
            DisplayTextOrAccidentalText();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DisplayTextOrAccidentalText::Choice getChoice() const;
            void setChoice( const DisplayTextOrAccidentalText::Choice value );
            DisplayTextPtr getDisplayText() const;
            void setDisplayText( const DisplayTextPtr& value );
            AccidentalTextPtr getAccidentalText() const;
            void setAccidentalText( const AccidentalTextPtr& value );
        private:
            Choice myChoice;
            DisplayTextPtr myDisplayText;
            AccidentalTextPtr myAccidentalText;
        };
        
        struct PartNameDisplayAttributes;
        using PartNameDisplayAttributesPtr = std::shared_ptr<PartNameDisplayAttributes>;
        
        struct PartNameDisplayAttributes : public AttributesInterface
        {
        public:
            PartNameDisplayAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo printObject;
            bool hasPrintObject;
        };
        
        class PartNameDisplay;
        using PartNameDisplayPtr = std::shared_ptr<PartNameDisplay>;
        using PartNameDisplayUPtr = std::unique_ptr<PartNameDisplay>;
        using PartNameDisplaySet = std::vector<PartNameDisplayPtr>;
        using PartNameDisplaySetIter = PartNameDisplaySet::iterator;
        using PartNameDisplaySetIterConst = PartNameDisplaySet::const_iterator;
        inline PartNameDisplayPtr makePartNameDisplay() { return std::make_shared<PartNameDisplay>(); }
        class PartNameDisplay : public ElementInterface
        {
        public:
            PartNameDisplay();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PartNameDisplayAttributesPtr getAttributes() const;
            void setAttributes( const PartNameDisplayAttributesPtr& value );
            /* _________ DisplayTextOrAccidentalText minOccurs = 0, maxOccurs = unbounded _________ */
            const DisplayTextOrAccidentalTextSet& getDisplayTextOrAccidentalText() const;
            void addDisplayTextOrAccidentalText( const DisplayTextOrAccidentalTextPtr& value );
            void removeDisplayTextOrAccidentalText( const DisplayTextOrAccidentalTextSetIterConst& setIterator );
            void clearDisplayTextOrAccidentalTextSet();
            DisplayTextOrAccidentalTextPtr getDisplayTextOrAccidentalText( const DisplayTextOrAccidentalTextSetIterConst& setIterator ) const;
        private:
            PartNameDisplayAttributesPtr myAttributes;
            DisplayTextOrAccidentalTextSet myDisplayTextOrAccidentalTextSet;
        };
        
//        /*
//         <!--  ID = 3861 [3861, 5936] ------------------------->
//         <!-- min=0 max=1 OptionalSingleOccurrence  -->
//         <!-- MsItemElementKind::composite -->
//         <!-- RecursiveSubElementCount = 2 -->
//         <!-- All Sub Elements Are Implemented: true -->
//         <xs:element name="part-abbreviation-display" type="name-display" minOccurs="0"/>
//         <xs:complexType name="name-display">
//         <xs:annotation>
//         <xs:documentation>The name-display type is used for exact formatting of multi-font text in part and group names to the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the start of each system. Enclosure for the display-text element is none by default. Language for the display-text element is Italian ("it") by default.</xs:documentation>
//         </xs:annotation>
//         <xs:sequence>
//         <xs:choice minOccurs="0" maxOccurs="unbounded">
//         <xs:element name="display-text" type="formatted-text"/>
//         <xs:element name="accidental-text" type="accidental-text"/>
//         </xs:choice>
//         </xs:sequence>
//         <xs:attributeGroup ref="print-object"/>
//         </xs:complexType>
//         */
//        
//        struct PartAbbreviationDisplayAttributes;
//        using PartAbbreviationDisplayAttributesPtr = std::shared_ptr<PartAbbreviationDisplayAttributes>;
//        
//        struct PartAbbreviationDisplayAttributes : public AttributesInterface
//        {
//        public:
//            PartAbbreviationDisplayAttributes();
//            virtual bool hasValues() const;
//            virtual std::ostream& toStream( std::ostream& os ) const;
//            t::YesNo printObject;
//            bool hasPrintObject;
//        };
//        
//        class PartAbbreviationDisplay;
//        using PartAbbreviationDisplayPtr = std::shared_ptr<PartAbbreviationDisplay>;
//        using PartAbbreviationDisplayUPtr = std::unique_ptr<PartAbbreviationDisplay>;
//        using PartAbbreviationDisplaySet = std::vector<PartAbbreviationDisplayPtr>;
//        using PartAbbreviationDisplaySetIter = PartAbbreviationDisplaySet::iterator;
//        using PartAbbreviationDisplaySetIterConst = PartAbbreviationDisplaySet::const_iterator;
//        inline PartAbbreviationDisplayPtr makePartAbbreviationDisplay() { return std::make_shared<PartAbbreviationDisplay>(); }
//        class PartAbbreviationDisplay : public ElementInterface
//        {
//        public:
//            PartAbbreviationDisplay();
//            virtual bool hasAttributes() const;
//            virtual std::ostream& streamAttributes( std::ostream& os ) const;
//            virtual std::ostream& streamName( std::ostream& os ) const;
//            virtual bool hasContents() const;
//            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
//            PartAbbreviationDisplayAttributesPtr getAttributes() const;
//            void setAttributes( const PartAbbreviationDisplayAttributesPtr& value );
//            /* _________ DisplayTextOrAccidentalText minOccurs = 0, maxOccurs = unbounded _________ */
//            const DisplayTextOrAccidentalTextSet& getDisplayTextOrAccidentalText() const;
//            void addDisplayTextOrAccidentalText( const DisplayTextOrAccidentalTextPtr& value );
//            void removeDisplayTextOrAccidentalText( const DisplayTextOrAccidentalTextSetIterConst& setIterator );
//            void clearDisplayTextOrAccidentalTextSet();
//            DisplayTextOrAccidentalTextPtr getDisplayTextOrAccidentalText( const DisplayTextOrAccidentalTextSetIterConst& setIterator ) const;
//        private:
//            PartAbbreviationDisplayAttributesPtr myAttributes;
//            DisplayTextOrAccidentalTextSet myDisplayTextOrAccidentalTextSet;
//        };
        
        /*
         3406
         <!--  ID = 3406 [3406] ------------------------->
         <!-- min=1 max=4294967295 OneOrMMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 13 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="percussion" type="percussion" maxOccurs="unbounded"/>
         <xs:complexType name="percussion">
         <xs:annotation>
         <xs:documentation>The percussion element is used to define percussion pictogram symbols. Definitions for these symbols can be found in Kurt Stone's "Music Notation in the Twentieth Century" on pages 206-212 and 223. Some values are added to these based on how usage has evolved in the 30 years since Stone's book was published.</xs:documentation>
         </xs:annotation>
         <xs:choice>
         <xs:element name="glass" type="glass"/>
         <xs:element name="metal" type="metal"/>
         <xs:element name="wood" type="wood"/>
         <xs:element name="pitched" type="pitched"/>
         <xs:element name="membrane" type="membrane"/>
         <xs:element name="effect" type="effect"/>
         <xs:element name="timpani" type="empty"/>
         <xs:element name="beater" type="beater"/>
         <xs:element name="stick" type="stick"/>
         <xs:element name="stick-location" type="stick-location"/>
         <xs:element name="other-percussion" type="xs:string"/>
         </xs:choice>
         <xs:attributeGroup ref="print-style-align"/>
         <xs:attributeGroup ref="enclosure"/>
         </xs:complexType> */
        
        class PercussionChoice;
        using PercussionChoicePtr = std::shared_ptr<PercussionChoice>;
        using PercussionChoiceUPtr = std::unique_ptr<PercussionChoice>;
        using PercussionChoiceSet = std::vector<PercussionChoicePtr>;
        using PercussionChoiceSetIter = PercussionChoiceSet::iterator;
        using PercussionChoiceSetIterConst = PercussionChoiceSet::const_iterator;
        inline PercussionChoicePtr makePercussionChoice() { return std::make_shared<PercussionChoice>(); }
        class PercussionChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                glass = 1,
                metal = 2,
                wood = 3,
                pitched = 4,
                membrane = 5,
                effect = 6,
                timpani = 7,
                beater = 8,
                stick = 9,
                stickType = 10,
                stickMaterial = 11,
                stickLocation = 12,
                otherPercussion = 13
            };
            PercussionChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PercussionChoice::Choice getChoice() const;
            void setChoice( const PercussionChoice::Choice value );
            /* _________ Glass minOccurs = 1, maxOccurs = 1 _________ */
            GlassPtr getGlass() const;
            void setGlass( const GlassPtr& value );
            /* _________ Metal minOccurs = 1, maxOccurs = 1 _________ */
            MetalPtr getMetal() const;
            void setMetal( const MetalPtr& value );
            /* _________ Wood minOccurs = 1, maxOccurs = 1 _________ */
            WoodPtr getWood() const;
            void setWood( const WoodPtr& value );
            /* _________ Pitched minOccurs = 1, maxOccurs = 1 _________ */
            PitchedPtr getPitched() const;
            void setPitched( const PitchedPtr& value );
            /* _________ Membrane minOccurs = 1, maxOccurs = 1 _________ */
            MembranePtr getMembrane() const;
            void setMembrane( const MembranePtr& value );
            /* _________ Effect minOccurs = 1, maxOccurs = 1 _________ */
            EffectPtr getEffect() const;
            void setEffect( const EffectPtr& value );
            /* _________ Timpani minOccurs = 1, maxOccurs = 1 _________ */
            TimpaniPtr getTimpani() const;
            void setTimpani( const TimpaniPtr& value );
            /* _________ Beater minOccurs = 1, maxOccurs = 1 _________ */
            BeaterPtr getBeater() const;
            void setBeater( const BeaterPtr& value );
            /* _________ Stick minOccurs = 1, maxOccurs = 1 _________ */
            StickPtr getStick() const;
            void setStick( const StickPtr& value );
            /* _________ StickType minOccurs = 1, maxOccurs = 1 _________ */
            StickTypePtr getStickType() const;
            void setStickType( const StickTypePtr& value );
            /* _________ StickMaterial minOccurs = 1, maxOccurs = 1 _________ */
            StickMaterialPtr getStickMaterial() const;
            void setStickMaterial( const StickMaterialPtr& value );
            /* _________ StickLocation minOccurs = 1, maxOccurs = 1 _________ */
            StickLocationPtr getStickLocation() const;
            void setStickLocation( const StickLocationPtr& value );
            /* _________ OtherPercussion minOccurs = 1, maxOccurs = 1 _________ */
            OtherPercussionPtr getOtherPercussion() const;
            void setOtherPercussion( const OtherPercussionPtr& value );
        private:
            Choice myChoice;
            GlassPtr myGlass;
            MetalPtr myMetal;
            WoodPtr myWood;
            PitchedPtr myPitched;
            MembranePtr myMembrane;
            EffectPtr myEffect;
            TimpaniPtr myTimpani;
            BeaterPtr myBeater;
            StickPtr myStick;
            StickTypePtr myStickType;
            StickMaterialPtr myStickMaterial;
            StickLocationPtr myStickLocation;
            OtherPercussionPtr myOtherPercussion;
        };
        
        
        struct PercussionAttributes;
        using PercussionAttributesPtr = std::shared_ptr<PercussionAttributes>;
        
        struct PercussionAttributes : public AttributesInterface
        {
        public:
            PercussionAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::LeftCenterRight halign;
            t::Valign valign;
            t::EnclosureShape enclosure;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasHalign;
            bool hasValign;
            bool hasEnclosure;
        };
        
        class Percussion;
        using PercussionPtr = std::shared_ptr<Percussion>;
        using PercussionUPtr = std::unique_ptr<Percussion>;
        using PercussionSet = std::vector<PercussionPtr>;
        using PercussionSetIter = PercussionSet::iterator;
        using PercussionSetIterConst = PercussionSet::const_iterator;
        inline PercussionPtr makePercussion() { return std::make_shared<Percussion>(); }
        class Percussion : public ElementInterface
        {
        public:
            Percussion();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PercussionAttributesPtr getAttributes() const;
            void setAttributes( const PercussionAttributesPtr& value );
            PercussionChoicePtr getPercussionChoice() const;
            void setPercussionChoice( const PercussionChoicePtr& value );
        private:
            PercussionAttributesPtr myAttributes;
            PercussionChoicePtr myChoice;
        };
        
        /*
         <!--  ID = 3910 [3910] ------------------------->
         <!-- min=1 max=4294967295 OneOrMMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 3 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="accord" type="accord" maxOccurs="unbounded"/>
         <xs:complexType name="accord">
         <xs:annotation>
         <xs:documentation>The accord type represents the tuning of a single string in the scordatura element. It uses the same group of elements as the staff-tuning element. Strings are numbered from high to low.</xs:documentation>
         </xs:annotation>
         <xs:group ref="tuning"/>
         <xs:attribute name="string" type="string-number"/>
         </xs:complexType>
         <xs:group name="tuning">
         <xs:annotation>
         <xs:documentation>The tuning group contains the sequence of elements common to the staff-tuning and accord elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="tuning-step" type="step">
         <xs:annotation>
         <xs:documentation>The tuning-step element is represented like the step element, with a different name to reflect is different function.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="tuning-alter" type="semitones" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The tuning-alter element is represented like the alter element, with a different name to reflect is different function.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="tuning-octave" type="octave">
         <xs:annotation>
         <xs:documentation>The tuning-octave element is represented like the octave element, with a different name to reflect is different function.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group> */
        
        struct AccordAttributes;
        using AccordAttributesPtr = std::shared_ptr<AccordAttributes>;
        
        struct AccordAttributes : public AttributesInterface
        {
        public:
            AccordAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StringNumber string;
            bool hasString;
        };
        
        class Accord;
        using AccordPtr = std::shared_ptr<Accord>;
        using AccordUPtr = std::unique_ptr<Accord>;
        using AccordSet = std::vector<AccordPtr>;
        using AccordSetIter = AccordSet::iterator;
        using AccordSetIterConst = AccordSet::const_iterator;
        inline AccordPtr makeAccord() { return std::make_shared<Accord>(); }
        class Accord : public ElementInterface
        {
        public:
            Accord();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            AccordAttributesPtr getAttributes() const;
            void setAttributes( const AccordAttributesPtr& value );
            /* _________ TuningStep minOccurs = 1, maxOccurs = 1 _________ */
            TuningStepPtr getTuningStep() const;
            void setTuningStep( const TuningStepPtr& value );
            /* _________ TuningAlter minOccurs = 0, maxOccurs = 1 _________ */
            TuningAlterPtr getTuningAlter() const;
            void setTuningAlter( const TuningAlterPtr& value );
            bool getHasTuningAlter() const;
            void setHasTuningAlter( const bool value );
            /* _________ TuningOctave minOccurs = 1, maxOccurs = 1 _________ */
            TuningOctavePtr getTuningOctave() const;
            void setTuningOctave( const TuningOctavePtr& value );
        private:
            AccordAttributesPtr myAttributes;
            TuningStepPtr myTuningStep;
            TuningAlterPtr myTuningAlter;
            bool myHasTuningAlter;
            TuningOctavePtr myTuningOctave;
        };
        /* <!--  ID = 3394 [3394] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 4 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="scordatura" type="scordatura"/>
         <xs:complexType name="scordatura">
         <xs:annotation>
         <xs:documentation>Scordatura string tunings are represented by a series of accord elements, similar to the staff-tuning elements. Strings are numbered from high to low.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="accord" type="accord" maxOccurs="unbounded"/>
         </xs:sequence>
         </xs:complexType>
         */
        
        class Scordatura;
        using ScordaturaPtr = std::shared_ptr<Scordatura>;
        using ScordaturaUPtr = std::unique_ptr<Scordatura>;
        using ScordaturaSet = std::vector<ScordaturaPtr>;
        using ScordaturaSetIter = ScordaturaSet::iterator;
        using ScordaturaSetIterConst = ScordaturaSet::const_iterator;
        inline ScordaturaPtr makeScordatura() { return std::make_shared<Scordatura>(); }
        class Scordatura : public ElementInterface
        {
        public:
            Scordatura();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Accord minOccurs = 1, maxOccurs = unbounded _________ */
            const AccordSet& getAccordSet() const;
            void addAccord( const AccordPtr& value );
            void removeAccord( const AccordSetIterConst& value );
            void clearAccordSet();
            AccordPtr getAccord( const AccordSetIterConst& setIterator ) const;
        private:
            AccordSet myAccordSet;
        };
        /*
         <!--  ID = 3301 [3301] ------------------------->
         <!-- min=1 max=4294967295 OneOrMMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 93 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="direction-type" type="direction-type" maxOccurs="unbounded"/>
         <xs:complexType name="direction-type">
         <xs:annotation>
         <xs:documentation>Textual direction types may have more than 1 component due to multiple fonts. The dynamics element may also be used in the notations element. Attribute groups related to print suggestions apply to the individual direction-type, not to the overall direction.</xs:documentation>
         </xs:annotation>
         <xs:choice>
         <xs:element name="rehearsal" type="formatted-text" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The rehearsal type specifies a rehearsal mark. Language is Italian ("it") by default. Enclosure is square by default. Left justification is assumed if not specified.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="segno" type="empty-print-style-align" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The segno element is the visual indicator of a segno sign. A sound element is needed to guide playback applications reliably.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="words" type="formatted-text" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The words element specifies a standard text direction. Left justification is assumed if not specified. Language is Italian ("it") by default. Enclosure is none by default.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="coda" type="empty-print-style-align" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The coda element is the visual indicator of a coda sign. A sound element is needed to guide playback applications reliably.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="wedge" type="wedge"/>
         <xs:element name="dynamics" type="dynamics" maxOccurs="unbounded"/>
         <xs:element name="dashes" type="dashes"/>
         <xs:element name="bracket" type="bracket"/>
         <xs:element name="pedal" type="pedal"/>
         <xs:element name="metronome" type="metronome"/>
         <xs:element name="octave-shift" type="octave-shift"/>
         <xs:element name="harp-pedals" type="harp-pedals"/>
         <xs:element name="damp" type="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The damp element specifies a harp damping mark.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="damp-all" type="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The damp-all element specifies a harp damping mark for all strings.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="eyeglasses" type="empty-print-style-align">
         <xs:annotation>
         <xs:documentation>The eyeglasses element specifies the eyeglasses symbol, common in commercial music.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="string-mute" type="string-mute"/>
         <xs:element name="scordatura" type="scordatura"/>
         <xs:element name="image" type="image"/>
         <xs:element name="principal-voice" type="principal-voice"/>
         <xs:element name="accordion-registration" type="accordion-registration"/>
         <xs:element name="percussion" type="percussion" maxOccurs="unbounded"/>
         <xs:element name="other-direction" type="other-direction"/>
         </xs:choice>
         </xs:complexType> */
        
        struct AttributesIterface;
        using AttributesIterfacePtr = std::shared_ptr<AttributesIterface>;
        
        struct AttributesIterface : public AttributesInterface
        {
        public:
            AttributesIterface();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
        };
        
        class DirectionType;
        using DirectionTypePtr = std::shared_ptr<DirectionType>;
        using DirectionTypeUPtr = std::unique_ptr<DirectionType>;
        using DirectionTypeSet = std::vector<DirectionTypePtr>;
        using DirectionTypeSetIter = DirectionTypeSet::iterator;
        using DirectionTypeSetIterConst = DirectionTypeSet::const_iterator;
        inline DirectionTypePtr makeDirectionType() { return std::make_shared<DirectionType>(); }
        class DirectionType : public ElementInterface
        {
        public:
            enum class Choice
            {
                rehearsal = 1,
                segno = 2,
                words = 3,
                coda = 4,
                wedge = 5,
                dynamics = 6,
                dashes = 7,
                bracket = 8,
                pedal = 9,
                metronome = 10,
                octaveShift = 11,
                harpPedals = 12,
                damp = 13,
                dampAll = 14,
                eyeglasses = 15,
                stringMute = 16,
                scordatura = 17,
                image = 18,
                principalVoice = 19,
                accordionRegistration = 20,
                percussion = 21,
                otherDirection = 22
            };
            DirectionType();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DirectionType::Choice getChoice() const;
            void setChoice( const DirectionType::Choice value );
            /* _________ Rehearsal minOccurs = 1, maxOccurs = unbounded _________ */
            const RehearsalSet& getRehearsalSet() const;
            void addRehearsal( const RehearsalPtr& value );
            void removeRehearsal( const RehearsalSetIterConst& value );
            void clearRehearsalSet();
            RehearsalPtr getRehearsal( const RehearsalSetIterConst& setIterator ) const;
            /* _________ Segno minOccurs = 1, maxOccurs = unbounded _________ */
            const SegnoSet& getSegnoSet() const;
            void addSegno( const SegnoPtr& value );
            void removeSegno( const SegnoSetIterConst& value );
            void clearSegnoSet();
            SegnoPtr getSegno( const SegnoSetIterConst& setIterator ) const;
            /* _________ Words minOccurs = 1, maxOccurs = unbounded _________ */
            const WordsSet& getWordsSet() const;
            void addWords( const WordsPtr& value );
            void removeWords( const WordsSetIterConst& value );
            void clearWordsSet();
            WordsPtr getWords( const WordsSetIterConst& setIterator ) const;
            /* _________ Coda minOccurs = 1, maxOccurs = unbounded _________ */
            const CodaSet& getCodaSet() const;
            void addCoda( const CodaPtr& value );
            void removeCoda( const CodaSetIterConst& value );
            void clearCodaSet();
            CodaPtr getCoda( const CodaSetIterConst& setIterator ) const;
            /* _________ Wedge minOccurs = 1, maxOccurs = 1 _________ */
            WedgePtr getWedge() const;
            void setWedge( const WedgePtr& value );
            /* _________ Dynamics minOccurs = 1, maxOccurs = unbounded _________ */
            const DynamicsSet& getDynamicsSet() const;
            void addDynamics( const DynamicsPtr& value );
            void removeDynamics( const DynamicsSetIterConst& value );
            void clearDynamicsSet();
            DynamicsPtr getDynamics( const DynamicsSetIterConst& setIterator ) const;
            /* _________ Dashes minOccurs = 1, maxOccurs = 1 _________ */
            DashesPtr getDashes() const;
            void setDashes( const DashesPtr& value );
            /* _________ Bracket minOccurs = 1, maxOccurs = 1 _________ */
            BracketPtr getBracket() const;
            void setBracket( const BracketPtr& value );
            /* _________ Pedal minOccurs = 1, maxOccurs = 1 _________ */
            PedalPtr getPedal() const;
            void setPedal( const PedalPtr& value );
            /* _________ Metronome minOccurs = 1, maxOccurs = 1 _________ */
            MetronomePtr getMetronome() const;
            void setMetronome( const MetronomePtr& value );
            /* _________ OctaveShift minOccurs = 1, maxOccurs = 1 _________ */
            OctaveShiftPtr getOctaveShift() const;
            void setOctaveShift( const OctaveShiftPtr& value );
            /* _________ HarpPedals minOccurs = 1, maxOccurs = 1 _________ */
            HarpPedalsPtr getHarpPedals() const;
            void setHarpPedals( const HarpPedalsPtr& value );
            /* _________ Damp minOccurs = 1, maxOccurs = 1 _________ */
            DampPtr getDamp() const;
            void setDamp( const DampPtr& value );
            /* _________ DampAll minOccurs = 1, maxOccurs = 1 _________ */
            DampAllPtr getDampAll() const;
            void setDampAll( const DampAllPtr& value );
            /* _________ Eyeglasses minOccurs = 1, maxOccurs = 1 _________ */
            EyeglassesPtr getEyeglasses() const;
            void setEyeglasses( const EyeglassesPtr& value );
            /* _________ StringMute minOccurs = 1, maxOccurs = 1 _________ */
            StringMutePtr getStringMute() const;
            void setStringMute( const StringMutePtr& value );
            /* _________ Scordatura minOccurs = 1, maxOccurs = 1 _________ */
            ScordaturaPtr getScordatura() const;
            void setScordatura( const ScordaturaPtr& value );
            /* _________ Image minOccurs = 1, maxOccurs = 1 _________ */
            ImagePtr getImage() const;
            void setImage( const ImagePtr& value );
            /* _________ PrincipalVoice minOccurs = 1, maxOccurs = 1 _________ */
            PrincipalVoicePtr getPrincipalVoice() const;
            void setPrincipalVoice( const PrincipalVoicePtr& value );
            /* _________ AccordionRegistration minOccurs = 1, maxOccurs = 1 _________ */
            AccordionRegistrationPtr getAccordionRegistration() const;
            void setAccordionRegistration( const AccordionRegistrationPtr& value );
            /* _________ Percussion minOccurs = 1, maxOccurs = unbounded _________ */
            const PercussionSet& getPercussionSet() const;
            void addPercussion( const PercussionPtr& value );
            void removePercussion( const PercussionSetIterConst& value );
            void clearPercussionSet();
            PercussionPtr getPercussion( const PercussionSetIterConst& setIterator ) const;
            /* _________ OtherDirection minOccurs = 1, maxOccurs = 1 _________ */
            OtherDirectionPtr getOtherDirection() const;
            void setOtherDirection( const OtherDirectionPtr& value );
        private:
            Choice myChoice;
            RehearsalSet myRehearsalSet;
            SegnoSet mySegnoSet;
            WordsSet myWordsSet;
            CodaSet myCodaSet;
            WedgePtr myWedge;
            DynamicsSet myDynamicsSet;
            DashesPtr myDashes;
            BracketPtr myBracket;
            PedalPtr myPedal;
            MetronomePtr myMetronome;
            OctaveShiftPtr myOctaveShift;
            HarpPedalsPtr myHarpPedals;
            DampPtr myDamp;
            DampAllPtr myDampAll;
            EyeglassesPtr myEyeglasses;
            StringMutePtr myStringMute;
            ScordaturaPtr myScordatura;
            ImagePtr myImage;
            PrincipalVoicePtr myPrincipalVoice;
            AccordionRegistrationPtr myAccordionRegistration;
            PercussionSet myPercussionSet;
            OtherDirectionPtr myOtherDirection;
        };
        
        /*
         3926 [ equivalents 3926, 5959 ]
         <!--  ID = 3926 [3926, 5959] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 8 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="midi-instrument" type="midi-instrument" minOccurs="0"/>
         <xs:complexType name="midi-instrument">
         <xs:annotation>
         <xs:documentation>The midi-instrument type defines MIDI 1.0 instrument playback. The midi-instrument element can be a part of either the score-instrument element at the start of a part, or the sound element within a part. The id attribute refers to the score-instrument affected by the change.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="midi-channel" type="midi-16" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The midi-channel element specifies a MIDI 1.0 channel numbers ranging from 1 to 16.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="midi-name" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The midi-name element corresponds to a ProgramName meta-event within a Standard MIDI File.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="midi-bank" type="midi-16384" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The midi-bank element specified a MIDI 1.0 bank number ranging from 1 to 16,384.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="midi-program" type="midi-128" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The midi-program element specifies a MIDI 1.0 program number ranging from 1 to 128.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="midi-unpitched" type="midi-128" minOccurs="0">
         <xs:annotation>
         <xs:documentation>For unpitched instruments, the midi-unpitched element specifies a MIDI 1.0 note number ranging from 1 to 128. It is usually used with MIDI banks for percussion. Note that MIDI 1.0 note numbers are generally specified from 0 to 127 rather than the 1 to 128 numbering used in this element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="volume" type="percent" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The volume element value is a percentage of the maximum ranging from 0 to 100, with decimal values allowed. This corresponds to a scaling value for the MIDI 1.0 channel volume controller.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="pan" type="rotation-degrees" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The pan and elevation elements allow placing of sound in a 3-D space relative to the listener. Both are expressed in degrees ranging from -180 to 180. For pan, 0 is straight ahead, -90 is hard left, 90 is hard right, and -180 and 180 are directly behind the listener.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="elevation" type="rotation-degrees" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The elevation and pan elements allow placing of sound in a 3-D space relative to the listener. Both are expressed in degrees ranging from -180 to 180. For elevation, 0 is level with the listener, 90 is directly above, and -90 is directly below.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         <xs:attribute name="id" type="xs:IDREF" use="required"/>
         </xs:complexType> */
        
        struct MidiInstrumentAttributes;
        using MidiInstrumentAttributesPtr = std::shared_ptr<MidiInstrumentAttributes>;
        
        struct MidiInstrumentAttributes : public AttributesInterface
        {
        public:
            MidiInstrumentAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsIDREF id;
            const 	bool hasId;
        };
        
        class MidiInstrument;
        using MidiInstrumentPtr = std::shared_ptr<MidiInstrument>;
        using MidiInstrumentUPtr = std::unique_ptr<MidiInstrument>;
        using MidiInstrumentSet = std::vector<MidiInstrumentPtr>;
        using MidiInstrumentSetIter = MidiInstrumentSet::iterator;
        using MidiInstrumentSetIterConst = MidiInstrumentSet::const_iterator;
        inline MidiInstrumentPtr makeMidiInstrument() { return std::make_shared<MidiInstrument>(); }
        class MidiInstrument : public ElementInterface
        {
        public:
            MidiInstrument();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MidiInstrumentAttributesPtr getAttributes() const;
            void setAttributes( const MidiInstrumentAttributesPtr& value );
            /* _________ MidiChannel minOccurs = 0, maxOccurs = 1 _________ */
            MidiChannelPtr getMidiChannel() const;
            void setMidiChannel( const MidiChannelPtr& value );
            bool getHasMidiChannel() const;
            void setHasMidiChannel( const bool value );
            /* _________ MidiName minOccurs = 0, maxOccurs = 1 _________ */
            MidiNamePtr getMidiName() const;
            void setMidiName( const MidiNamePtr& value );
            bool getHasMidiName() const;
            void setHasMidiName( const bool value );
            /* _________ MidiBank minOccurs = 0, maxOccurs = 1 _________ */
            MidiBankPtr getMidiBank() const;
            void setMidiBank( const MidiBankPtr& value );
            bool getHasMidiBank() const;
            void setHasMidiBank( const bool value );
            /* _________ MidiProgram minOccurs = 0, maxOccurs = 1 _________ */
            MidiProgramPtr getMidiProgram() const;
            void setMidiProgram( const MidiProgramPtr& value );
            bool getHasMidiProgram() const;
            void setHasMidiProgram( const bool value );
            /* _________ MidiUnpitched minOccurs = 0, maxOccurs = 1 _________ */
            MidiUnpitchedPtr getMidiUnpitched() const;
            void setMidiUnpitched( const MidiUnpitchedPtr& value );
            bool getHasMidiUnpitched() const;
            void setHasMidiUnpitched( const bool value );
            /* _________ Volume minOccurs = 0, maxOccurs = 1 _________ */
            VolumePtr getVolume() const;
            void setVolume( const VolumePtr& value );
            bool getHasVolume() const;
            void setHasVolume( const bool value );
            /* _________ Pan minOccurs = 0, maxOccurs = 1 _________ */
            PanPtr getPan() const;
            void setPan( const PanPtr& value );
            bool getHasPan() const;
            void setHasPan( const bool value );
            /* _________ Elevation minOccurs = 0, maxOccurs = 1 _________ */
            ElevationPtr getElevation() const;
            void setElevation( const ElevationPtr& value );
            bool getHasElevation() const;
            void setHasElevation( const bool value );
        private:
            MidiInstrumentAttributesPtr myAttributes;
            MidiChannelPtr myMidiChannel;
            bool myHasMidiChannel;
            MidiNamePtr myMidiName;
            bool myHasMidiName;
            MidiBankPtr myMidiBank;
            bool myHasMidiBank;
            MidiProgramPtr myMidiProgram;
            bool myHasMidiProgram;
            MidiUnpitchedPtr myMidiUnpitched;
            bool myHasMidiUnpitched;
            VolumePtr myVolume;
            bool myHasVolume;
            PanPtr myPan;
            bool myHasPan;
            ElevationPtr myElevation;
            bool myHasElevation;
        };
        
        /*
         3930 [ equivalents 3930, 5050 ]
         <!--  ID = 3930 [3930, 5050] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 4 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="play" type="play" minOccurs="0"/>
         <xs:complexType name="play">
         <xs:annotation>
         <xs:documentation>The play type, new in Version 3.0, specifies playback techniques to be used in conjunction with the instrument-sound element. When used as part of a sound element, it applies to all notes going forward in score order. In multi-instrument parts, the affected instrument should be specified using the id attribute. When used as part of a note element, it applies to the current note only.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="ipa" type="xs:string">
         <xs:annotation>
         <xs:documentation>The ipa element represents International Phonetic Alphabet (IPA) sounds for vocal music. String content is limited to IPA 2005 symbols represented in Unicode 6.0.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="mute" type="mute"/>
         <xs:element name="semi-pitched" type="semi-pitched"/>
         <xs:element name="other-play" type="other-play"/>
         </xs:choice>
         </xs:sequence>
         <xs:attribute name="id" type="xs:IDREF"/>
         </xs:complexType> */
        
        struct PlayAttributes;
        using PlayAttributesPtr = std::shared_ptr<PlayAttributes>;
        
        struct PlayAttributes : public AttributesInterface
        {
        public:
            PlayAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsIDREF id;
            bool hasId;
        };
        
        class Play;
        using PlayPtr = std::shared_ptr<Play>;
        using PlayUPtr = std::unique_ptr<Play>;
        using PlaySet = std::vector<PlayPtr>;
        using PlaySetIter = PlaySet::iterator;
        using PlaySetIterConst = PlaySet::const_iterator;
        inline PlayPtr makePlay() { return std::make_shared<Play>(); }
        class Play : public ElementInterface
        {
        public:
            enum class Choice
            {
                ipa = 1,
                mute = 2,
                semiPitched = 3,
                otherPlay = 4
            };
            Play();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PlayAttributesPtr getAttributes() const;
            void setAttributes( const PlayAttributesPtr& value );
            /* _________ Choice __________ */
            Play::Choice getChoice() const;
            void setChoice( const Play::Choice value );
            /* _________ Ipa minOccurs = 1, maxOccurs = 1 _________ */
            IpaPtr getIpa() const;
            void setIpa( const IpaPtr& value );
            /* _________ Mute minOccurs = 1, maxOccurs = 1 _________ */
            MutePtr getMute() const;
            void setMute( const MutePtr& value );
            /* _________ SemiPitched minOccurs = 1, maxOccurs = 1 _________ */
            SemiPitchedPtr getSemiPitched() const;
            void setSemiPitched( const SemiPitchedPtr& value );
            /* _________ OtherPlay minOccurs = 1, maxOccurs = 1 _________ */
            OtherPlayPtr getOtherPlay() const;
            void setOtherPlay( const OtherPlayPtr& value );
            
        private:
            PlayAttributesPtr myAttributes;
            Choice myChoice;
            IpaPtr myIpa;
            MutePtr myMute;
            SemiPitchedPtr mySemiPitched;
            OtherPlayPtr myOtherPlay;
        };
        /*
         4079
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 5 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="encoding" type="encoding" minOccurs="0"/>
         <xs:complexType name="encoding">
         <xs:annotation>
         <xs:documentation>The encoding element contains information about who did the digital encoding, when, with what software, and in what aspects. Standard type values for the encoder element are music, words, and arrangement, but other types may be used. The type attribute is only needed when there are multiple encoder elements.</xs:documentation>
         </xs:annotation>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="encoding-date" type="yyyy-mm-dd"/>
         <xs:element name="encoder" type="typed-text"/>
         <xs:element name="software" type="xs:string"/>
         <xs:element name="encoding-description" type="xs:string"/>
         <xs:element name="supports" type="supports"/>
         </xs:choice>
         </xs:complexType> */
        
        class Encoding;
        using EncodingPtr = std::shared_ptr<Encoding>;
        using EncodingUPtr = std::unique_ptr<Encoding>;
        using EncodingSet = std::vector<EncodingPtr>;
        using EncodingSetIter = EncodingSet::iterator;
        using EncodingSetIterConst = EncodingSet::const_iterator;
        inline EncodingPtr makeEncoding() { return std::make_shared<Encoding>(); }
        class Encoding : public ElementInterface
        {
        public:
            enum class Choice
            {
                encodingDate = 1,
                encoder = 2,
                software = 3,
                encodingDescription = 4,
                supports = 5
            };
            Encoding();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice _________ */
            Encoding::Choice getChoice() const;
            void setChoice( const Encoding::Choice value );
            /* _________ EncodingDate minOccurs = 1, maxOccurs = 1 _________ */
            EncodingDatePtr getEncodingDate() const;
            void setEncodingDate( const EncodingDatePtr& value );
            /* _________ Encoder minOccurs = 1, maxOccurs = 1 _________ */
            EncoderPtr getEncoder() const;
            void setEncoder( const EncoderPtr& value );
            /* _________ Software minOccurs = 1, maxOccurs = 1 _________ */
            SoftwarePtr getSoftware() const;
            void setSoftware( const SoftwarePtr& value );
            /* _________ EncodingDescription minOccurs = 1, maxOccurs = 1 _________ */
            EncodingDescriptionPtr getEncodingDescription() const;
            void setEncodingDescription( const EncodingDescriptionPtr& value );
            /* _________ Supports minOccurs = 1, maxOccurs = 1 _________ */
            SupportsPtr getSupports() const;
            void setSupports( const SupportsPtr& value );
        private:
            Choice myChoice;
            EncodingDatePtr myEncodingDate;
            EncoderPtr myEncoder;
            SoftwarePtr mySoftware;
            EncodingDescriptionPtr myEncodingDescription;
            SupportsPtr mySupports;
        };
        /*
         4096
         <!--  ID = 4096 [4096] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 1 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="miscellaneous" type="miscellaneous" minOccurs="0"/>
         <xs:complexType name="miscellaneous">
         <xs:annotation>
         <xs:documentation>If a program has other metadata not yet supported in the MusicXML format, it can go in the miscellaneous element. The miscellaneous type puts each separate part of metadata into its own miscellaneous-field type.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="miscellaneous-field" type="miscellaneous-field" minOccurs="0" maxOccurs="unbounded"/>
         </xs:sequence>
         </xs:complexType> */
        
        class Miscellaneous;
        using MiscellaneousPtr = std::shared_ptr<Miscellaneous>;
        using MiscellaneousUPtr = std::unique_ptr<Miscellaneous>;
        using MiscellaneousSet = std::vector<MiscellaneousPtr>;
        using MiscellaneousSetIter = MiscellaneousSet::iterator;
        using MiscellaneousSetIterConst = MiscellaneousSet::const_iterator;
        inline MiscellaneousPtr makeMiscellaneous() { return std::make_shared<Miscellaneous>(); }
        class Miscellaneous : public ElementInterface
        {
        public:
            Miscellaneous();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ MiscellaneousField minOccurs = 0, maxOccurs = unbounded _________ */
            const MiscellaneousFieldSet& getMiscellaneousFieldSet() const;
            void addMiscellaneousField( const MiscellaneousFieldPtr& value );
            void removeMiscellaneousField( const MiscellaneousFieldSetIterConst& value );
            void clearMiscellaneousFieldSet();
            MiscellaneousFieldPtr getMiscellaneousField( const MiscellaneousFieldSetIterConst& setIterator ) const;
        private:
            MiscellaneousFieldSet myMiscellaneousFieldSet;
        };
        /*
         3314 [ equivalents 3314, 6331 ]
         <!--  ID = 3314 [3314, 6331] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 16 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="sound" type="sound" minOccurs="0"/>
         <xs:complexType name="sound">
         <xs:annotation>
         <xs:documentation>The sound element contains general playback parameters. They can stand alone within a part/measure, or be a component element within a direction.
         
         Tempo is expressed in quarter notes per minute. If 0, the sound-generating program should prompt the user at the time of compiling a sound (MIDI) file.
         
         Dynamics (or MIDI velocity) are expressed as a percentage of the default forte value (90 for MIDI 1.0).
         
         Dacapo indicates to go back to the beginning of the movement. When used it always has the value "yes".
         
         Segno and dalsegno are used for backwards jumps to a segno sign; coda and tocoda are used for forward jumps to a coda sign. If there are multiple jumps, the value of these parameters can be used to name and distinguish them. If segno or coda is used, the divisions attribute can also be used to indicate the number of divisions per quarter note. Otherwise sound and MIDI generating programs may have to recompute this.
         
         By default, a dalsegno or dacapo attribute indicates that the jump should occur the first time through, while a tocoda attribute indicates the jump should occur the second time through. The time that jumps occur can be changed by using the time-only attribute.
         
         Forward-repeat is used when a forward repeat sign is implied, and usually follows a bar line. When used it always has the value of "yes".
         
         The fine attribute follows the final note or rest in a movement with a da capo or dal segno direction. If numeric, the value represents the actual duration of the final note or rest, which can be ambiguous in written notation and different among parts and voices. The value may also be "yes" to indicate no change to the final duration.
         
         If the sound element applies only particular times through a repeat, the time-only attribute indicates which times to apply the sound element.
         
         Pizzicato in a sound element effects all following notes. Yes indicates pizzicato, no indicates arco.
         
         The pan and elevation attributes are deprecated in Version 2.0. The pan and elevation elements in the midi-instrument element should be used instead. The meaning of the pan and elevation attributes is the same as for the pan and elevation elements. If both are present, the mid-instrument elements take priority.
         
         The damper-pedal, soft-pedal, and sostenuto-pedal attributes effect playback of the three common piano pedals and their MIDI controller equivalents. The yes value indicates the pedal is depressed; no indicates the pedal is released. A numeric value from 0 to 100 may also be used for half pedaling. This value is the percentage that the pedal is depressed. A value of 0 is equivalent to no, and a value of 100 is equivalent to yes.
         
         MIDI devices, MIDI instruments, and playback techniques are changed using the midi-device, midi-instrument, and play elements. When there are multiple instances of these elements, they should be grouped together by instrument using the id attribute values.
         
         The offset element is used to indicate that the sound takes place offset from the current score position. If the sound element is a child of a direction element, the sound offset element overrides the direction offset element if both elements are present. Note that the offset reflects the intended musical position for the change in sound. It should not be used to compensate for latency issues in particular hardware configurations.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:sequence minOccurs="0" maxOccurs="unbounded">
         <xs:element name="midi-device" type="midi-device" minOccurs="0"/>
         <xs:element name="midi-instrument" type="midi-instrument" minOccurs="0"/>
         <xs:element name="play" type="play" minOccurs="0"/>
         </xs:sequence>
         <xs:element name="offset" type="offset" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="tempo" type="non-negative-decimal"/>
         <xs:attribute name="dynamics" type="non-negative-decimal"/>
         <xs:attribute name="dacapo" type="yes-no"/>
         <xs:attribute name="segno" type="xs:token"/>
         <xs:attribute name="dalsegno" type="xs:token"/>
         <xs:attribute name="coda" type="xs:token"/>
         <xs:attribute name="tocoda" type="xs:token"/>
         <xs:attribute name="divisions" type="divisions"/>
         <xs:attribute name="forward-repeat" type="yes-no"/>
         <xs:attribute name="fine" type="xs:token"/>
         <xs:attribute name="time-only" type="time-only"/>
         <xs:attribute name="pizzicato" type="yes-no"/>
         <xs:attribute name="pan" type="rotation-degrees"/>
         <xs:attribute name="elevation" type="rotation-degrees"/>
         <xs:attribute name="damper-pedal" type="yes-no-number"/>
         <xs:attribute name="soft-pedal" type="yes-no-number"/>
         <xs:attribute name="sostenuto-pedal" type="yes-no-number"/>
         </xs:complexType> */
        
        struct SoundAttributes;
        using SoundAttributesPtr = std::shared_ptr<SoundAttributes>;
        
        struct SoundAttributes : public AttributesInterface
        {
        public:
            SoundAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::NonNegativeDecimal tempo;
            t::NonNegativeDecimal dynamics;
            t::YesNo dacapo;
            t::XsToken segno;
            t::XsToken dalsegno;
            t::XsToken coda;
            t::XsToken tocoda;
            t::DivisionsValue divisions;
            t::YesNo forwardRepeat;
            t::XsToken fine;
            t::TimeOnly timeOnly;
            t::YesNo pizzicato;
            t::RotationDegrees pan;
            t::RotationDegrees elevation;
            t::YesNoNumber damperPedal;
            t::YesNoNumber softPedal;
            t::YesNoNumber sostenutoPedal;
            bool hasTempo;
            bool hasDynamics;
            bool hasDacapo;
            bool hasSegno;
            bool hasDalsegno;
            bool hasCoda;
            bool hasTocoda;
            bool hasDivisions;
            bool hasForwardRepeat;
            bool hasFine;
            bool hasTimeOnly;
            bool hasPizzicato;
            bool hasPan;
            bool hasElevation;
            bool hasDamperPedal;
            bool hasSoftPedal;
            bool hasSostenutoPedal;
        };
        
        class Sound;
        using SoundPtr = std::shared_ptr<Sound>;
        using SoundUPtr = std::unique_ptr<Sound>;
        using SoundSet = std::vector<SoundPtr>;
        using SoundSetIter = SoundSet::iterator;
        using SoundSetIterConst = SoundSet::const_iterator;
        inline SoundPtr makeSound() { return std::make_shared<Sound>(); }
        class Sound : public ElementInterface
        {
        public:
            Sound();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            SoundAttributesPtr getAttributes() const;
            void setAttributes( const SoundAttributesPtr& value );
            /* _________ MidiDevice minOccurs = 0, maxOccurs = 1 _________ */
            MidiDevicePtr getMidiDevice() const;
            void setMidiDevice( const MidiDevicePtr& value );
            bool getHasMidiDevice() const;
            void setHasMidiDevice( const bool value );
            /* _________ MidiInstrument minOccurs = 0, maxOccurs = 1 _________ */
            MidiInstrumentPtr getMidiInstrument() const;
            void setMidiInstrument( const MidiInstrumentPtr& value );
            bool getHasMidiInstrument() const;
            void setHasMidiInstrument( const bool value );
            /* _________ Play minOccurs = 0, maxOccurs = 1 _________ */
            PlayPtr getPlay() const;
            void setPlay( const PlayPtr& value );
            bool getHasPlay() const;
            void setHasPlay( const bool value );
        private:
            SoundAttributesPtr myAttributes;
            MidiDevicePtr myMidiDevice;
            bool myHasMidiDevice;
            MidiInstrumentPtr myMidiInstrument;
            bool myHasMidiInstrument;
            PlayPtr myPlay;
            bool myHasPlay;
        };
        /*
         4232
         <!--  ID = 4232 [4232] ------------------------->
         <!-- min=0 max=2 RangeBound  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 4 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="page-margins" type="page-margins" minOccurs="0" maxOccurs="2"/>
         
         <xs:complexType name="page-margins">
         <xs:annotation>
         <xs:documentation>Page margins are specified either for both even and odd pages, or via separate odd and even page number values. The type attribute is not needed when used as part of a print element. If omitted when the page-margins type is used in the defaults element, "both" is the default value.</xs:documentation>
         </xs:annotation>
         <xs:group ref="all-margins"/>
         <xs:attribute name="type" type="margin-type"/>
         </xs:complexType>
         
         <xs:group name="all-margins">
         <xs:annotation>
         <xs:documentation>The all-margins group specifies both horizontal and vertical margins in tenths.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="left-right-margins"/>
         <xs:element name="top-margin" type="tenths"/>
         <xs:element name="bottom-margin" type="tenths"/>
         </xs:sequence>
         </xs:group>
         
         <xs:group name="left-right-margins">
         <xs:annotation>
         <xs:documentation>The left-right-margins group specifies horizontal margins in tenths.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="left-margin" type="tenths"/>
         <xs:element name="right-margin" type="tenths"/>
         </xs:sequence>
         </xs:group> */
        
        struct PageMarginsAttributes;
        using PageMarginsAttributesPtr = std::shared_ptr<PageMarginsAttributes>;
        
        struct PageMarginsAttributes : public AttributesInterface
        {
        public:
            PageMarginsAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::MarginType type;
            bool hasType;
        };
        
        class PageMargins;
        using PageMarginsPtr = std::shared_ptr<PageMargins>;
        using PageMarginsUPtr = std::unique_ptr<PageMargins>;
        using PageMarginsSet = std::vector<PageMarginsPtr>;
        using PageMarginsSetIter = PageMarginsSet::iterator;
        using PageMarginsSetIterConst = PageMarginsSet::const_iterator;
        inline PageMarginsPtr makePageMargins() { return std::make_shared<PageMargins>(); }
        class PageMargins : public ElementInterface
        {
        public:
            PageMargins();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PageMarginsAttributesPtr getAttributes() const;
            void setAttributes( const PageMarginsAttributesPtr& value );
            /* _________ LeftMargin minOccurs = 1, maxOccurs = 1 _________ */
            LeftMarginPtr getLeftMargin() const;
            void setLeftMargin( const LeftMarginPtr& value );
            /* _________ RightMargin minOccurs = 1, maxOccurs = 1 _________ */
            RightMarginPtr getRightMargin() const;
            void setRightMargin( const RightMarginPtr& value );
            /* _________ TopMargin minOccurs = 1, maxOccurs = 1 _________ */
            TopMarginPtr getTopMargin() const;
            void setTopMargin( const TopMarginPtr& value );
            /* _________ BottomMargin minOccurs = 1, maxOccurs = 1 _________ */
            BottomMarginPtr getBottomMargin() const;
            void setBottomMargin( const BottomMarginPtr& value );
        private:
            PageMarginsAttributesPtr myAttributes;
            LeftMarginPtr myLeftMargin;
            RightMarginPtr myRightMargin;
            TopMarginPtr myTopMargin;
            BottomMarginPtr myBottomMargin;
        };
        /*
         <!--  ID = 4285 [4285] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="system-margins" type="system-margins" minOccurs="0"/>
         <xs:complexType name="system-margins">
         <xs:annotation>
         <xs:documentation>System margins are relative to the page margins. Positive values indent and negative values reduce the margin size.</xs:documentation>
         </xs:annotation>
         <xs:group ref="left-right-margins"/>
         </xs:complexType>
         <xs:group name="left-right-margins">
         <xs:annotation>
         <xs:documentation>The left-right-margins group specifies horizontal margins in tenths.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="left-margin" type="tenths"/>
         <xs:element name="right-margin" type="tenths"/>
         </xs:sequence>
         </xs:group> */
        
        class SystemMargins;
        using SystemMarginsPtr = std::shared_ptr<SystemMargins>;
        using SystemMarginsUPtr = std::unique_ptr<SystemMargins>;
        using SystemMarginsSet = std::vector<SystemMarginsPtr>;
        using SystemMarginsSetIter = SystemMarginsSet::iterator;
        using SystemMarginsSetIterConst = SystemMarginsSet::const_iterator;
        inline SystemMarginsPtr makeSystemMargins() { return std::make_shared<SystemMargins>(); }
        class SystemMargins : public ElementInterface
        {
        public:
            SystemMargins();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ LeftMargin minOccurs = 1, maxOccurs = 1 _________ */
            LeftMarginPtr getLeftMargin() const;
            void setLeftMargin( const LeftMarginPtr& value );
            /* _________ RightMargin minOccurs = 1, maxOccurs = 1 _________ */
            RightMarginPtr getRightMargin() const;
            void setRightMargin( const RightMarginPtr& value );
        private:
            LeftMarginPtr myLeftMargin;
            RightMarginPtr myRightMargin;
        };
        /* <!--  ID = 4297 [4297] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="system-dividers" type="system-dividers" minOccurs="0"/>
         <xs:complexType name="system-dividers">
         <xs:annotation>
         <xs:documentation>The system-dividers element indicates the presence or absence of system dividers (also known as system separation marks) between systems displayed on the same page. Dividers on the left and right side of the page are controlled by the left-divider and right-divider elements respectively. The default vertical position is half the system-distance value from the top of the system that is below the divider. The default horizontal position is the left and right system margin, respectively.
         
         When used in the print element, the system-dividers element affects the dividers that would appear between the current system and the previous system.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="left-divider" type="empty-print-object-style-align"/>
         <xs:element name="right-divider" type="empty-print-object-style-align"/>
         </xs:sequence>
         </xs:complexType> */
        
        class SystemDividers;
        using SystemDividersPtr = std::shared_ptr<SystemDividers>;
        using SystemDividersUPtr = std::unique_ptr<SystemDividers>;
        using SystemDividersSet = std::vector<SystemDividersPtr>;
        using SystemDividersSetIter = SystemDividersSet::iterator;
        using SystemDividersSetIterConst = SystemDividersSet::const_iterator;
        inline SystemDividersPtr makeSystemDividers() { return std::make_shared<SystemDividers>(); }
        class SystemDividers : public ElementInterface
        {
        public:
            SystemDividers();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ LeftDivider minOccurs = 1, maxOccurs = 1 _________ */
            LeftDividerPtr getLeftDivider() const;
            void setLeftDivider( const LeftDividerPtr& value );
            /* _________ RightDivider minOccurs = 1, maxOccurs = 1 _________ */
            RightDividerPtr getRightDivider() const;
            void setRightDivider( const RightDividerPtr& value );
        private:
            LeftDividerPtr myLeftDivider;
            RightDividerPtr myRightDivider;
        };
        /* <!--  ID = 4389 [4389] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::simple -->
         <!-- RecursiveSubElementCount = 0 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="strong-accent" type="strong-accent">
         <xs:annotation>
         <xs:documentation>The strong-accent element indicates a vertical accent mark.</xs:documentation>
         </xs:annotation>
         </xs:element>
         
         <xs:complexType name="strong-accent">
         <xs:annotation>
         <xs:documentation>The strong-accent type indicates a vertical accent mark. The type attribute indicates if the point of the accent is down or up.</xs:documentation>
         </xs:annotation>
         <xs:complexContent>
         <xs:extension base="empty-placement">
         <xs:attribute name="type" type="up-down" default="up"/>
         </xs:extension>
         </xs:complexContent>
         </xs:complexType>
         
         <xs:complexType name="empty-placement">
         <xs:annotation>
         <xs:documentation>The empty-placement type represents an empty element with print-style and placement attributes.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         
         <xs:attributeGroup name="print-style">
         <xs:annotation>
         <xs:documentation>The print-style attribute group collects the most popular combination of printing attributes: position, font, and color.</xs:documentation>
         </xs:annotation>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         </xs:attributeGroup>
         
         <xs:attributeGroup name="placement">
         <xs:annotation>
         <xs:documentation>The placement attribute indicates whether something is above or below another element, such as a note or a notation.</xs:documentation>
         </xs:annotation>
         <xs:attribute name="placement" type="above-below"/>
         </xs:attributeGroup> */
        
        struct StrongAccentAttributes;
        using StrongAccentAttributesPtr = std::shared_ptr<StrongAccentAttributes>;
        
        struct StrongAccentAttributes : public AttributesInterface
        {
        public:
            StrongAccentAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::AboveBelow placement;
            t::UpDown type;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasPlacement;
            bool hasType;
        };
        
        class StrongAccent;
        using StrongAccentPtr = std::shared_ptr<StrongAccent>;
        using StrongAccentUPtr = std::unique_ptr<StrongAccent>;
        using StrongAccentSet = std::vector<StrongAccentPtr>;
        using StrongAccentSetIter = StrongAccentSet::iterator;
        using StrongAccentSetIterConst = StrongAccentSet::const_iterator;
        inline StrongAccentPtr makeStrongAccent() { return std::make_shared<StrongAccent>(); }
        class StrongAccent : public ElementInterface
        {
        public:
            StrongAccent();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            StrongAccentAttributesPtr getAttributes() const;
            void setAttributes( const StrongAccentAttributesPtr& value );
        private:
            StrongAccentAttributesPtr myAttributes;
        };
        /*
         4608 <!--  ID = 4608 [4608] ------------------------->
         <!-- min=1 max=4294967295 OneOrMMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 4 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="figure" type="figure" maxOccurs="unbounded"/>
         <xs:complexType name="figure">
         <xs:annotation>
         <xs:documentation>The figure type represents a single figure within a figured-bass element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="prefix" type="style-text" minOccurs="0">
         <xs:annotation>
         <xs:documentation>Values for the prefix element include the accidental values sharp, flat, natural, double-sharp, flat-flat, and sharp-sharp. The prefix element may contain additional values for symbols specific to particular figured bass styles.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="figure-number" type="style-text" minOccurs="0">
         <xs:annotation>
         <xs:documentation>A figure-number is a number. Overstrikes of the figure number are represented in the suffix element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="suffix" type="style-text" minOccurs="0">
         <xs:annotation>
         <xs:documentation>Values for the suffix element include the accidental values sharp, flat, natural, double-sharp, flat-flat, and sharp-sharp. Suffixes include both symbols that come after the figure number and those that overstrike the figure number. The suffix value slash is used for slashed numbers indicating chromatic alteration. The orientation and display of the slash usually depends on the figure number. The suffix element may contain additional values for symbols specific to particular figured bass styles.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="extend" type="extend" minOccurs="0"/>
         </xs:sequence>
         </xs:complexType> */
        
        class Figure;
        using FigurePtr = std::shared_ptr<Figure>;
        using FigureUPtr = std::unique_ptr<Figure>;
        using FigureSet = std::vector<FigurePtr>;
        using FigureSetIter = FigureSet::iterator;
        using FigureSetIterConst = FigureSet::const_iterator;
        inline FigurePtr makeFigure() { return std::make_shared<Figure>(); }
        class Figure : public ElementInterface
        {
        public:
            Figure();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Prefix minOccurs = 0, maxOccurs = 1 _________ */
            PrefixPtr getPrefix() const;
            void setPrefix( const PrefixPtr& value );
            bool getHasPrefix() const;
            void setHasPrefix( const bool value );
            /* _________ FigureNumber minOccurs = 0, maxOccurs = 1 _________ */
            FigureNumberPtr getFigureNumber() const;
            void setFigureNumber( const FigureNumberPtr& value );
            bool getHasFigureNumber() const;
            void setHasFigureNumber( const bool value );
            /* _________ Suffix minOccurs = 0, maxOccurs = 1 _________ */
            SuffixPtr getSuffix() const;
            void setSuffix( const SuffixPtr& value );
            bool getHasSuffix() const;
            void setHasSuffix( const bool value );
            /* _________ Extend minOccurs = 0, maxOccurs = 1 _________ */
            ExtendPtr getExtend() const;
            void setExtend( const ExtendPtr& value );
            bool getHasExtend() const;
            void setHasExtend( const bool value );
        private:
            PrefixPtr myPrefix;
            bool myHasPrefix;
            FigureNumberPtr myFigureNumber;
            bool myHasFigureNumber;
            SuffixPtr mySuffix;
            bool myHasSuffix;
            ExtendPtr myExtend;
            bool myHasExtend;
        };
        /* <!--  ID = 5016 [5016] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 4 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="time-modification" type="time-modification" minOccurs="0"/>
         <xs:complexType name="time-modification">
         <xs:annotation>
         <xs:documentation>Time modification indicates tuplets, double-note tremolos, and other durational changes. A time-modification element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note type represented by the type and dot elements. Nested tuplets and other notations that use more detailed information need both the time-modification and tuplet elements to be represented accurately.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="actual-notes" type="xs:nonNegativeInteger">
         <xs:annotation>
         <xs:documentation>The actual-notes element describes how many notes are played in the time usually occupied by the number in the normal-notes element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="normal-notes" type="xs:nonNegativeInteger">
         <xs:annotation>
         <xs:documentation>The normal-notes element describes how many notes are usually played in the time occupied by the number in the actual-notes element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:sequence minOccurs="0">
         <xs:element name="normal-type" type="note-type-value">
         <xs:annotation>
         <xs:documentation>If the type associated with the number in the normal-notes element is different than the current note type (e.g., a quarter note within an eighth note triplet), then the normal-notes type (e.g. eighth) is specified in the normal-type and normal-dot elements.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="normal-dot" type="empty" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The normal-dot element is used to specify dotted normal tuplet types.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:sequence>
         </xs:complexType> */
        class NormalTypeNormalDotGroup;
        using NormalTypeNormalDotGroupPtr = std::shared_ptr<NormalTypeNormalDotGroup>;
        using NormalTypeNormalDotGroupUPtr = std::unique_ptr<NormalTypeNormalDotGroup>;
        using NormalTypeNormalDotGroupSet = std::vector<NormalTypeNormalDotGroupPtr>;
        using NormalTypeNormalDotGroupSetIter = NormalTypeNormalDotGroupSet::iterator;
        using NormalTypeNormalDotGroupSetIterConst = NormalTypeNormalDotGroupSet::const_iterator;
        inline NormalTypeNormalDotGroupPtr makeNormalTypeNormalDotGroup() { return std::make_shared<NormalTypeNormalDotGroup>(); }
        class NormalTypeNormalDotGroup : public ElementInterface
        {
        public:
            NormalTypeNormalDotGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ NormalType minOccurs = 1, maxOccurs = 1 _________ */
            NormalTypePtr getNormalType() const;
            void setNormalType( const NormalTypePtr& value );
            /* _________ NormalDot minOccurs = 0, maxOccurs = unbounded _________ */
            const NormalDotSet& getNormalDotSet() const;
            void addNormalDot( const NormalDotPtr& value );
            void removeNormalDot( const NormalDotSetIterConst& value );
            void clearNormalDotSet();
            NormalDotPtr getNormalDot( const NormalDotSetIterConst& setIterator ) const;
        private:
            NormalTypePtr myNormalType;
            NormalDotSet myNormalDotSet;
        };
        
        class TimeModification;
        using TimeModificationPtr = std::shared_ptr<TimeModification>;
        using TimeModificationUPtr = std::unique_ptr<TimeModification>;
        using TimeModificationSet = std::vector<TimeModificationPtr>;
        using TimeModificationSetIter = TimeModificationSet::iterator;
        using TimeModificationSetIterConst = TimeModificationSet::const_iterator;
        inline TimeModificationPtr makeTimeModification() { return std::make_shared<TimeModification>(); }
        class TimeModification : public ElementInterface
        {
        public:
            TimeModification();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ ActualNotes minOccurs = 1, maxOccurs = 1 _________ */
            ActualNotesPtr getActualNotes() const;
            void setActualNotes( const ActualNotesPtr& value );
            /* _________ NormalNotes minOccurs = 1, maxOccurs = 1 _________ */
            NormalNotesPtr getNormalNotes() const;
            void setNormalNotes( const NormalNotesPtr& value );
            /* _________ NormalTypeNormalDotGroup minOccurs = 0, maxOccurs = 1 _________ */
            NormalTypeNormalDotGroupPtr getNormalTypeNormalDotGroup() const;
            void setNormalTypeNormalDotGroup( const NormalTypeNormalDotGroupPtr& value );
            bool getHasNormalTypeNormalDotGroup() const;
            void setHasNormalTypeNormalDotGroup( const bool value );
        private:
            ActualNotesPtr myActualNotes;
            NormalNotesPtr myNormalNotes;
            NormalTypeNormalDotGroupPtr myNormalTypeNormalDotGroup;
            bool myHasNormalTypeNormalDotGroup;
        };
        /*
         <!--  ID = 5028 [5028] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="notehead-text" type="notehead-text" minOccurs="0"/>
         <xs:complexType name="notehead-text">
         <xs:annotation>
         <xs:documentation>The notehead-text type represents text that is displayed inside a notehead, as is done in some educational music. It is not needed for the numbers used in tablature or jianpu notation. The presence of a TAB or jianpu clefs is sufficient to indicate that numbers are used. The display-text and accidental-text elements allow display of fully formatted text and accidentals.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice maxOccurs="unbounded">
         <xs:element name="display-text" type="formatted-text"/>
         <xs:element name="accidental-text" type="accidental-text"/>
         </xs:choice>
         </xs:sequence>
         </xs:complexType> */
        
        class NoteheadText;
        using NoteheadTextPtr = std::shared_ptr<NoteheadText>;
        using NoteheadTextUPtr = std::unique_ptr<NoteheadText>;
        using NoteheadTextSet = std::vector<NoteheadTextPtr>;
        using NoteheadTextSetIter = NoteheadTextSet::iterator;
        using NoteheadTextSetIterConst = NoteheadTextSet::const_iterator;
        inline NoteheadTextPtr makeNoteheadText() { return std::make_shared<NoteheadText>(); }
        class NoteheadText : public ElementInterface
        {
        public:
            NoteheadText();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ DisplayText minOccurs = 1, maxOccurs = 1 _________ */
            DisplayTextPtr getDisplayText() const;
            void setDisplayText( const DisplayTextPtr& value );
            /* _________ AccidentalText minOccurs = 1, maxOccurs = 1 _________ */
            AccidentalTextPtr getAccidentalText() const;
            void setAccidentalText( const AccidentalTextPtr& value );
        private:
            DisplayTextPtr myDisplayText;
            AccidentalTextPtr myAccidentalText;
        };
        /*
         <!--  ID = 4935 [4935] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 16 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="articulations" type="articulations"/>
         <xs:complexType name="articulations">
         <xs:annotation>
         <xs:documentation>Articulations and accents are grouped together here.</xs:documentation>
         </xs:annotation>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="accent" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The accent element indicates a regular horizontal accent mark.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="strong-accent" type="strong-accent">
         <xs:annotation>
         <xs:documentation>The strong-accent element indicates a vertical accent mark.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="staccato" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The staccato element is used for a dot articulation, as opposed to a stroke or a wedge.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="tenuto" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The tenuto element indicates a tenuto line symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="detached-legato" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The detached-legato element indicates the combination of a tenuto line and staccato dot symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="staccatissimo" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The staccatissimo element is used for a wedge articulation, as opposed to a dot or a stroke.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="spiccato" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The spiccato element is used for a stroke articulation, as opposed to a dot or a wedge.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="scoop" type="empty-line">
         <xs:annotation>
         <xs:documentation>The scoop element is an indeterminate slide attached to a single note. The scoop element appears before the main note and comes from below the main pitch.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="plop" type="empty-line">
         <xs:annotation>
         <xs:documentation>The plop element is an indeterminate slide attached to a single note. The plop element appears before the main note and comes from above the main pitch.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="doit" type="empty-line">
         <xs:annotation>
         <xs:documentation>The doit element is an indeterminate slide attached to a single note. The doit element appears after the main note and goes above the main pitch.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="falloff" type="empty-line">
         <xs:annotation>
         <xs:documentation>The falloff element is an indeterminate slide attached to a single note. The falloff element appears before the main note and goes below the main pitch.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="breath-mark" type="breath-mark"/>
         <xs:element name="caesura" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The caesura element indicates a slight pause. It is notated using a "railroad tracks" symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="stress" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The stress element indicates a stressed note.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="unstress" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The unstress element indicates an unstressed note. It is often notated using a u-shaped symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="other-articulation" type="placement-text">
         <xs:annotation>
         <xs:documentation>The other-articulation element is used to define any articulations not yet in the MusicXML format. This allows extended representation, though without application interoperability.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:choice>
         </xs:complexType> */
        
        class ArticulationsChoice;
        using ArticulationsChoicePtr = std::shared_ptr<ArticulationsChoice>;
        using ArticulationsChoiceUPtr = std::unique_ptr<ArticulationsChoice>;
        using ArticulationsChoiceSet = std::vector<ArticulationsChoicePtr>;
        using ArticulationsChoiceSetIter = ArticulationsChoiceSet::iterator;
        using ArticulationsChoiceSetIterConst = ArticulationsChoiceSet::const_iterator;
        inline ArticulationsChoicePtr makeArticulationsChoice() { return std::make_shared<ArticulationsChoice>(); }
        class ArticulationsChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                accent = 1,
                strongAccent = 2,
                staccato = 3,
                tenuto = 4,
                detachedLegato = 5,
                stacatissimo = 6,
                spiccato = 7,
                scoop = 8,
                plop = 9,
                doit = 10,
                falloff = 11,
                breathMark = 12,
                caesura = 13,
                stress = 14,
                unstress = 15,
                otherArticulation = 16
            };
            ArticulationsChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice minOccurs = 1, maxOccurs = 1 _________ */
            ArticulationsChoice::Choice getChoice() const;
            void setChoice( const ArticulationsChoice::Choice value );
            /* _________ Accent minOccurs = 1, maxOccurs = 1 _________ */
            AccentPtr getAccent() const;
            void setAccent( const AccentPtr& value );
            /* _________ StrongAccent minOccurs = 1, maxOccurs = 1 _________ */
            StrongAccentPtr getStrongAccent() const;
            void setStrongAccent( const StrongAccentPtr& value );
            /* _________ Staccato minOccurs = 1, maxOccurs = 1 _________ */
            StaccatoPtr getStaccato() const;
            void setStaccato( const StaccatoPtr& value );
            /* _________ Tenuto minOccurs = 1, maxOccurs = 1 _________ */
            TenutoPtr getTenuto() const;
            void setTenuto( const TenutoPtr& value );
            /* _________ DetachedLegato minOccurs = 1, maxOccurs = 1 _________ */
            DetachedLegatoPtr getDetachedLegato() const;
            void setDetachedLegato( const DetachedLegatoPtr& value );
            /* _________ Staccatissimo minOccurs = 1, maxOccurs = 1 _________ */
            StaccatissimoPtr getStaccatissimo() const;
            void setStaccatissimo( const StaccatissimoPtr& value );
            /* _________ Spiccato minOccurs = 1, maxOccurs = 1 _________ */
            SpiccatoPtr getSpiccato() const;
            void setSpiccato( const SpiccatoPtr& value );
            /* _________ Scoop minOccurs = 1, maxOccurs = 1 _________ */
            ScoopPtr getScoop() const;
            void setScoop( const ScoopPtr& value );
            /* _________ Plop minOccurs = 1, maxOccurs = 1 _________ */
            PlopPtr getPlop() const;
            void setPlop( const PlopPtr& value );
            /* _________ Doit minOccurs = 1, maxOccurs = 1 _________ */
            DoitPtr getDoit() const;
            void setDoit( const DoitPtr& value );
            /* _________ Falloff minOccurs = 1, maxOccurs = 1 _________ */
            FalloffPtr getFalloff() const;
            void setFalloff( const FalloffPtr& value );
            /* _________ BreathMark minOccurs = 1, maxOccurs = 1 _________ */
            BreathMarkPtr getBreathMark() const;
            void setBreathMark( const BreathMarkPtr& value );
            /* _________ Caesura minOccurs = 1, maxOccurs = 1 _________ */
            CaesuraPtr getCaesura() const;
            void setCaesura( const CaesuraPtr& value );
            /* _________ Stress minOccurs = 1, maxOccurs = 1 _________ */
            StressPtr getStress() const;
            void setStress( const StressPtr& value );
            /* _________ Unstress minOccurs = 1, maxOccurs = 1 _________ */
            UnstressPtr getUnstress() const;
            void setUnstress( const UnstressPtr& value );
            /* _________ OtherArticulation minOccurs = 1, maxOccurs = 1 _________ */
            OtherArticulationPtr getOtherArticulation() const;
            void setOtherArticulation( const OtherArticulationPtr& value );
        private:
            Choice myChoice;
            AccentPtr myAccent;
            StrongAccentPtr myStrongAccent;
            StaccatoPtr myStaccato;
            TenutoPtr myTenuto;
            DetachedLegatoPtr myDetachedLegato;
            StaccatissimoPtr myStaccatissimo;
            SpiccatoPtr mySpiccato;
            ScoopPtr myScoop;
            PlopPtr myPlop;
            DoitPtr myDoit;
            FalloffPtr myFalloff;
            BreathMarkPtr myBreathMark;
            CaesuraPtr myCaesura;
            StressPtr myStress;
            UnstressPtr myUnstress;
            OtherArticulationPtr myOtherArticulation;
        };
        class Articulations;
        using ArticulationsPtr = std::shared_ptr<Articulations>;
        using ArticulationsUPtr = std::unique_ptr<Articulations>;
        using ArticulationsSet = std::vector<ArticulationsPtr>;
        using ArticulationsSetIter = ArticulationsSet::iterator;
        using ArticulationsSetIterConst = ArticulationsSet::const_iterator;
        inline ArticulationsPtr makeArticulations() { return std::make_shared<Articulations>(); }
        class Articulations : public ElementInterface
        {
        public:
            Articulations();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ ArticulationsChoice minOccurs = 0, maxOccurs = unbounded _________ */
            const ArticulationsChoiceSet& getArticulationsChoiceSet() const;
            void addArticulationsChoice( const ArticulationsChoicePtr& value );
            void removeArticulationsChoice( const ArticulationsChoiceSetIterConst& value );
            void clearArticulationsChoiceSet();
            ArticulationsChoicePtr getArticulationsChoice( const ArticulationsChoiceSetIterConst& setIterator ) const;
        private:
            ArticulationsChoiceSet myArticulationsChoiceSet;
        };
        
        /* <!--  ID = 5045 [5045] ------------------------->
         <!-- min=0 max=4294967295 ZeroOrMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 13 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="lyric" type="lyric" minOccurs="0" maxOccurs="unbounded"/>
         
         <xs:complexType name="lyric">
         <xs:annotation>
         <xs:documentation>The lyric type represents text underlays for lyrics, based on Humdrum with support for other formats. Two text elements that are not separated by an elision element are part of the same syllable, but may have different text formatting. The MusicXML 2.0 XSD is more strict than the 2.0 DTD in enforcing this by disallowing a second syllabic element unless preceded by an elision element. The lyric number indicates multiple lines, though a name can be used as well (as in Finale's verse / chorus / section specification). Justification is center by default placement is below by default. The content of the elision type is used to specify the symbol used to display the elision. Common values are a no-break space (Unicode 00A0), an underscore (Unicode 005F), or an undertie (Unicode 203F).</xs:documentation>
         </xs:annotation>
         
         <xs:sequence>
         <xs:choice> <!-- LyricTextChoice -->
         <xs:sequence> <!-- SyllabicTextGroup -->
         <xs:element name="syllabic" type="syllabic" minOccurs="0"/>
         <xs:element name="text" type="text-element-data"/>
         <xs:sequence minOccurs="0" maxOccurs="unbounded">
         <xs:sequence minOccurs="0"> <!-- ElisionSyllabicGroup -->
         <xs:element name="elision" type="text-font-color"/>
         <xs:element name="syllabic" type="syllabic" minOccurs="0"/>
         </xs:sequence>
         <xs:element name="text" type="text-element-data"/>
         </xs:sequence> <!-- /SyllabicTextGroup -->
         <xs:element name="extend" type="extend" minOccurs="0"/>
         </xs:sequence> <!-- /SyllabicTextGroup -->
         <xs:element name="extend" type="extend"/>
         <xs:element name="laughing" type="empty">
         <xs:annotation>
         <xs:documentation>The laughing element is taken from Humdrum.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="humming" type="empty">
         <xs:annotation>
         <xs:documentation>The humming element is taken from Humdrum.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:choice> <!-- /LyricTextChoice -->
         <xs:element name="end-line" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The end-line element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric display for Karaoke and similar applications.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="end-paragraph" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The end-paragraph element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric display for Karaoke and similar applications.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:group ref="editorial"/> <!-- EditorialGroup -->
         </xs:sequence>
         
         <xs:attribute name="number" type="xs:NMTOKEN"/>
         <xs:attribute name="name" type="xs:token"/>
         <xs:attributeGroup ref="justify"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="color"/>
         <xs:attributeGroup ref="print-object"/>
         </xs:complexType>
         
         <xs:group name="editorial"> <!-- EditorialGroup -->
         <xs:annotation>
         <xs:documentation>The editorial group specifies editorial information for a musical element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         </xs:sequence>
         </xs:group>
         
         <xs:group name="footnote">
         <xs:annotation>
         <xs:documentation>The footnote element specifies editorial information that appears in footnotes in the printed score. It is defined within a group due to its multiple uses within the MusicXML schema.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="footnote" type="formatted-text"/>
         </xs:sequence>
         </xs:group>
         
         <xs:group name="level">
         <xs:annotation>
         <xs:documentation>The level element specifies editorial information for different MusicXML elements. It is defined within a group due to its multiple uses within the MusicXML schema.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="level" type="level"/>
         </xs:sequence>
         </xs:group> */
        
        class ElisionSyllabicGroup;
        using ElisionSyllabicGroupPtr = std::shared_ptr<ElisionSyllabicGroup>;
        using ElisionSyllabicGroupUPtr = std::unique_ptr<ElisionSyllabicGroup>;
        using ElisionSyllabicGroupSet = std::vector<ElisionSyllabicGroupPtr>;
        using ElisionSyllabicGroupSetIter = ElisionSyllabicGroupSet::iterator;
        using ElisionSyllabicGroupSetIterConst = ElisionSyllabicGroupSet::const_iterator;
        inline ElisionSyllabicGroupPtr makeElisionSyllabicGroup() { return std::make_shared<ElisionSyllabicGroup>(); }
        class ElisionSyllabicGroup : public ElementInterface
        {
        public:
            ElisionSyllabicGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Elision minOccurs = 1, maxOccurs = 1 _________ */
            ElisionPtr getElision() const;
            void setElision( const ElisionPtr& value );
            /* _________ Syllabic minOccurs = 0, maxOccurs = 1 _________ */
            SyllabicPtr getSyllabic() const;
            void setSyllabic( const SyllabicPtr& value );
            bool getHasSyllabic() const;
            void setHasSyllabic( const bool value );
        private:
            ElisionPtr myElision;
            SyllabicPtr mySyllabic;
            bool myHasSyllabic;
        };
        
        class ElisionSyllabicTextGroup;
        using ElisionSyllabicTextGroupPtr = std::shared_ptr<ElisionSyllabicTextGroup>;
        using ElisionSyllabicTextGroupUPtr = std::unique_ptr<ElisionSyllabicTextGroup>;
        using ElisionSyllabicTextGroupSet = std::vector<ElisionSyllabicTextGroupPtr>;
        using ElisionSyllabicTextGroupSetIter = ElisionSyllabicTextGroupSet::iterator;
        using ElisionSyllabicTextGroupSetIterConst = ElisionSyllabicTextGroupSet::const_iterator;
        inline ElisionSyllabicTextGroupPtr makeElisionSyllabicTextGroup() { return std::make_shared<ElisionSyllabicTextGroup>(); }
        class ElisionSyllabicTextGroup : public ElementInterface
        {
        public:
            ElisionSyllabicTextGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ ElisionSyllabicGroup minOccurs = 0, maxOccurs = 1 _________ */
            ElisionSyllabicGroupPtr getElisionSyllabicGroup() const;
            void setElisionSyllabicGroup( const ElisionSyllabicGroupPtr& value );
            bool getHasElisionSyllabicGroup() const;
            void setHasElisionSyllabicGroup( const bool value );
            /* _________ Text minOccurs = 1, maxOccurs = 1 _________ */
            TextPtr getText() const;
            void setText( const TextPtr& value );
        private:
            ElisionSyllabicGroupPtr myElisionSyllabicGroup;
            bool myHasElisionSyllabicGroup;
            TextPtr myText;
        };
        
        
        class SyllabicTextGroup;
        using SyllabicTextGroupPtr = std::shared_ptr<SyllabicTextGroup>;
        using SyllabicTextGroupUPtr = std::unique_ptr<SyllabicTextGroup>;
        using SyllabicTextGroupSet = std::vector<SyllabicTextGroupPtr>;
        using SyllabicTextGroupSetIter = SyllabicTextGroupSet::iterator;
        using SyllabicTextGroupSetIterConst = SyllabicTextGroupSet::const_iterator;
        inline SyllabicTextGroupPtr makeSyllabicTextGroup() { return std::make_shared<SyllabicTextGroup>(); }
        class SyllabicTextGroup : public ElementInterface
        {
        public:
            SyllabicTextGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Syllabic minOccurs = 0, maxOccurs = 1 _________ */
            SyllabicPtr getSyllabic() const;
            void setSyllabic( const SyllabicPtr& value );
            bool getHasSyllabic() const;
            void setHasSyllabic( const bool value );
            /* _________ Text minOccurs = 1, maxOccurs = 1 _________ */
            TextPtr getText() const;
            void setText( const TextPtr& value );
            /* _________ ElisionSyllabicTextGroup minOccurs = 0, maxOccurs = unbounded _________ */
            const ElisionSyllabicTextGroupSet& getElisionSyllabicTextGroupSet() const;
            void addElisionSyllabicTextGroup( const ElisionSyllabicTextGroupPtr& value );
            void removeElisionSyllabicTextGroup( const ElisionSyllabicTextGroupSetIterConst& value );
            void clearElisionSyllabicTextGroupSet();
            ElisionSyllabicTextGroupPtr getElisionSyllabicTextGroup( const ElisionSyllabicTextGroupSetIterConst& setIterator ) const;
            /* _________ Extend minOccurs = 0, maxOccurs = 1 _________ */
            ExtendPtr getExtend() const;
            void setExtend( const ExtendPtr& value );
            bool getHasExtend() const;
            void setHasExtend( const bool value );
        private:
            SyllabicPtr mySyllabic;
            bool myHasSyllabic;
            TextPtr myText;
            ElisionSyllabicTextGroupSet myElisionSyllabicTextGroupSet;
            ExtendPtr myExtend;
            bool myHasExtend;
        };
        
        
        class LyricTextChoice;
        using LyricTextChoicePtr = std::shared_ptr<LyricTextChoice>;
        using LyricTextChoiceUPtr = std::unique_ptr<LyricTextChoice>;
        using LyricTextChoiceSet = std::vector<LyricTextChoicePtr>;
        using LyricTextChoiceSetIter = LyricTextChoiceSet::iterator;
        using LyricTextChoiceSetIterConst = LyricTextChoiceSet::const_iterator;
        inline LyricTextChoicePtr makeLyricTextChoice() { return std::make_shared<LyricTextChoice>(); }
        class LyricTextChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                syllabicTextGroup = 1,
                extend = 2,
                laughing = 3,
                humming = 4
            };
            LyricTextChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            LyricTextChoice::Choice getChoice() const;
            void setChoice( const LyricTextChoice::Choice value );
            /* _________ SyllabicTextGroup minOccurs = 1, maxOccurs = 1 _________ */
            SyllabicTextGroupPtr getSyllabicTextGroup() const;
            void setSyllabicTextGroup( const SyllabicTextGroupPtr& value );
            /* _________ Extend minOccurs = 1, maxOccurs = 1 _________ */
            ExtendPtr getExtend() const;
            void setExtend( const ExtendPtr& value );
            /* _________ Laughing minOccurs = 1, maxOccurs = 1 _________ */
            LaughingPtr getLaughing() const;
            void setLaughing( const LaughingPtr& value );
            /* _________ Humming minOccurs = 1, maxOccurs = 1 _________ */
            HummingPtr getHumming() const;
            void setHumming( const HummingPtr& value );
        private:
            Choice myChoice;
            SyllabicTextGroupPtr mySyllabicTextGroup;
            ExtendPtr myExtend;
            LaughingPtr myLaughing;
            HummingPtr myHumming;
        };
        
        
        class EditorialGroup;
        using EditorialGroupPtr = std::shared_ptr<EditorialGroup>;
        using EditorialGroupUPtr = std::unique_ptr<EditorialGroup>;
        using EditorialGroupSet = std::vector<EditorialGroupPtr>;
        using EditorialGroupSetIter = EditorialGroupSet::iterator;
        using EditorialGroupSetIterConst = EditorialGroupSet::const_iterator;
        inline EditorialGroupPtr makeEditorialGroup() { return std::make_shared<EditorialGroup>(); }
        class EditorialGroup : public ElementInterface
        {
        public:
            EditorialGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Footnote minOccurs = 0, maxOccurs = 1 _________ */
            FootnotePtr getFootnote() const;
            void setFootnote( const FootnotePtr& value );
            bool getHasFootnote() const;
            void setHasFootnote( const bool value );
            /* _________ Level minOccurs = 0, maxOccurs = 1 _________ */
            LevelPtr getLevel() const;
            void setLevel( const LevelPtr& value );
            bool getHasLevel() const;
            void setHasLevel( const bool value );
        private:
            FootnotePtr myFootnote;
            bool myHasFootnote;
            LevelPtr myLevel;
            bool myHasLevel;
        };
        
        class EditorialVoiceGroup;
        using EditorialVoiceGroupPtr = std::shared_ptr<EditorialVoiceGroup>;
        using EditorialVoiceGroupUPtr = std::unique_ptr<EditorialVoiceGroup>;
        using EditorialVoiceGroupSet = std::vector<EditorialVoiceGroupPtr>;
        using EditorialVoiceGroupSetIter = EditorialVoiceGroupSet::iterator;
        using EditorialVoiceGroupSetIterConst = EditorialVoiceGroupSet::const_iterator;
        inline EditorialVoiceGroupPtr makeEditorialVoiceGroup() { return std::make_shared<EditorialVoiceGroup>(); }
        class EditorialVoiceGroup : public ElementInterface
        {
        public:
            EditorialVoiceGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Footnote minOccurs = 0, maxOccurs = 1 _________ */
            FootnotePtr getFootnote() const;
            void setFootnote( const FootnotePtr& value );
            bool getHasFootnote() const;
            void setHasFootnote( const bool value );
            /* _________ Level minOccurs = 0, maxOccurs = 1 _________ */
            LevelPtr getLevel() const;
            void setLevel( const LevelPtr& value );
            bool getHasLevel() const;
            void setHasLevel( const bool value );
            /* _________ Voice minOccurs = 0, maxOccurs = 1 _________ */
            VoicePtr getVoice() const;
            void setVoice( const VoicePtr& value );
            bool getHasVoice() const;
            void setHasVoice( const bool value );
        private:
            FootnotePtr myFootnote;
            bool myHasFootnote;
            LevelPtr myLevel;
            bool myHasLevel;
            VoicePtr myVoice;
            bool myHasVoice;
        };
        
        struct LyricAttributes;
        using LyricAttributesPtr = std::shared_ptr<LyricAttributes>;
        
        struct LyricAttributes : public AttributesInterface
        {
        public:
            LyricAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsNMToken number;
            t::XsToken name;
            t::LeftCenterRight justify;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::AboveBelow placement;
            t::Color color;
            t::YesNo printObject;
            bool hasNumber;
            bool hasName;
            bool hasJustify;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasPlacement;
            bool hasColor;
            bool hasPrintObject;
        };
        
        class Lyric;
        using LyricPtr = std::shared_ptr<Lyric>;
        using LyricUPtr = std::unique_ptr<Lyric>;
        using LyricSet = std::vector<LyricPtr>;
        using LyricSetIter = LyricSet::iterator;
        using LyricSetIterConst = LyricSet::const_iterator;
        inline LyricPtr makeLyric() { return std::make_shared<Lyric>(); }
        class Lyric : public ElementInterface
        {
        public:
            Lyric();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            LyricAttributesPtr getAttributes() const;
            void setAttributes( const LyricAttributesPtr& value );
            /* _________ LyricTextChoice minOccurs = 1, maxOccurs = 1 _________ */
            LyricTextChoicePtr getLyricTextChoice() const;
            void setLyricTextChoice( const LyricTextChoicePtr& value );
            /* _________ EndLine minOccurs = 0, maxOccurs = 1 _________ */
            EndLinePtr getEndLine() const;
            void setEndLine( const EndLinePtr& value );
            bool getHasEndLine() const;
            void setHasEndLine( const bool value );
            /* _________ EndParagraph minOccurs = 0, maxOccurs = 1 _________ */
            EndParagraphPtr getEndParagraph() const;
            void setEndParagraph( const EndParagraphPtr& value );
            bool getHasEndParagraph() const;
            void setHasEndParagraph( const bool value );
            /* _________ EditorialGroup minOccurs = 1, maxOccurs = 1 _________ */
            EditorialGroupPtr getEditorialGroup() const;
            void setEditorialGroup( const EditorialGroupPtr& value );
        private:
            LyricAttributesPtr myAttributes;
            LyricTextChoicePtr myLyricTextChoice;
            EndLinePtr myEndLine;
            bool myHasEndLine;
            EndParagraphPtr myEndParagraph;
            bool myHasEndParagraph;
            EditorialGroupPtr myEditorialGroup;
        };
        
        
        /*
         <!--  ID = 5166 [5166] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::simple -->
         <!-- RecursiveSubElementCount = 0 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="mordent" type="mordent">
         <xs:annotation>
         <xs:documentation>The mordent element represents the sign with the vertical line. The long attribute is "no" by default.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="mordent">
         <xs:annotation>
         <xs:documentation>The mordent type is used for both represents the mordent sign with the vertical line and the inverted-mordent sign without the line. The long attribute is "no" by default. The approach and departure attributes are used for compound ornaments, indicating how the beginning and ending of the ornament look relative to the main part of the mordent.</xs:documentation>
         </xs:annotation>
         <xs:complexContent>
         <xs:extension base="empty-trill-sound">
         <xs:attribute name="long" type="yes-no"/>
         <xs:attribute name="approach" type="above-below"/>
         <xs:attribute name="departure" type="above-below"/>
         </xs:extension>
         </xs:complexContent>
         </xs:complexType> */
        
        struct MordentAttributes;
        using MordentAttributesPtr = std::shared_ptr<MordentAttributes>;
        
        struct MordentAttributes : public AttributesInterface
        {
        public:
            MordentAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::AboveBelow placement;
            t::StartNote startNote;
            t::TrillStep trillStep;
            t::TwoNoteTurn twoNoteTurn;
            t::YesNo accelerate;
            t::TrillBeats beats;
            t::Percent secondBeat;
            t::Percent lastBeat;
            t::YesNo long_;
            t::AboveBelow approach;
            t::AboveBelow departure;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasPlacement;
            bool hasStartNote;
            bool hasTrillStep;
            bool hasTwoNoteTurn;
            bool hasAccelerate;
            bool hasBeats;
            bool hasSecondBeat;
            bool hasLastBeat;
            bool hasLong;
            bool hasApproach;
            bool hasDeparture;
        };
        
        
        
        class Mordent;
        using MordentPtr = std::shared_ptr<Mordent>;
        using MordentUPtr = std::unique_ptr<Mordent>;
        using MordentSet = std::vector<MordentPtr>;
        using MordentSetIter = MordentSet::iterator;
        using MordentSetIterConst = MordentSet::const_iterator;
        inline MordentPtr makeMordent() { return std::make_shared<Mordent>(); }
        class Mordent : public ElementInterface
        {
        public:
            Mordent();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MordentAttributesPtr getAttributes() const;
            void setAttributes( const MordentAttributesPtr& value );
        private:
            MordentAttributesPtr myAttributes;
        };
        
        /*<!--  ID = 5171 [5171] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::simple -->
         <!-- RecursiveSubElementCount = 0 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="inverted-mordent" type="mordent">
         <xs:annotation>
         <xs:documentation>The inverted-mordent element represents the sign without the vertical line. The long attribute is "no" by default.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="mordent">
         <xs:annotation>
         <xs:documentation>The mordent type is used for both represents the mordent sign with the vertical line and the inverted-mordent sign without the line. The long attribute is "no" by default. The approach and departure attributes are used for compound ornaments, indicating how the beginning and ending of the ornament look relative to the main part of the mordent.</xs:documentation>
         </xs:annotation>
         <xs:complexContent>
         <xs:extension base="empty-trill-sound">
         <xs:attribute name="long" type="yes-no"/>
         <xs:attribute name="approach" type="above-below"/>
         <xs:attribute name="departure" type="above-below"/>
         </xs:extension>
         </xs:complexContent>
         </xs:complexType> */
        
        using InvertedMordentAttributes = MordentAttributes;
        using InvertedMordentAttributesPtr = std::shared_ptr<InvertedMordentAttributes>;
        
        class InvertedMordent;
        using InvertedMordentPtr = std::shared_ptr<InvertedMordent>;
        using InvertedMordentUPtr = std::unique_ptr<InvertedMordent>;
        using InvertedMordentSet = std::vector<InvertedMordentPtr>;
        using InvertedMordentSetIter = InvertedMordentSet::iterator;
        using InvertedMordentSetIterConst = InvertedMordentSet::const_iterator;
        inline InvertedMordentPtr makeInvertedMordent() { return std::make_shared<InvertedMordent>(); }
        class InvertedMordent : public ElementInterface
        {
        public:
            InvertedMordent();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            InvertedMordentAttributesPtr getAttributes() const;
            void setAttributes( const InvertedMordentAttributesPtr& value );
        private:
            InvertedMordentAttributesPtr myAttributes;
        };
        
        /* <!--  ID = 5410 [5410] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::simple -->
         <!-- RecursiveSubElementCount = 0 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="heel" type="heel-toe"/>
         <xs:complexType name="heel-toe">
         <xs:annotation>
         <xs:documentation>The heel and toe elements are used with organ pedals. The substitution value is "no" if the attribute is not present.</xs:documentation>
         </xs:annotation>
         <xs:complexContent>
         <xs:extension base="empty-placement">
         <xs:attribute name="substitution" type="yes-no"/>
         </xs:extension>
         </xs:complexContent>
         </xs:complexType> */
        
        struct HeelAttributes;
        using HeelAttributesPtr = std::shared_ptr<HeelAttributes>;
        
        struct HeelAttributes : public AttributesInterface
        {
        public:
            HeelAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::AboveBelow placement;
            t::YesNo substitution;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasPlacement;
            bool hasSubstitution;
        };
        
        class Heel;
        using HeelPtr = std::shared_ptr<Heel>;
        using HeelUPtr = std::unique_ptr<Heel>;
        using HeelSet = std::vector<HeelPtr>;
        using HeelSetIter = HeelSet::iterator;
        using HeelSetIterConst = HeelSet::const_iterator;
        inline HeelPtr makeHeel() { return std::make_shared<Heel>(); }
        class Heel : public ElementInterface
        {
        public:
            Heel();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            HeelAttributesPtr getAttributes() const;
            void setAttributes( const HeelAttributesPtr& value );
        private:
            HeelAttributesPtr myAttributes;
        };
        
        /* <!--  ID = 5413 [5413] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::simple -->
         <!-- RecursiveSubElementCount = 0 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="toe" type="heel-toe"/>
         <xs:complexType name="heel-toe">
         <xs:annotation>
         <xs:documentation>The heel and toe elements are used with organ pedals. The substitution value is "no" if the attribute is not present.</xs:documentation>
         </xs:annotation>
         <xs:complexContent>
         <xs:extension base="empty-placement">
         <xs:attribute name="substitution" type="yes-no"/>
         </xs:extension>
         </xs:complexContent>
         </xs:complexType> */
        
        using ToeAttributes = HeelAttributes;
        using ToeAttributesPtr = HeelAttributesPtr;
        
        class Toe;
        using ToePtr = std::shared_ptr<Toe>;
        using ToeUPtr = std::unique_ptr<Toe>;
        using ToeSet = std::vector<ToePtr>;
        using ToeSetIter = ToeSet::iterator;
        using ToeSetIterConst = ToeSet::const_iterator;
        inline ToePtr makeToe() { return std::make_shared<Toe>(); }
        class Toe : public ElementInterface
        {
        public:
            Toe();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            ToeAttributesPtr getAttributes() const;
            void setAttributes( const ToeAttributesPtr& value );
        private:
            ToeAttributesPtr myAttributes;
        };
        
        /* !--  ID = 5421 [5421] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 3 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="hole" type="hole"/>
         <xs:complexType name="hole">
         <xs:annotation>
         <xs:documentation>The hole type represents the symbols used for woodwind and brass fingerings as well as other notations.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="hole-type" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The content of the optional hole-type element indicates what the hole symbol represents in terms of instrument fingering or other techniques.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="hole-closed" type="hole-closed"/>
         <xs:element name="hole-shape" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The optional hole-shape element indicates the shape of the hole symbol; the default is a circle.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType> */
        
        struct HoleAttributes;
        using HoleAttributesPtr = std::shared_ptr<HoleAttributes>;
        
        struct HoleAttributes : public AttributesInterface
        {
        public:
            HoleAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasPlacement;
        };
        
        class Hole;
        using HolePtr = std::shared_ptr<Hole>;
        using HoleUPtr = std::unique_ptr<Hole>;
        using HoleSet = std::vector<HolePtr>;
        using HoleSetIter = HoleSet::iterator;
        using HoleSetIterConst = HoleSet::const_iterator;
        inline HolePtr makeHole() { return std::make_shared<Hole>(); }
        class Hole : public ElementInterface
        {
        public:
            Hole();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            HoleAttributesPtr getAttributes() const;
            void setAttributes( const HoleAttributesPtr& value );
            /* _________ HoleType minOccurs = 0, maxOccurs = 1 _________ */
            HoleTypePtr getHoleType() const;
            void setHoleType( const HoleTypePtr& value );
            bool getHasHoleType() const;
            void setHasHoleType( const bool value );
            /* _________ HoleClosed minOccurs = 1, maxOccurs = 1 _________ */
            HoleClosedPtr getHoleClosed() const;
            void setHoleClosed( const HoleClosedPtr& value );
            /* _________ HoleShape minOccurs = 0, maxOccurs = 1 _________ */
            HoleShapePtr getHoleShape() const;
            void setHoleShape( const HoleShapePtr& value );
            bool getHasHoleShape() const;
            void setHasHoleShape( const bool value );
        private:
            HoleAttributesPtr myAttributes;
            HoleTypePtr myHoleType;
            bool myHasHoleType;
            HoleClosedPtr myHoleClosed;
            HoleShapePtr myHoleShape;
            bool myHasHoleShape;
        };
        /* <!--  ID = 5562 [5562] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 3 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="tuplet-actual" type="tuplet-portion" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The tuplet-actual element provide optional full control over how the actual part of the tuplet is displayed, including number and note type (with dots). If any of these elements are absent, their values are based on the time-modification element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="tuplet-portion">
         <xs:annotation>
         <xs:documentation>The tuplet-portion type provides optional full control over tuplet specifications. It allows the number and note type (including dots) to be set for the actual and normal portions of a single tuplet. If any of these elements are absent, their values are based on the time-modification element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="tuplet-number" type="tuplet-number" minOccurs="0"/>
         <xs:element name="tuplet-type" type="tuplet-type" minOccurs="0"/>
         <xs:element name="tuplet-dot" type="tuplet-dot" minOccurs="0" maxOccurs="unbounded"/>
         </xs:sequence>
         </xs:complexType> */
        
        class TupletActual;
        using TupletActualPtr = std::shared_ptr<TupletActual>;
        using TupletActualUPtr = std::unique_ptr<TupletActual>;
        using TupletActualSet = std::vector<TupletActualPtr>;
        using TupletActualSetIter = TupletActualSet::iterator;
        using TupletActualSetIterConst = TupletActualSet::const_iterator;
        inline TupletActualPtr makeTupletActual() { return std::make_shared<TupletActual>(); }
        class TupletActual : public ElementInterface
        {
        public:
            TupletActual();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ TupletNumber minOccurs = 0, maxOccurs = 1 _________ */
            TupletNumberPtr getTupletNumber() const;
            void setTupletNumber( const TupletNumberPtr& value );
            bool getHasTupletNumber() const;
            void setHasTupletNumber( const bool value );
            /* _________ TupletType minOccurs = 0, maxOccurs = 1 _________ */
            TupletTypePtr getTupletType() const;
            void setTupletType( const TupletTypePtr& value );
            bool getHasTupletType() const;
            void setHasTupletType( const bool value );
            /* _________ TupletDot minOccurs = 0, maxOccurs = unbounded _________ */
            const TupletDotSet& getTupletDotSet() const;
            void addTupletDot( const TupletDotPtr& value );
            void removeTupletDot( const TupletDotSetIterConst& value );
            void clearTupletDotSet();
            TupletDotPtr getTupletDot( const TupletDotSetIterConst& setIterator ) const;
        private:
            TupletNumberPtr myTupletNumber;
            bool myHasTupletNumber;
            TupletTypePtr myTupletType;
            bool myHasTupletType;
            TupletDotSet myTupletDotSet;
        };
        
        /* <!--  ID = 5568 [5568] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 3 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="tuplet-normal" type="tuplet-portion" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The tuplet-normal element provide optional full control over how the normal part of the tuplet is displayed, including number and note type (with dots). If any of these elements are absent, their values are based on the time-modification element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="tuplet-portion">
         <xs:annotation>
         <xs:documentation>The tuplet-portion type provides optional full control over tuplet specifications. It allows the number and note type (including dots) to be set for the actual and normal portions of a single tuplet. If any of these elements are absent, their values are based on the time-modification element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="tuplet-number" type="tuplet-number" minOccurs="0"/>
         <xs:element name="tuplet-type" type="tuplet-type" minOccurs="0"/>
         <xs:element name="tuplet-dot" type="tuplet-dot" minOccurs="0" maxOccurs="unbounded"/>
         </xs:sequence>
         </xs:complexType> */
        
        class TupletNormal;
        using TupletNormalPtr = std::shared_ptr<TupletNormal>;
        using TupletNormalUPtr = std::unique_ptr<TupletNormal>;
        using TupletNormalSet = std::vector<TupletNormalPtr>;
        using TupletNormalSetIter = TupletNormalSet::iterator;
        using TupletNormalSetIterConst = TupletNormalSet::const_iterator;
        inline TupletNormalPtr makeTupletNormal() { return std::make_shared<TupletNormal>(); }
        class TupletNormal : public ElementInterface
        {
        public:
            TupletNormal();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ TupletNumber minOccurs = 0, maxOccurs = 1 _________ */
            TupletNumberPtr getTupletNumber() const;
            void setTupletNumber( const TupletNumberPtr& value );
            bool getHasTupletNumber() const;
            void setHasTupletNumber( const bool value );
            /* _________ TupletType minOccurs = 0, maxOccurs = 1 _________ */
            TupletTypePtr getTupletType() const;
            void setTupletType( const TupletTypePtr& value );
            bool getHasTupletType() const;
            void setHasTupletType( const bool value );
            /* _________ TupletDot minOccurs = 0, maxOccurs = unbounded _________ */
            const TupletDotSet& getTupletDotSet() const;
            void addTupletDot( const TupletDotPtr& value );
            void removeTupletDot( const TupletDotSetIterConst& value );
            void clearTupletDotSet();
            TupletDotPtr getTupletDot( const TupletDotSetIterConst& setIterator ) const;
        private:
            TupletNumberPtr myTupletNumber;
            bool myHasTupletNumber;
            TupletTypePtr myTupletType;
            bool myHasTupletType;
            TupletDotSet myTupletDotSet;
        };
        
        /* <!--  ID = 4920 [4920] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 8 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="tuplet" type="tuplet"/>
         <xs:complexType name="tuplet">
         <xs:annotation>
         <xs:documentation>A tuplet element is present when a tuplet is to be displayed graphically, in addition to the sound data provided by the time-modification elements. The number attribute is used to distinguish nested tuplets. The bracket attribute is used to indicate the presence of a bracket. If unspecified, the results are implementation-dependent. The line-shape attribute is used to specify whether the bracket is straight or in the older curved or slurred style. It is straight by default.
         
         Whereas a time-modification element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note type, the tuplet element describes how this is displayed. The tuplet element also provides more detailed representation information than the time-modification element, and is needed to represent nested tuplets and other complex tuplets accurately.
         
         The show-number attribute is used to display either the number of actual notes, the number of both actual and normal notes, or neither. It is actual by default. The show-type attribute is used to display either the actual type, both the actual and normal types, or neither. It is none by default.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="tuplet-actual" type="tuplet-portion" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The tuplet-actual element provide optional full control over how the actual part of the tuplet is displayed, including number and note type (with dots). If any of these elements are absent, their values are based on the time-modification element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="tuplet-normal" type="tuplet-portion" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The tuplet-normal element provide optional full control over how the normal part of the tuplet is displayed, including number and note type (with dots). If any of these elements are absent, their values are based on the time-modification element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="number" type="number-level"/>
         <xs:attribute name="bracket" type="yes-no"/>
         <xs:attribute name="show-number" type="show-tuplet"/>
         <xs:attribute name="show-type" type="show-tuplet"/>
         <xs:attributeGroup ref="line-shape"/>
         <xs:attributeGroup ref="position"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType> */
        
        struct TupletAttributes;
        using TupletAttributesPtr = std::shared_ptr<TupletAttributes>;
        
        struct TupletAttributes : public AttributesInterface
        {
        public:
            TupletAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            t::NumberLevel number;
            t::YesNo bracket;
            t::ShowTuplet showNumber;
            t::ShowTuplet showType;
            t::LineShape lineShape;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::AboveBelow placement;
            const 	bool hasType;
            bool hasNumber;
            bool hasBracket;
            bool hasShowNumber;
            bool hasShowType;
            bool hasLineShape;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasPlacement;
        };
        
        class Tuplet;
        using TupletPtr = std::shared_ptr<Tuplet>;
        using TupletUPtr = std::unique_ptr<Tuplet>;
        using TupletSet = std::vector<TupletPtr>;
        using TupletSetIter = TupletSet::iterator;
        using TupletSetIterConst = TupletSet::const_iterator;
        inline TupletPtr makeTuplet() { return std::make_shared<Tuplet>(); }
        class Tuplet : public ElementInterface
        {
        public:
            Tuplet();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            TupletAttributesPtr getAttributes() const;
            void setAttributes( const TupletAttributesPtr& value );
            /* _________ TupletActual minOccurs = 0, maxOccurs = 1 _________ */
            TupletActualPtr getTupletActual() const;
            void setTupletActual( const TupletActualPtr& value );
            bool getHasTupletActual() const;
            void setHasTupletActual( const bool value );
            /* _________ TupletNormal minOccurs = 0, maxOccurs = 1 _________ */
            TupletNormalPtr getTupletNormal() const;
            void setTupletNormal( const TupletNormalPtr& value );
            bool getHasTupletNormal() const;
            void setHasTupletNormal( const bool value );
        private:
            TupletAttributesPtr myAttributes;
            TupletActualPtr myTupletActual;
            bool myHasTupletActual;
            TupletNormalPtr myTupletNormal;
            bool myHasTupletNormal;
        };
        /* <!--  ID = 5704 [5704] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="scaling" type="scaling" minOccurs="0"/>
         <xs:complexType name="scaling">
         <xs:annotation>
         <xs:documentation>Margins, page sizes, and distances are all measured in tenths to keep MusicXML data in a consistent coordinate system as much as possible. The translation to absolute units is done with the scaling type, which specifies how many millimeters are equal to how many tenths. For a staff height of 7 mm, millimeters would be set to 7 while tenths is set to 40. The ability to set a formula rather than a single scaling factor helps avoid roundoff errors.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="millimeters" type="millimeters"/>
         <xs:element name="tenths" type="tenths"/>
         </xs:sequence>
         </xs:complexType> */
        
        class Scaling;
        using ScalingPtr = std::shared_ptr<Scaling>;
        using ScalingUPtr = std::unique_ptr<Scaling>;
        using ScalingSet = std::vector<ScalingPtr>;
        using ScalingSetIter = ScalingSet::iterator;
        using ScalingSetIterConst = ScalingSet::const_iterator;
        inline ScalingPtr makeScaling() { return std::make_shared<Scaling>(); }
        class Scaling : public ElementInterface
        {
        public:
            Scaling();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Millimeters minOccurs = 1, maxOccurs = 1 _________ */
            MillimetersPtr getMillimeters() const;
            void setMillimeters( const MillimetersPtr& value );
            /* _________ Tenths minOccurs = 1, maxOccurs = 1 _________ */
            TenthsPtr getTenths() const;
            void setTenths( const TenthsPtr& value );
        private:
            MillimetersPtr myMillimeters;
            TenthsPtr myTenths;
        };
        
        /* !--  ID = 5710 [5710] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 4 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="appearance" type="appearance" minOccurs="0"/>
         <xs:complexType name="appearance">
         <xs:annotation>
         <xs:documentation>The appearance type controls general graphical settings for the music's final form appearance on a printed page of display. This includes support for line widths, definitions for note sizes, and standard distances between notation elements, plus an extension element for other aspects of appearance.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="line-width" type="line-width" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="note-size" type="note-size" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="distance" type="distance" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="other-appearance" type="other-appearance" minOccurs="0" maxOccurs="unbounded"/>
         </xs:sequence>
         </xs:complexType> */
        
        class Appearance;
        using AppearancePtr = std::shared_ptr<Appearance>;
        using AppearanceUPtr = std::unique_ptr<Appearance>;
        using AppearanceSet = std::vector<AppearancePtr>;
        using AppearanceSetIter = AppearanceSet::iterator;
        using AppearanceSetIterConst = AppearanceSet::const_iterator;
        inline AppearancePtr makeAppearance() { return std::make_shared<Appearance>(); }
        class Appearance : public ElementInterface
        {
        public:
            Appearance();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ LineWidth minOccurs = 0, maxOccurs = unbounded _________ */
            const LineWidthSet& getLineWidthSet() const;
            void addLineWidth( const LineWidthPtr& value );
            void removeLineWidth( const LineWidthSetIterConst& value );
            void clearLineWidthSet();
            LineWidthPtr getLineWidth( const LineWidthSetIterConst& setIterator ) const;
            /* _________ NoteSize minOccurs = 0, maxOccurs = unbounded _________ */
            const NoteSizeSet& getNoteSizeSet() const;
            void addNoteSize( const NoteSizePtr& value );
            void removeNoteSize( const NoteSizeSetIterConst& value );
            void clearNoteSizeSet();
            NoteSizePtr getNoteSize( const NoteSizeSetIterConst& setIterator ) const;
            /* _________ Distance minOccurs = 0, maxOccurs = unbounded _________ */
            const DistanceSet& getDistanceSet() const;
            void addDistance( const DistancePtr& value );
            void removeDistance( const DistanceSetIterConst& value );
            void clearDistanceSet();
            DistancePtr getDistance( const DistanceSetIterConst& setIterator ) const;
            /* _________ OtherAppearance minOccurs = 0, maxOccurs = unbounded _________ */
            const OtherAppearanceSet& getOtherAppearanceSet() const;
            void addOtherAppearance( const OtherAppearancePtr& value );
            void removeOtherAppearance( const OtherAppearanceSetIterConst& value );
            void clearOtherAppearanceSet();
            OtherAppearancePtr getOtherAppearance( const OtherAppearanceSetIterConst& setIterator ) const;
        private:
            LineWidthSet myLineWidthSet;
            NoteSizeSet myNoteSizeSet;
            DistanceSet myDistanceSet;
            OtherAppearanceSet myOtherAppearanceSet;
        };
        /* <!--  ID = 5908 [5908] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="virtual-instrument" type="virtual-instrument" minOccurs="0"/>
         <xs:complexType name="virtual-instrument">
         <xs:annotation>
         <xs:documentation>The virtual-instrument element defines a specific virtual instrument used for an instrument sound.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="virtual-library" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The virtual-library element indicates the virtual instrument library name.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="virtual-name" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The virtual-name element indicates the library-specific name for the virtual instrument.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:complexType> */
        
        class VirtualInstrument;
        using VirtualInstrumentPtr = std::shared_ptr<VirtualInstrument>;
        using VirtualInstrumentUPtr = std::unique_ptr<VirtualInstrument>;
        using VirtualInstrumentSet = std::vector<VirtualInstrumentPtr>;
        using VirtualInstrumentSetIter = VirtualInstrumentSet::iterator;
        using VirtualInstrumentSetIterConst = VirtualInstrumentSet::const_iterator;
        inline VirtualInstrumentPtr makeVirtualInstrument() { return std::make_shared<VirtualInstrument>(); }
        class VirtualInstrument : public ElementInterface
        {
        public:
            VirtualInstrument();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ VirtualLibrary minOccurs = 0, maxOccurs = 1 _________ */
            VirtualLibraryPtr getVirtualLibrary() const;
            void setVirtualLibrary( const VirtualLibraryPtr& value );
            bool getHasVirtualLibrary() const;
            void setHasVirtualLibrary( const bool value );
            /* _________ VirtualName minOccurs = 0, maxOccurs = 1 _________ */
            VirtualNamePtr getVirtualName() const;
            void setVirtualName( const VirtualNamePtr& value );
            bool getHasVirtualName() const;
            void setHasVirtualName( const bool value );
        private:
            VirtualLibraryPtr myVirtualLibrary;
            bool myHasVirtualLibrary;
            VirtualNamePtr myVirtualName;
            bool myHasVirtualName;
        };
        
        /* <!--  ID = 6191 [6191] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="root" type="root"/>
         <xs:complexType name="root">
         <xs:annotation>
         <xs:documentation>The root type indicates a pitch like C, D, E vs. a function indication like I, II, III. It is used with chord symbols in popular music. The root element has a root-step and optional root-alter element similar to the step and alter elements, but renamed to distinguish the different musical meanings.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="root-step" type="root-step"/>
         <xs:element name="root-alter" type="root-alter" minOccurs="0"/>
         </xs:sequence>
         </xs:complexType> */
        
        class Root;
        using RootPtr = std::shared_ptr<Root>;
        using RootUPtr = std::unique_ptr<Root>;
        using RootSet = std::vector<RootPtr>;
        using RootSetIter = RootSet::iterator;
        using RootSetIterConst = RootSet::const_iterator;
        inline RootPtr makeRoot() { return std::make_shared<Root>(); }
        class Root : public ElementInterface
        {
        public:
            Root();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ RootStep minOccurs = 1, maxOccurs = 1 _________ */
            RootStepPtr getRootStep() const;
            void setRootStep( const RootStepPtr& value );
            /* _________ RootAlter minOccurs = 0, maxOccurs = 1 _________ */
            RootAlterPtr getRootAlter() const;
            void setRootAlter( const RootAlterPtr& value );
            bool getHasRootAlter() const;
            void setHasRootAlter( const bool value );
        private:
            RootStepPtr myRootStep;
            RootAlterPtr myRootAlter;
            bool myHasRootAlter;
        };
        
        /* <!--  ID = 6206 [6206] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="bass" type="bass" minOccurs="0"/>
         <xs:complexType name="bass">
         <xs:annotation>
         <xs:documentation>The bass type is used to indicate a bass note in popular music chord symbols, e.g. G/C. It is generally not used in functional harmony, as inversion is generally not used in pop chord symbols. As with root, it is divided into step and alter elements, similar to pitches.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="bass-step" type="bass-step"/>
         <xs:element name="bass-alter" type="bass-alter" minOccurs="0"/>
         </xs:sequence>
         </xs:complexType> */
        
        class Bass;
        using BassPtr = std::shared_ptr<Bass>;
        using BassUPtr = std::unique_ptr<Bass>;
        using BassSet = std::vector<BassPtr>;
        using BassSetIter = BassSet::iterator;
        using BassSetIterConst = BassSet::const_iterator;
        inline BassPtr makeBass() { return std::make_shared<Bass>(); }
        class Bass : public ElementInterface
        {
        public:
            Bass();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ BassStep minOccurs = 1, maxOccurs = 1 _________ */
            BassStepPtr getBassStep() const;
            void setBassStep( const BassStepPtr& value );
            /* _________ BassAlter minOccurs = 0, maxOccurs = 1 _________ */
            BassAlterPtr getBassAlter() const;
            void setBassAlter( const BassAlterPtr& value );
            bool getHasBassAlter() const;
            void setHasBassAlter( const bool value );
        private:
            BassStepPtr myBassStep;
            BassAlterPtr myBassAlter;
            bool myHasBassAlter;
        };
        
        /* <!--  ID = 6210 [6210] ------------------------->
         <!-- min=0 max=4294967295 ZeroOrMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 3 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="degree" type="degree" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="degree">
         <xs:annotation>
         <xs:documentation>The degree type is used to add, alter, or subtract individual notes in the chord. The print-object attribute can be used to keep the degree from printing separately when it has already taken into account in the text attribute of the kind element. The degree-value and degree-type text attributes specify how the value and type of the degree should be displayed.
         
         A harmony of kind "other" can be spelled explicitly by using a series of degree elements together with a root.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="degree-value" type="degree-value"/>
         <xs:element name="degree-alter" type="degree-alter"/>
         <xs:element name="degree-type" type="degree-type"/>
         </xs:sequence>
         <xs:attributeGroup ref="print-object"/>
         </xs:complexType> */
        
        struct DegreeAttributes;
        using DegreeAttributesPtr = std::shared_ptr<DegreeAttributes>;
        
        struct DegreeAttributes : public AttributesInterface
        {
        public:
            DegreeAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo printObject;
            bool hasPrintObject;
        };
        
        class Degree;
        using DegreePtr = std::shared_ptr<Degree>;
        using DegreeUPtr = std::unique_ptr<Degree>;
        using DegreeSet = std::vector<DegreePtr>;
        using DegreeSetIter = DegreeSet::iterator;
        using DegreeSetIterConst = DegreeSet::const_iterator;
        inline DegreePtr makeDegree() { return std::make_shared<Degree>(); }
        class Degree : public ElementInterface
        {
        public:
            Degree();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DegreeAttributesPtr getAttributes() const;
            void setAttributes( const DegreeAttributesPtr& value );
            /* _________ DegreeValue minOccurs = 1, maxOccurs = 1 _________ */
            DegreeValuePtr getDegreeValue() const;
            void setDegreeValue( const DegreeValuePtr& value );
            /* _________ DegreeAlter minOccurs = 1, maxOccurs = 1 _________ */
            DegreeAlterPtr getDegreeAlter() const;
            void setDegreeAlter( const DegreeAlterPtr& value );
            /* _________ DegreeType minOccurs = 1, maxOccurs = 1 _________ */
            DegreeTypePtr getDegreeType() const;
            void setDegreeType( const DegreeTypePtr& value );
        private:
            DegreeAttributesPtr myAttributes;
            DegreeValuePtr myDegreeValue;
            DegreeAlterPtr myDegreeAlter;
            DegreeTypePtr myDegreeType;
        };
        /* <!--  ID = 6233 [6233] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 7 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="page-layout" type="page-layout" minOccurs="0"/>
         <xs:complexType name="page-layout">
         <xs:annotation>
         <xs:documentation>Page layout can be defined both in score-wide defaults and in the print element. Page margins are specified either for both even and odd pages, or via separate odd and even page number values. The type is not needed when used as part of a print element. If omitted when used in the defaults element, "both" is the default.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:sequence minOccurs="0">
         <xs:element name="page-height" type="tenths"/>
         <xs:element name="page-width" type="tenths"/>
         </xs:sequence>
         <xs:element name="page-margins" type="page-margins" minOccurs="0" maxOccurs="2"/>
         </xs:sequence>
         </xs:complexType> */
        
        class PageLayout;
        using PageLayoutPtr = std::shared_ptr<PageLayout>;
        using PageLayoutUPtr = std::unique_ptr<PageLayout>;
        using PageLayoutSet = std::vector<PageLayoutPtr>;
        using PageLayoutSetIter = PageLayoutSet::iterator;
        using PageLayoutSetIterConst = PageLayoutSet::const_iterator;
        inline PageLayoutPtr makePageLayout() { return std::make_shared<PageLayout>(); }
        class PageLayout : public ElementInterface
        {
        public:
            PageLayout();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ PageHeight minOccurs = 1, maxOccurs = 1 _________ */
            PageHeightPtr getPageHeight() const;
            void setPageHeight( const PageHeightPtr& value );
            /* _________ PageWidth minOccurs = 1, maxOccurs = 1 _________ */
            PageWidthPtr getPageWidth() const;
            void setPageWidth( const PageWidthPtr& value );
            /* _________ PageMargins minOccurs = 0, maxOccurs = 2 _________ */
            const PageMarginsSet& getPageMarginsSet() const;
            void addPageMargins( const PageMarginsPtr& value );
            void removePageMargins( const PageMarginsSetIterConst& value );
            void clearPageMarginsSet();
            PageMarginsPtr getPageMargins( const PageMarginsSetIterConst& setIterator ) const;
        private:
            PageHeightPtr myPageHeight;
            PageWidthPtr myPageWidth;
            PageMarginsSet myPageMarginsSet;
        };
        /* <!--  ID = 6237 [6237] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 8 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="system-layout" type="system-layout" minOccurs="0"/>
         <xs:complexType name="system-layout">
         <xs:annotation>
         <xs:documentation>A system is a group of staves that are read and played simultaneously. System layout includes left and right margins and the vertical distance from the previous system. The system distance is measured from the bottom line of the previous system to the top line of the current system. It is ignored for the first system on a page. The top system distance is measured from the page's top margin to the top line of the first system. It is ignored for all but the first system on a page.
         
         Sometimes the sum of measure widths in a system may not equal the system width specified by the layout elements due to roundoff or other errors. The behavior when reading MusicXML files in these cases is application-dependent. For instance, applications may find that the system layout data is more reliable than the sum of the measure widths, and adjust the measure widths accordingly.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="system-margins" type="system-margins" minOccurs="0"/>
         <xs:element name="system-distance" type="tenths" minOccurs="0"/>
         <xs:element name="top-system-distance" type="tenths" minOccurs="0"/>
         <xs:element name="system-dividers" type="system-dividers" minOccurs="0"/>
         </xs:sequence>
         </xs:complexType> */
        
        class SystemLayout;
        using SystemLayoutPtr = std::shared_ptr<SystemLayout>;
        using SystemLayoutUPtr = std::unique_ptr<SystemLayout>;
        using SystemLayoutSet = std::vector<SystemLayoutPtr>;
        using SystemLayoutSetIter = SystemLayoutSet::iterator;
        using SystemLayoutSetIterConst = SystemLayoutSet::const_iterator;
        inline SystemLayoutPtr makeSystemLayout() { return std::make_shared<SystemLayout>(); }
        class SystemLayout : public ElementInterface
        {
        public:
            SystemLayout();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ SystemMargins minOccurs = 0, maxOccurs = 1 _________ */
            SystemMarginsPtr getSystemMargins() const;
            void setSystemMargins( const SystemMarginsPtr& value );
            bool getHasSystemMargins() const;
            void setHasSystemMargins( const bool value );
            SystemDistancePtr getSystemDistance() const;
            void setSystemDistance( const SystemDistancePtr& value );
            bool getHasSystemDistance() const;
            void setHasSystemDistance( const bool value );
            /* _________ TopSystemDistance minOccurs = 0, maxOccurs = 1 _________ */
            TopSystemDistancePtr getTopSystemDistance() const;
            void setTopSystemDistance( const TopSystemDistancePtr& value );
            bool getHasTopSystemDistance() const;
            void setHasTopSystemDistance( const bool value );
            /* _________ SystemDividers minOccurs = 0, maxOccurs = 1 _________ */
            SystemDividersPtr getSystemDividers() const;
            void setSystemDividers( const SystemDividersPtr& value );
            bool getHasSystemDividers() const;
            void setHasSystemDividers( const bool value );
        private:
            SystemMarginsPtr mySystemMargins;
            bool myHasSystemMargins;
            SystemDistancePtr mySystemDistance;
            bool myHasSystemDistance;
            TopSystemDistancePtr myTopSystemDistance;
            bool myHasTopSystemDistance;
            SystemDividersPtr mySystemDividers;
            bool myHasSystemDividers;
        };
        /* <!--  ID = 6241 [6241] ------------------------->
         <!-- min=0 max=4294967295 ZeroOrMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 1 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="staff-layout" type="staff-layout" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="staff-layout">
         <xs:annotation>
         <xs:documentation>Staff layout includes the vertical distance from the bottom line of the previous staff in this system to the top line of the staff specified by the number attribute. The optional number attribute refers to staff numbers within the part, from top to bottom on the system. A value of 1 is assumed if not present. When used in the defaults element, the values apply to all parts. This value is ignored for the first staff in a system.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="staff-distance" type="tenths" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="number" type="staff-number"/>
         </xs:complexType> */
        
        struct StaffLayoutAttributes;
        using StaffLayoutAttributesPtr = std::shared_ptr<StaffLayoutAttributes>;
        
        struct StaffLayoutAttributes : public AttributesInterface
        {
        public:
            StaffLayoutAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StaffNumber number;
            bool hasNumber;
        };
        
        class StaffLayout;
        using StaffLayoutPtr = std::shared_ptr<StaffLayout>;
        using StaffLayoutUPtr = std::unique_ptr<StaffLayout>;
        using StaffLayoutSet = std::vector<StaffLayoutPtr>;
        using StaffLayoutSetIter = StaffLayoutSet::iterator;
        using StaffLayoutSetIterConst = StaffLayoutSet::const_iterator;
        inline StaffLayoutPtr makeStaffLayout() { return std::make_shared<StaffLayout>(); }
        class StaffLayout : public ElementInterface
        {
        public:
            StaffLayout();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            StaffLayoutAttributesPtr getAttributes() const;
            void setAttributes( const StaffLayoutAttributesPtr& value );
            /* _________ StaffDistance minOccurs = 0, maxOccurs = 1 _________ */
            StaffDistancePtr getStaffDistance() const;
            void setStaffDistance( const StaffDistancePtr& value );
            bool getHasStaffDistance() const;
            void setHasStaffDistance( const bool value );
        private:
            StaffLayoutAttributesPtr myAttributes;
            StaffDistancePtr myStaffDistance;
            bool myHasStaffDistance;
        };
        /* <!--  ID = 6290 [6290] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 3 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="pitch" type="pitch"/>
         <xs:complexType name="pitch">
         <xs:annotation>
         <xs:documentation>Pitch is represented as a combination of the step of the diatonic scale, the chromatic alteration, and the octave.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="step" type="step"/>
         <xs:element name="alter" type="semitones" minOccurs="0"/>
         <xs:element name="octave" type="octave"/>
         </xs:sequence>
         </xs:complexType> */
        
        class Pitch;
        using PitchPtr = std::shared_ptr<Pitch>;
        using PitchUPtr = std::unique_ptr<Pitch>;
        using PitchSet = std::vector<PitchPtr>;
        using PitchSetIter = PitchSet::iterator;
        using PitchSetIterConst = PitchSet::const_iterator;
        inline PitchPtr makePitch() { return std::make_shared<Pitch>(); }
        class Pitch : public ElementInterface
        {
        public:
            Pitch();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Step minOccurs = 1, maxOccurs = 1 _________ */
            StepPtr getStep() const;
            void setStep( const StepPtr& value );
            /* _________ Alter minOccurs = 0, maxOccurs = 1 _________ */
            AlterPtr getAlter() const;
            void setAlter( const AlterPtr& value );
            bool getHasAlter() const;
            void setHasAlter( const bool value );
            /* _________ Octave minOccurs = 1, maxOccurs = 1 _________ */
            OctavePtr getOctave() const;
            void setOctave( const OctavePtr& value );
        private:
            StepPtr myStep;
            AlterPtr myAlter;
            bool myHasAlter;
            OctavePtr myOctave;
        };
        
        class DisplayStepOctaveGroup;
        using DisplayStepOctaveGroupPtr = std::shared_ptr<DisplayStepOctaveGroup>;
        using DisplayStepOctaveGroupUPtr = std::unique_ptr<DisplayStepOctaveGroup>;
        using DisplayStepOctaveGroupSet = std::vector<DisplayStepOctaveGroupPtr>;
        using DisplayStepOctaveGroupSetIter = DisplayStepOctaveGroupSet::iterator;
        using DisplayStepOctaveGroupSetIterConst = DisplayStepOctaveGroupSet::const_iterator;
        inline DisplayStepOctaveGroupPtr makeDisplayStepOctaveGroup() { return std::make_shared<DisplayStepOctaveGroup>(); }
        class DisplayStepOctaveGroup : public ElementInterface
        {
        public:
            DisplayStepOctaveGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ DisplayStep minOccurs = 1, maxOccurs = 1 _________ */
            DisplayStepPtr getDisplayStep() const;
            void setDisplayStep( const DisplayStepPtr& value );
            /* _________ DisplayOctave minOccurs = 1, maxOccurs = 1 _________ */
            DisplayOctavePtr getDisplayOctave() const;
            void setDisplayOctave( const DisplayOctavePtr& value );
        private:
            DisplayStepPtr myDisplayStep;
            DisplayOctavePtr myDisplayOctave;
        };
        
        /* <!--  ID = 6293 [6293] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="unpitched" type="unpitched"/>
         <xs:complexType name="unpitched">
         <xs:annotation>
         <xs:documentation>The unpitched type represents musical elements that are notated on the staff but lack definite pitch, such as unpitched percussion and speaking voice.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="display-step-octave" minOccurs="0"/>
         </xs:sequence>
         </xs:complexType>
         <xs:group name="display-step-octave">
         <xs:annotation>
         <xs:documentation>The display-step-octave group contains the sequence of elements used by both the rest and unpitched elements. This group is used to place rests and unpitched elements on the staff without implying that these elements have pitch. Positioning follows the current clef. If percussion clef is used, the display-step and display-octave elements are interpreted as if in treble clef, with a G in octave 4 on line 2. If not present, the note is placed on the middle line of the staff, generally used for a one-line staff.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="display-step" type="step"/>
         <xs:element name="display-octave" type="octave"/>
         </xs:sequence>
         </xs:group> */
        
        class Unpitched;
        using UnpitchedPtr = std::shared_ptr<Unpitched>;
        using UnpitchedUPtr = std::unique_ptr<Unpitched>;
        using UnpitchedSet = std::vector<UnpitchedPtr>;
        using UnpitchedSetIter = UnpitchedSet::iterator;
        using UnpitchedSetIterConst = UnpitchedSet::const_iterator;
        inline UnpitchedPtr makeUnpitched() { return std::make_shared<Unpitched>(); }
        class Unpitched : public ElementInterface
        {
        public:
            Unpitched();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ DisplayStepOctaveGroup minOccurs = 0, maxOccurs = 1 _________ */
            DisplayStepOctaveGroupPtr getDisplayStepOctaveGroup() const;
            void setDisplayStepOctaveGroup( const DisplayStepOctaveGroupPtr& value );
            bool getHasDisplayStepOctaveGroup() const;
            void setHasDisplayStepOctaveGroup( const bool value );
        private:
            DisplayStepOctaveGroupPtr myDisplayStepOctaveGroup;
            bool myHasDisplayStepOctaveGroup;
        };
        
        /* <!--  ID = 6296 [6296] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="rest" type="rest"/>
         <xs:complexType name="rest">
         <xs:annotation>
         <xs:documentation>The rest element indicates notated rests or silences. Rest elements are usually empty, but placement on the staff can be specified using display-step and display-octave elements. If the measure attribute is set to yes, this indicates this is a complete measure rest.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="display-step-octave" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="measure" type="yes-no"/>
         </xs:complexType>
         <xs:group name="display-step-octave">
         <xs:annotation>
         <xs:documentation>The display-step-octave group contains the sequence of elements used by both the rest and unpitched elements. This group is used to place rests and unpitched elements on the staff without implying that these elements have pitch. Positioning follows the current clef. If percussion clef is used, the display-step and display-octave elements are interpreted as if in treble clef, with a G in octave 4 on line 2. If not present, the note is placed on the middle line of the staff, generally used for a one-line staff.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="display-step" type="step"/>
         <xs:element name="display-octave" type="octave"/>
         </xs:sequence>
         </xs:group> */
        
        struct RestAttributes;
        using RestAttributesPtr = std::shared_ptr<RestAttributes>;
        
        struct RestAttributes : public AttributesInterface
        {
        public:
            RestAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo measure;
            bool hasMeasure;
        };
        
        class Rest;
        using RestPtr = std::shared_ptr<Rest>;
        using RestUPtr = std::unique_ptr<Rest>;
        using RestSet = std::vector<RestPtr>;
        using RestSetIter = RestSet::iterator;
        using RestSetIterConst = RestSet::const_iterator;
        inline RestPtr makeRest() { return std::make_shared<Rest>(); }
        class Rest : public ElementInterface
        {
        public:
            Rest();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            RestAttributesPtr getAttributes() const;
            void setAttributes( const RestAttributesPtr& value );
            /* _________ DisplayStepOctaveGroup minOccurs = 0, maxOccurs = 1 _________ */
            DisplayStepOctaveGroupPtr getDisplayStepOctaveGroup() const;
            void setDisplayStepOctaveGroup( const DisplayStepOctaveGroupPtr& value );
            bool getHasDisplayStepOctaveGroup() const;
            void setHasDisplayStepOctaveGroup( const bool value );
        private:
            RestAttributesPtr myAttributes;
            DisplayStepOctaveGroupPtr myDisplayStepOctaveGroup;
            bool myHasDisplayStepOctaveGroup;
        };
        
        /* <!--  ID = 6310 [6310] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 3 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="backup" type="backup"/>
         
         <xs:complexType name="backup">
         <xs:annotation>
         <xs:documentation>The backup and forward elements are required to coordinate multiple voices in one part, including music on multiple staves. The backup type is generally used to move between voices and staves. Thus the backup element does not include voice or staff elements. Duration values should always be positive, and should not cross measure boundaries or mid-measure changes in the divisions value.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="duration"/>
         <xs:group ref="editorial"/>
         </xs:sequence>
         </xs:complexType>
         
         <xs:group name="duration">
         <xs:annotation>
         <xs:documentation>The duration element is defined within a group due to its uses within the note, figure-bass, backup, and forward elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="duration" type="positive-divisions">
         <xs:annotation>
         <xs:documentation>Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, swing eighths vs. even eighths, or differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should use the note element's attack and release attributes.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         
         <xs:group name="editorial">
         <xs:annotation>
         <xs:documentation>The editorial group specifies editorial information for a musical element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         </xs:sequence>
         </xs:group> */
        
        class Backup;
        using BackupPtr = std::shared_ptr<Backup>;
        using BackupUPtr = std::unique_ptr<Backup>;
        using BackupSet = std::vector<BackupPtr>;
        using BackupSetIter = BackupSet::iterator;
        using BackupSetIterConst = BackupSet::const_iterator;
        inline BackupPtr makeBackup() { return std::make_shared<Backup>(); }
        class Backup : public ElementInterface
        {
        public:
            Backup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Duration minOccurs = 1, maxOccurs = 1 _________ */
            DurationPtr getDuration() const;
            void setDuration( const DurationPtr& value );
            /* _________ EditorialGroup minOccurs = 1, maxOccurs = 1 _________ */
            EditorialGroupPtr getEditorialGroup() const;
            void setEditorialGroup( const EditorialGroupPtr& value );
        private:
            DurationPtr myDuration;
            EditorialGroupPtr myEditorialGroup;
        };
        
        /* <!--  ID = 6313 [6313] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 5 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="forward" type="forward"/>
         
         <xs:complexType name="forward">
         <xs:annotation>
         <xs:documentation>The backup and forward elements are required to coordinate multiple voices in one part, including music on multiple staves. The forward element is generally used within voices and staves. Duration values should always be positive, and should not cross measure boundaries or mid-measure changes in the divisions value.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="duration"/>
         <xs:group ref="editorial-voice"/>
         <xs:group ref="staff" minOccurs="0"/>
         </xs:sequence>
         </xs:complexType>
         
         <xs:group name="duration">
         <xs:annotation>
         <xs:documentation>The duration element is defined within a group due to its uses within the note, figure-bass, backup, and forward elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="duration" type="positive-divisions">
         <xs:annotation>
         <xs:documentation>Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, swing eighths vs. even eighths, or differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should use the note element's attack and release attributes.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         
         <xs:group name="editorial-voice">
         <xs:annotation>
         <xs:documentation>The editorial-voice group supports the common combination of editorial and voice information for a musical element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         <xs:group ref="voice" minOccurs="0"/>
         </xs:sequence>
         </xs:group>
         
         <xs:group name="staff">
         <xs:annotation>
         <xs:documentation>The staff element is defined within a group due to its use by both notes and direction elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="staff" type="xs:positiveInteger">
         <xs:annotation>
         <xs:documentation>Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group> */
        
        class Forward;
        using ForwardPtr = std::shared_ptr<Forward>;
        using ForwardUPtr = std::unique_ptr<Forward>;
        using ForwardSet = std::vector<ForwardPtr>;
        using ForwardSetIter = ForwardSet::iterator;
        using ForwardSetIterConst = ForwardSet::const_iterator;
        inline ForwardPtr makeForward() { return std::make_shared<Forward>(); }
        class Forward : public ElementInterface
        {
        public:
            Forward();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Duration minOccurs = 1, maxOccurs = 1 _________ */
            DurationPtr getDuration() const;
            void setDuration( const DurationPtr& value );
            /* _________ Footnote minOccurs = 1, maxOccurs = 1 _________ */
            EditorialVoiceGroupPtr getEditorialVoiceGroup() const;
            void setEditorialVoiceGroup( const EditorialVoiceGroupPtr& value );
            /* _________ Staff minOccurs = 0, maxOccurs = 1 _________ */
            StaffPtr getStaff() const;
            void setStaff( const StaffPtr& value );
            bool getHasStaff() const;
            void setHasStaff( const bool value );
        private:
            DurationPtr myDuration;
            EditorialVoiceGroupPtr myEditorialVoiceGroup;
            StaffPtr myStaff;
            bool myHasStaff;
        };
        /* <!--  ID = 6325 [6325] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 8 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="figured-bass" type="figured-bass"/>
         <xs:complexType name="figured-bass">
         <xs:annotation>
         <xs:documentation>The figured-bass element represents figured bass notation. Figured bass elements take their position from the first regular note (not a grace note or chord note) that follows in score order. The optional duration element is used to indicate changes of figures under a note.
         
         Figures are ordered from top to bottom. The value of parentheses is "no" if not present.</xs:documentation>
         </xs:annotation>
         
         <xs:sequence>
         <xs:element name="figure" type="figure" maxOccurs="unbounded"/>
         <xs:group ref="duration" minOccurs="0"/>
         <xs:group ref="editorial"/>
         </xs:sequence>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="printout"/>
         <xs:attribute name="parentheses" type="yes-no"/>
         </xs:complexType>
         
         <xs:group name="duration">
         <xs:annotation>
         <xs:documentation>The duration element is defined within a group due to its uses within the note, figure-bass, backup, and forward elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="duration" type="positive-divisions">
         <xs:annotation>
         <xs:documentation>Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, swing eighths vs. even eighths, or differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should use the note element's attack and release attributes.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         
         <xs:group name="editorial">
         <xs:annotation>
         <xs:documentation>The editorial group specifies editorial information for a musical element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         </xs:sequence>
         </xs:group> */
        
        struct FiguredBassAttributes;
        using FiguredBassAttributesPtr = std::shared_ptr<FiguredBassAttributes>;
        
        struct FiguredBassAttributes : public AttributesInterface
        {
        public:
            FiguredBassAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::YesNo printObject;
            t::YesNo printDot;
            t::YesNo printSpacing;
            t::YesNo printLyric;
            t::YesNo parentheses;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasPrintObject;
            bool hasPrintDot;
            bool hasPrintSpacing;
            bool hasPrintLyric;
            bool hasParentheses;
        };
        
        class FiguredBass;
        using FiguredBassPtr = std::shared_ptr<FiguredBass>;
        using FiguredBassUPtr = std::unique_ptr<FiguredBass>;
        using FiguredBassSet = std::vector<FiguredBassPtr>;
        using FiguredBassSetIter = FiguredBassSet::iterator;
        using FiguredBassSetIterConst = FiguredBassSet::const_iterator;
        inline FiguredBassPtr makeFiguredBass() { return std::make_shared<FiguredBass>(); }
        class FiguredBass : public ElementInterface
        {
        public:
            FiguredBass();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            FiguredBassAttributesPtr getAttributes() const;
            void setAttributes( const FiguredBassAttributesPtr& value );
            /* _________ Figure minOccurs = 1, maxOccurs = unbounded _________ */
            const FigureSet& getFigureSet() const;
            void addFigure( const FigurePtr& value );
            void removeFigure( const FigureSetIterConst& value );
            void clearFigureSet();
            FigurePtr getFigure( const FigureSetIterConst& setIterator ) const;
            /* _________ Duration minOccurs = 0, maxOccurs = 1 _________ */
            DurationPtr getDuration() const;
            void setDuration( const DurationPtr& value );
            bool getHasDuration() const;
            void setHasDuration( const bool value );
            /* _________ EditorialGroup minOccurs = 1, maxOccurs = 1 _________ */
            EditorialGroupPtr getEditorialGroup() const;
            void setEditorialGroup( const EditorialGroupPtr& value );
        private:
            FiguredBassAttributesPtr myAttributes;
            FigureSet myFigureSet;
            DurationPtr myDuration;
            bool myHasDuration;
            EditorialGroupPtr myEditorialGroup;
        };
        
        /* <!--  ID = 6334 [6334] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 9 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="barline" type="barline"/>
         <xs:complexType name="barline">
         <xs:annotation>
         <xs:documentation>If a barline is other than a normal single barline, it should be represented by a barline type that describes it. This includes information about repeats and multiple endings, as well as line style. Barline data is on the same level as the other musical data in a score - a child of a measure in a partwise score, or a part in a timewise score. This allows for barlines within measures, as in dotted barlines that subdivide measures in complex meters. The two fermata elements allow for fermatas on both sides of the barline (the lower one inverted).
         
         Barlines have a location attribute to make it easier to process barlines independently of the other musical data in a score. It is often easier to set up measures separately from entering notes. The location attribute must match where the barline element occurs within the rest of the musical data in the score. If location is left, it should be the first element in the measure, aside from the print, bookmark, and link elements. If location is right, it should be the last element, again with the possible exception of the print, bookmark, and link elements. If no location is specified, the right barline is the default. The segno, coda, and divisions attributes work the same way as in the sound element. They are used for playback when barline elements contain segno or coda child elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="bar-style" type="bar-style-color" minOccurs="0"/>
         <xs:group ref="editorial"/>
         <xs:element name="wavy-line" type="wavy-line" minOccurs="0"/>
         <xs:element name="segno" type="empty-print-style-align" minOccurs="0"/>
         <xs:element name="coda" type="empty-print-style-align" minOccurs="0"/>
         <xs:element name="fermata" type="fermata" minOccurs="0" maxOccurs="2"/>
         <xs:element name="ending" type="ending" minOccurs="0"/>
         <xs:element name="repeat" type="repeat" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="location" type="right-left-middle" default="right"/>
         <xs:attribute name="segno" type="xs:token"/>
         <xs:attribute name="coda" type="xs:token"/>
         <xs:attribute name="divisions" type="divisions"/>
         </xs:complexType>
         <xs:group name="editorial">
         <xs:annotation>
         <xs:documentation>The editorial group specifies editorial information for a musical element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         </xs:sequence>
         </xs:group> */
        
        struct BarlineAttributes;
        using BarlineAttributesPtr = std::shared_ptr<BarlineAttributes>;
        
        struct BarlineAttributes : public AttributesInterface
        {
        public:
            BarlineAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::RightLeftMiddle location;
            t::XsToken segno;
            t::XsToken coda;
            t::DivisionsValue divisions;
            bool hasLocation;
            bool hasSegno;
            bool hasCoda;
            bool hasDivisions;
        };
        
        class Barline;
        using BarlinePtr = std::shared_ptr<Barline>;
        using BarlineUPtr = std::unique_ptr<Barline>;
        using BarlineSet = std::vector<BarlinePtr>;
        using BarlineSetIter = BarlineSet::iterator;
        using BarlineSetIterConst = BarlineSet::const_iterator;
        inline BarlinePtr makeBarline() { return std::make_shared<Barline>(); }
        class Barline : public ElementInterface
        {
        public:
            Barline();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BarlineAttributesPtr getAttributes() const;
            void setAttributes( const BarlineAttributesPtr& value );
            /* _________ BarStyle minOccurs = 0, maxOccurs = 1 _________ */
            BarStylePtr getBarStyle() const;
            void setBarStyle( const BarStylePtr& value );
            bool getHasBarStyle() const;
            void setHasBarStyle( const bool value );
            /* _________ EditorialGroup minOccurs = 1, maxOccurs = 1 _________ */
            EditorialGroupPtr getEditorialGroup() const;
            void setEditorialGroup( const EditorialGroupPtr& value );
            /* _________ WavyLine minOccurs = 0, maxOccurs = 1 _________ */
            WavyLinePtr getWavyLine() const;
            void setWavyLine( const WavyLinePtr& value );
            bool getHasWavyLine() const;
            void setHasWavyLine( const bool value );
            /* _________ Segno minOccurs = 0, maxOccurs = 1 _________ */
            SegnoPtr getSegno() const;
            void setSegno( const SegnoPtr& value );
            bool getHasSegno() const;
            void setHasSegno( const bool value );
            /* _________ Coda minOccurs = 0, maxOccurs = 1 _________ */
            CodaPtr getCoda() const;
            void setCoda( const CodaPtr& value );
            bool getHasCoda() const;
            void setHasCoda( const bool value );
            /* _________ Fermata minOccurs = 0, maxOccurs = 2 _________ */
            const FermataSet& getFermataSet() const;
            void addFermata( const FermataPtr& value );
            void removeFermata( const FermataSetIterConst& value );
            void clearFermataSet();
            FermataPtr getFermata( const FermataSetIterConst& setIterator ) const;
            /* _________ Ending minOccurs = 0, maxOccurs = 1 _________ */
            EndingPtr getEnding() const;
            void setEnding( const EndingPtr& value );
            bool getHasEnding() const;
            void setHasEnding( const bool value );
            /* _________ Repeat minOccurs = 0, maxOccurs = 1 _________ */
            RepeatPtr getRepeat() const;
            void setRepeat( const RepeatPtr& value );
            bool getHasRepeat() const;
            void setHasRepeat( const bool value );
        private:
            BarlineAttributesPtr myAttributes;
            BarStylePtr myBarStyle;
            bool myHasBarStyle;
            EditorialGroupPtr myEditorialGroup;
            WavyLinePtr myWavyLine;
            bool myHasWavyLine;
            SegnoPtr mySegno;
            bool myHasSegno;
            CodaPtr myCoda;
            bool myHasCoda;
            FermataSet myFermataSet;
            EndingPtr myEnding;
            bool myHasEnding;
            RepeatPtr myRepeat;
            bool myHasRepeat;
        };
        
        /* <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 1 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="grouping" type="grouping"/>
         <xs:complexType name="grouping">
         <xs:annotation>
         <xs:documentation>The grouping type is used for musical analysis. When the type attribute is "start" or "single", it usually contains one or more feature elements. The number attribute is used for distinguishing between overlapping and hierarchical groupings. The member-of attribute allows for easy distinguishing of what grouping elements are in what hierarchy. Feature elements contained within a "stop" type of grouping may be ignored.
         
         This element is flexible to allow for different types of analyses. Future versions of the MusicXML format may add elements that can represent more standardized categories of analysis data, allowing for easier data sharing.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="feature" type="feature" minOccurs="0" maxOccurs="unbounded"/>
         </xs:sequence>
         <xs:attribute name="type" type="start-stop-single" use="required"/>
         <xs:attribute name="number" type="xs:token" default="1"/>
         <xs:attribute name="member-of" type="xs:token"/>
         </xs:complexType>  */
        
        struct GroupingAttributes;
        using GroupingAttributesPtr = std::shared_ptr<GroupingAttributes>;
        
        struct GroupingAttributes : public AttributesInterface
        {
        public:
            GroupingAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStopSingle type;
            t::XsToken number;
            t::XsToken memberOf;
            const 	bool hasType;
            bool hasNumber;
            bool hasMemberOf;
        };
        
        class Grouping;
        using GroupingPtr = std::shared_ptr<Grouping>;
        using GroupingUPtr = std::unique_ptr<Grouping>;
        using GroupingSet = std::vector<GroupingPtr>;
        using GroupingSetIter = GroupingSet::iterator;
        using GroupingSetIterConst = GroupingSet::const_iterator;
        inline GroupingPtr makeGrouping() { return std::make_shared<Grouping>(); }
        class Grouping : public ElementInterface
        {
        public:
            Grouping();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            GroupingAttributesPtr getAttributes() const;
            void setAttributes( const GroupingAttributesPtr& value );
            /* _________ Feature minOccurs = 0, maxOccurs = unbounded _________ */
            const FeatureSet& getFeatureSet() const;
            void addFeature( const FeaturePtr& value );
            void removeFeature( const FeatureSetIterConst& value );
            void clearFeatureSet();
            FeaturePtr getFeature( const FeatureSetIterConst& setIterator ) const;
        private:
            GroupingAttributesPtr myAttributes;
            FeatureSet myFeatureSet;
        };
        /* <!--  ID = 6359 [6359] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 3 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="work" type="work" minOccurs="0"/>
         <xs:complexType name="work">
         <xs:annotation>
         <xs:documentation>LayoutGroups are optionally identified by number and title. The work type also may indicate a link to the opus document that composes multiple scores into a collection.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="work-number" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The work-number element specifies the number of a work, such as its opus number.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="work-title" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The work-title element specifies the title of a work, not including its opus or other work number.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="opus" type="opus" minOccurs="0"/>
         </xs:sequence>
         </xs:complexType> */
        
        class Work;
        using WorkPtr = std::shared_ptr<Work>;
        using WorkUPtr = std::unique_ptr<Work>;
        using WorkSet = std::vector<WorkPtr>;
        using WorkSetIter = WorkSet::iterator;
        using WorkSetIterConst = WorkSet::const_iterator;
        inline WorkPtr makeWork() { return std::make_shared<Work>(); }
        class Work : public ElementInterface
        {
        public:
            Work();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ WorkNumber minOccurs = 0, maxOccurs = 1 _________ */
            WorkNumberPtr getWorkNumber() const;
            void setWorkNumber( const WorkNumberPtr& value );
            bool getHasWorkNumber() const;
            void setHasWorkNumber( const bool value );
            /* _________ WorkTitle minOccurs = 0, maxOccurs = 1 _________ */
            WorkTitlePtr getWorkTitle() const;
            void setWorkTitle( const WorkTitlePtr& value );
            bool getHasWorkTitle() const;
            void setHasWorkTitle( const bool value );
            /* _________ Opus minOccurs = 0, maxOccurs = 1 _________ */
            OpusPtr getOpus() const;
            void setOpus( const OpusPtr& value );
            bool getHasOpus() const;
            void setHasOpus( const bool value );
        private:
            WorkNumberPtr myWorkNumber;
            bool myHasWorkNumber;
            WorkTitlePtr myWorkTitle;
            bool myHasWorkTitle;
            OpusPtr myOpus;
            bool myHasOpus;
        };
        
        class LayoutGroup;
        using LayoutGroupPtr = std::shared_ptr<LayoutGroup>;
        using LayoutGroupUPtr = std::unique_ptr<LayoutGroup>;
        using LayoutGroupSet = std::vector<LayoutGroupPtr>;
        using LayoutGroupSetIter = LayoutGroupSet::iterator;
        using LayoutGroupSetIterConst = LayoutGroupSet::const_iterator;
        inline LayoutGroupPtr makeLayoutGroup() { return std::make_shared<LayoutGroup>(); }
        class LayoutGroup : public ElementInterface
        {
        public:
            LayoutGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ PageLayout minOccurs = 0, maxOccurs = 1 _________ */
            PageLayoutPtr getPageLayout() const;
            void setPageLayout( const PageLayoutPtr& value );
            bool getHasPageLayout() const;
            void setHasPageLayout( const bool value );
            /* _________ SystemLayout minOccurs = 0, maxOccurs = 1 _________ */
            SystemLayoutPtr getSystemLayout() const;
            void setSystemLayout( const SystemLayoutPtr& value );
            bool getHasSystemLayout() const;
            void setHasSystemLayout( const bool value );
            /* _________ StaffLayout minOccurs = 0, maxOccurs = unbounded _________ */
            const StaffLayoutSet& getStaffLayoutSet() const;
            void addStaffLayout( const StaffLayoutPtr& value );
            void removeStaffLayout( const StaffLayoutSetIterConst& value );
            void clearStaffLayoutSet();
            StaffLayoutPtr getStaffLayout( const StaffLayoutSetIterConst& setIterator ) const;
        private:
            PageLayoutPtr myPageLayout;
            bool myHasPageLayout;
            SystemLayoutPtr mySystemLayout;
            bool myHasSystemLayout;
            StaffLayoutSet myStaffLayoutSet;
        };
        
        /* <!--  ID = 6379 [6379] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 31 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="defaults" type="defaults" minOccurs="0"/>
         <xs:complexType name="defaults">
         <xs:annotation>
         <xs:documentation>The defaults type specifies score-wide defaults for scaling, layout, and appearance.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="scaling" type="scaling" minOccurs="0"/>
         <xs:group ref="layout"/>
         <xs:element name="appearance" type="appearance" minOccurs="0"/>
         <xs:element name="music-font" type="empty-font" minOccurs="0"/>
         <xs:element name="word-font" type="empty-font" minOccurs="0"/>
         <xs:element name="lyric-font" type="lyric-font" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="lyric-language" type="lyric-language" minOccurs="0" maxOccurs="unbounded"/>
         </xs:sequence>
         </xs:complexType>
         <xs:group name="layout">
         <xs:annotation>
         <xs:documentation>The layout group specifies the sequence of page, system, and staff layout elements that is common to both the defaults and print elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="page-layout" type="page-layout" minOccurs="0"/>
         <xs:element name="system-layout" type="system-layout" minOccurs="0"/>
         <xs:element name="staff-layout" type="staff-layout" minOccurs="0" maxOccurs="unbounded"/>
         </xs:sequence>
         </xs:group> */
        
        class Defaults;
        using DefaultsPtr = std::shared_ptr<Defaults>;
        using DefaultsUPtr = std::unique_ptr<Defaults>;
        using DefaultsSet = std::vector<DefaultsPtr>;
        using DefaultsSetIter = DefaultsSet::iterator;
        using DefaultsSetIterConst = DefaultsSet::const_iterator;
        inline DefaultsPtr makeDefaults() { return std::make_shared<Defaults>(); }
        class Defaults : public ElementInterface
        {
        public:
            Defaults();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Scaling minOccurs = 0, maxOccurs = 1 _________ */
            ScalingPtr getScaling() const;
            void setScaling( const ScalingPtr& value );
            bool getHasScaling() const;
            void setHasScaling( const bool value );
            /* _________ LayoutGroup minOccurs = 1, maxOccurs = 1 _________ */
            LayoutGroupPtr getLayoutGroup() const;
            void setLayoutGroup( const LayoutGroupPtr& value );
            /* _________ Appearance minOccurs = 0, maxOccurs = 1 _________ */
            AppearancePtr getAppearance() const;
            void setAppearance( const AppearancePtr& value );
            bool getHasAppearance() const;
            void setHasAppearance( const bool value );
            /* _________ MusicFont minOccurs = 0, maxOccurs = 1 _________ */
            MusicFontPtr getMusicFont() const;
            void setMusicFont( const MusicFontPtr& value );
            bool getHasMusicFont() const;
            void setHasMusicFont( const bool value );
            /* _________ WordFont minOccurs = 0, maxOccurs = 1 _________ */
            WordFontPtr getWordFont() const;
            void setWordFont( const WordFontPtr& value );
            bool getHasWordFont() const;
            void setHasWordFont( const bool value );
            /* _________ LyricFont minOccurs = 0, maxOccurs = unbounded _________ */
            const LyricFontSet& getLyricFontSet() const;
            void addLyricFont( const LyricFontPtr& value );
            void removeLyricFont( const LyricFontSetIterConst& value );
            void clearLyricFontSet();
            LyricFontPtr getLyricFont( const LyricFontSetIterConst& setIterator ) const;
            /* _________ LyricLanguage minOccurs = 0, maxOccurs = unbounded _________ */
            const LyricLanguageSet& getLyricLanguageSet() const;
            void addLyricLanguage( const LyricLanguagePtr& value );
            void removeLyricLanguage( const LyricLanguageSetIterConst& value );
            void clearLyricLanguageSet();
            LyricLanguagePtr getLyricLanguage( const LyricLanguageSetIterConst& setIterator ) const;
        private:
            ScalingPtr myScaling;
            bool myHasScaling;
            LayoutGroupPtr myLayoutGroup;
            AppearancePtr myAppearance;
            bool myHasAppearance;
            MusicFontPtr myMusicFont;
            bool myHasMusicFont;
            WordFontPtr myWordFont;
            bool myHasWordFont;
            LyricFontSet myLyricFontSet;
            LyricLanguageSet myLyricLanguageSet;
        };
        
        /* <!--  ID = 4929 [4929] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 14 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="ornaments" type="ornaments"/>
         <xs:complexType name="ornaments">
         <xs:annotation>
         <xs:documentation>OrnamentsChoice can be any of several types, followed optionally by accidentals. The accidental-mark element's content is represented the same as an accidental element, but with a different name to reflect the different musical meaning.</xs:documentation>
         </xs:annotation>
         <xs:sequence minOccurs="0" maxOccurs="unbounded">
         <xs:choice>
         <xs:element name="trill-mark" type="empty-trill-sound">
         <xs:annotation>
         <xs:documentation>The trill-mark element represents the trill-mark symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="turn" type="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The turn element is the normal turn shape which goes up then down.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="delayed-turn" type="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The delayed-turn element indicates a normal turn that is delayed until the end of the current note.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="inverted-turn" type="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The inverted-turn element has the shape which goes down and then up.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="delayed-inverted-turn" type="horizontal-turn">
         <xs:annotation>
         <xs:documentation>The delayed-inverted-turn element indicates an inverted turn that is delayed until the end of the current note.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="vertical-turn" type="empty-trill-sound">
         <xs:annotation>
         <xs:documentation>The vertical-turn element has the turn symbol shape arranged vertically going from upper left to lower right.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="shake" type="empty-trill-sound">
         <xs:annotation>
         <xs:documentation>The shake element has a similar appearance to an inverted-mordent element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="wavy-line" type="wavy-line"/>
         <xs:element name="mordent" type="mordent">
         <xs:annotation>
         <xs:documentation>The mordent element represents the sign with the vertical line. The long attribute is "no" by default.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="inverted-mordent" type="mordent">
         <xs:annotation>
         <xs:documentation>The inverted-mordent element represents the sign without the vertical line. The long attribute is "no" by default.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="schleifer" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The name for this ornament is based on the German, to avoid confusion with the more common slide element defined earlier.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="tremolo" type="tremolo"/>
         <xs:element name="other-ornament" type="placement-text">
         <xs:annotation>
         <xs:documentation>The other-ornament element is used to define any ornaments not yet in the MusicXML format. This allows extended representation, though without application interoperability.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:choice>
         <xs:element name="accidental-mark" type="accidental-mark" minOccurs="0" maxOccurs="unbounded"/>
         </xs:sequence>
         </xs:complexType> */
        
        class OrnamentsChoice;
        using OrnamentsChoicePtr = std::shared_ptr<OrnamentsChoice>;
        using OrnamentsChoiceUPtr = std::unique_ptr<OrnamentsChoice>;
        using OrnamentsChoiceSet = std::vector<OrnamentsChoicePtr>;
        using OrnamentsChoiceSetIter = OrnamentsChoiceSet::iterator;
        using OrnamentsChoiceSetIterConst = OrnamentsChoiceSet::const_iterator;
        inline OrnamentsChoicePtr makeOrnamentsChoice() { return std::make_shared<OrnamentsChoice>(); }
        class OrnamentsChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                trillMark = 1,
                turn = 2,
                delayedTurn = 3,
                invertedTurn = 4,
                delayedInvertedTurn = 5,
                verticalTurn = 6,
                shake = 7,
                wavyLine = 8,
                mordent = 9,
                invertedMordent = 10,
                schleifer = 11,
                tremolo = 12,
                otherOrnament = 13
            };
            OrnamentsChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice enum _________ */
            OrnamentsChoice::Choice getChoice() const;
            void setChoice( const OrnamentsChoice::Choice value );
            /* _________ TrillMark minOccurs = 1, maxOccurs = 1 _________ */
            TrillMarkPtr getTrillMark() const;
            void setTrillMark( const TrillMarkPtr& value );
            /* _________ Turn minOccurs = 1, maxOccurs = 1 _________ */
            TurnPtr getTurn() const;
            void setTurn( const TurnPtr& value );
            /* _________ DelayedTurn minOccurs = 1, maxOccurs = 1 _________ */
            DelayedTurnPtr getDelayedTurn() const;
            void setDelayedTurn( const DelayedTurnPtr& value );
            /* _________ InvertedTurn minOccurs = 1, maxOccurs = 1 _________ */
            InvertedTurnPtr getInvertedTurn() const;
            void setInvertedTurn( const InvertedTurnPtr& value );
            /* _________ DelayedInvertedTurn minOccurs = 1, maxOccurs = 1 _________ */
            DelayedInvertedTurnPtr getDelayedInvertedTurn() const;
            void setDelayedInvertedTurn( const DelayedInvertedTurnPtr& value );
            /* _________ VerticalTurn minOccurs = 1, maxOccurs = 1 _________ */
            VerticalTurnPtr getVerticalTurn() const;
            void setVerticalTurn( const VerticalTurnPtr& value );
            /* _________ Shake minOccurs = 1, maxOccurs = 1 _________ */
            ShakePtr getShake() const;
            void setShake( const ShakePtr& value );
            /* _________ WavyLine minOccurs = 1, maxOccurs = 1 _________ */
            WavyLinePtr getWavyLine() const;
            void setWavyLine( const WavyLinePtr& value );
            /* _________ Mordent minOccurs = 1, maxOccurs = 1 _________ */
            MordentPtr getMordent() const;
            void setMordent( const MordentPtr& value );
            /* _________ InvertedMordent minOccurs = 1, maxOccurs = 1 _________ */
            InvertedMordentPtr getInvertedMordent() const;
            void setInvertedMordent( const InvertedMordentPtr& value );
            /* _________ Schleifer minOccurs = 1, maxOccurs = 1 _________ */
            SchleiferPtr getSchleifer() const;
            void setSchleifer( const SchleiferPtr& value );
            /* _________ Tremolo minOccurs = 1, maxOccurs = 1 _________ */
            TremoloPtr getTremolo() const;
            void setTremolo( const TremoloPtr& value );
            /* _________ OtherOrnament minOccurs = 1, maxOccurs = 1 _________ */
            OtherOrnamentPtr getOtherOrnament() const;
            void setOtherOrnament( const OtherOrnamentPtr& value );
        private:
            Choice myChoice;
            TrillMarkPtr myTrillMark;
            TurnPtr myTurn;
            DelayedTurnPtr myDelayedTurn;
            InvertedTurnPtr myInvertedTurn;
            DelayedInvertedTurnPtr myDelayedInvertedTurn;
            VerticalTurnPtr myVerticalTurn;
            ShakePtr myShake;
            WavyLinePtr myWavyLine;
            MordentPtr myMordent;
            InvertedMordentPtr myInvertedMordent;
            SchleiferPtr mySchleifer;
            TremoloPtr myTremolo;
            OtherOrnamentPtr myOtherOrnament;
        };
        class Ornaments;
        using OrnamentsPtr = std::shared_ptr<Ornaments>;
        using OrnamentsUPtr = std::unique_ptr<Ornaments>;
        using OrnamentsSet = std::vector<OrnamentsPtr>;
        using OrnamentsSetIter = OrnamentsSet::iterator;
        using OrnamentsSetIterConst = OrnamentsSet::const_iterator;
        inline OrnamentsPtr makeOrnaments() { return std::make_shared<Ornaments>(); }
        class Ornaments : public ElementInterface
        {
        public:
            Ornaments();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ OrnamentsChoice minOccurs = 1, maxOccurs = 1 _________ */
            OrnamentsChoicePtr getOrnamentsChoice() const;
            void setOrnamentsChoice( const OrnamentsChoicePtr& value );
            /* _________ AccidentalMark minOccurs = 0, maxOccurs = unbounded _________ */
            const AccidentalMarkSet& getAccidentalMarkSet() const;
            void addAccidentalMark( const AccidentalMarkPtr& value );
            void removeAccidentalMark( const AccidentalMarkSetIterConst& value );
            void clearAccidentalMarkSet();
            AccidentalMarkPtr getAccidentalMark( const AccidentalMarkSetIterConst& setIterator ) const;
        private:
            OrnamentsChoicePtr myOrnamentsChoice;
            AccidentalMarkSet myAccidentalMarkSet;
        };
        
        /* <!--  ID = 5402 [5402] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 4 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="bend" type="bend"/>
         <xs:complexType name="bend">
         <xs:annotation>
         <xs:documentation>The bend type is used in guitar and tablature. The bend-alter element indicates the number of steps in the bend, similar to the alter element. As with the alter element, numbers like 0.5 can be used to indicate microtones. Negative numbers indicate pre-bends or releases; the pre-bend and release elements are used to distinguish what is intended. A with-bar element indicates that the bend is to be done at the bridge with a whammy or vibrato bar. The content of the element indicates how this should be notated.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="bend-alter" type="semitones">
         <xs:annotation>
         <xs:documentation>The bend-alter element indicates the number of steps in the bend, similar to the alter element. As with the alter element, numbers like 0.5 can be used to indicate microtones. Negative numbers indicate pre-bends or releases; the pre-bend and release elements are used to distinguish what is intended.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:choice minOccurs="0">
         <xs:element name="pre-bend" type="empty">
         <xs:annotation>
         <xs:documentation>The pre-bend element indicates that this is a pre-bend rather than a normal bend or a release.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="release" type="empty">
         <xs:annotation>
         <xs:documentation>The release element indicates that this is a release rather than a normal bend or pre-bend.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:choice>
         <xs:element name="with-bar" type="placement-text" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The with-bar element indicates that the bend is to be done at the bridge with a whammy or vibrato bar. The content of the element indicates how this should be notated.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="bend-sound"/>
         </xs:complexType> */
        
        class BendChoice;
        using BendChoicePtr = std::shared_ptr<BendChoice>;
        using BendChoiceUPtr = std::unique_ptr<BendChoice>;
        using BendChoiceSet = std::vector<BendChoicePtr>;
        using BendChoiceSetIter = BendChoiceSet::iterator;
        using BendChoiceSetIterConst = BendChoiceSet::const_iterator;
        inline BendChoicePtr makeBendChoice() { return std::make_shared<BendChoice>(); }
        class BendChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                preBend = 1,
                release = 2
            };
            BendChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BendChoice::Choice getChoice() const;
            void setChoice( BendChoice::Choice value );
            /* _________ PreBend minOccurs = 1, maxOccurs = 1 _________ */
            PreBendPtr getPreBend() const;
            void setPreBend( const PreBendPtr& value );
            /* _________ Release minOccurs = 1, maxOccurs = 1 _________ */
            ReleasePtr getRelease() const;
            void setRelease( const ReleasePtr& value );
        private:
            Choice myChoice;
            PreBendPtr myPreBend;
            ReleasePtr myRelease;
        };
        
        
        struct BendAttributes;
        using BendAttributesPtr = std::shared_ptr<BendAttributes>;
        
        struct BendAttributes : public AttributesInterface
        {
        public:
            BendAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::YesNo accelerate;
            t::TrillBeats beats;
            t::Percent firstBeat;
            t::Percent lastBeat;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasAccelerate;
            bool hasBeats;
            bool hasFirstBeat;
            bool hasLastBeat;
        };
        
        class Bend;
        using BendPtr = std::shared_ptr<Bend>;
        using BendUPtr = std::unique_ptr<Bend>;
        using BendSet = std::vector<BendPtr>;
        using BendSetIter = BendSet::iterator;
        using BendSetIterConst = BendSet::const_iterator;
        inline BendPtr makeBend() { return std::make_shared<Bend>(); }
        class Bend : public ElementInterface
        {
        public:
            Bend();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            BendAttributesPtr getAttributes() const;
            void setAttributes( const BendAttributesPtr& value );
            /* _________ BendAlter minOccurs = 1, maxOccurs = 1 _________ */
            BendAlterPtr getBendAlter() const;
            void setBendAlter( const BendAlterPtr& value );
            /* _________ BendChoice minOccurs = 1, maxOccurs = 1 _________ */
            BendChoicePtr getBendChoice() const;
            void setBendChoice( const BendChoicePtr& value );
            /* _________ WithBar minOccurs = 0, maxOccurs = 1 _________ */
            WithBarPtr getWithBar() const;
            void setWithBar( const WithBarPtr& value );
            bool getHasWithBar() const;
            void setHasWithBar( const bool value );
        private:
            BendAttributesPtr myAttributes;
            BendAlterPtr myBendAlter;
            BendChoicePtr myBendChoice;
            WithBarPtr myWithBar;
            bool myHasWithBar;
        };
        /* <!--  ID = 5424 [5424] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 3 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="arrow" type="arrow"/>
         <xs:complexType name="arrow">
         <xs:annotation>
         <xs:documentation>The arrow element represents an arrow used for a musical technical indication..</xs:documentation>
         </xs:annotation>
         <xs:choice>
         <xs:sequence>
         <xs:element name="arrow-direction" type="arrow-direction"/>
         <xs:element name="arrow-style" type="arrow-style" minOccurs="0"/>
         </xs:sequence>
         <xs:element name="circular-arrow" type="circular-arrow"/>
         </xs:choice>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType> */
        
        class ArrowGroup;
        using ArrowGroupPtr = std::shared_ptr<ArrowGroup>;
        using ArrowGroupUPtr = std::unique_ptr<ArrowGroup>;
        using ArrowGroupSet = std::vector<ArrowGroupPtr>;
        using ArrowGroupSetIter = ArrowGroupSet::iterator;
        using ArrowGroupSetIterConst = ArrowGroupSet::const_iterator;
        inline ArrowGroupPtr makeArrowGroup() { return std::make_shared<ArrowGroup>(); }
        class ArrowGroup : public ElementInterface
        {
        public:
            ArrowGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ ArrowDirection minOccurs = 1, maxOccurs = 1 _________ */
            ArrowDirectionPtr getArrowDirection() const;
            void setArrowDirection( const ArrowDirectionPtr& value );
            /* _________ ArrowStyle minOccurs = 0, maxOccurs = 1 _________ */
            ArrowStylePtr getArrowStyle() const;
            void setArrowStyle( const ArrowStylePtr& value );
            bool getHasArrowStyle() const;
            void setHasArrowStyle( const bool value );
        private:
            ArrowDirectionPtr myArrowDirection;
            ArrowStylePtr myArrowStyle;
            bool myHasArrowStyle;
        };
        
        struct ArrowAttributes;
        using ArrowAttributesPtr = std::shared_ptr<ArrowAttributes>;
        
        struct ArrowAttributes : public AttributesInterface
        {
        public:
            ArrowAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::AboveBelow placement;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasPlacement;
        };
        
        class Arrow;
        using ArrowPtr = std::shared_ptr<Arrow>;
        using ArrowUPtr = std::unique_ptr<Arrow>;
        using ArrowSet = std::vector<ArrowPtr>;
        using ArrowSetIter = ArrowSet::iterator;
        using ArrowSetIterConst = ArrowSet::const_iterator;
        inline ArrowPtr makeArrow() { return std::make_shared<Arrow>(); }
        class Arrow : public ElementInterface
        {
        public:
            enum class Choice
            {
                arrowGroup = 1,
                circularArrow = 2
            };
            Arrow();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            ArrowAttributesPtr getAttributes() const;
            void setAttributes( const ArrowAttributesPtr& value );
            /* _________ Choice _________ */
            Arrow::Choice getChoice() const;
            void setChoice( const Arrow::Choice value );
            /* _________ ArrowGroup minOccurs = 1, maxOccurs = 1 _________ */
            ArrowGroupPtr getArrowGroup() const;
            void setArrowGroup( const ArrowGroupPtr& value );
            /* _________ CircularArrow minOccurs = 1, maxOccurs = 1 _________ */
            CircularArrowPtr getCircularArrow() const;
            void setCircularArrow( const CircularArrowPtr& value );
        private:
            Choice myChoice;
            ArrowAttributesPtr myAttributes;
            ArrowGroupPtr myArrowGroup;
            CircularArrowPtr myCircularArrow;
        };
        /* <!--  ID = 5807 [5807] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="group-name-display" type="name-display" minOccurs="0">
         <xs:annotation>
         <xs:documentation>Formatting specified in the group-name-display element overrides formatting specified in the group-name element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="name-display">
         <xs:annotation>
         <xs:documentation>The name-display type is used for exact formatting of multi-font text in part and group names to the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the start of each system. Enclosure for the display-text element is none by default. Language for the display-text element is Italian ("it") by default.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="display-text" type="formatted-text"/>
         <xs:element name="accidental-text" type="accidental-text"/>
         </xs:choice>
         </xs:sequence>
         <xs:attributeGroup ref="print-object"/> */
        
        struct GroupNameDisplayAttributes;
        using GroupNameDisplayAttributesPtr = std::shared_ptr<GroupNameDisplayAttributes>;
        
        struct GroupNameDisplayAttributes : public AttributesInterface
        {
        public:
            GroupNameDisplayAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo printObject;
            bool hasPrintObject;
        };
        
        class GroupNameDisplay;
        using GroupNameDisplayPtr = std::shared_ptr<GroupNameDisplay>;
        using GroupNameDisplayUPtr = std::unique_ptr<GroupNameDisplay>;
        using GroupNameDisplaySet = std::vector<GroupNameDisplayPtr>;
        using GroupNameDisplaySetIter = GroupNameDisplaySet::iterator;
        using GroupNameDisplaySetIterConst = GroupNameDisplaySet::const_iterator;
        inline GroupNameDisplayPtr makeGroupNameDisplay() { return std::make_shared<GroupNameDisplay>(); }
        class GroupNameDisplay : public ElementInterface
        {
        public:
            enum class Choice
            {
                displayText = 1,
                accidentalText = 2
            };
            GroupNameDisplay();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            GroupNameDisplayAttributesPtr getAttributes() const;
            void setAttributes( const GroupNameDisplayAttributesPtr& value );
            /* _________ Choice _________ */
            GroupNameDisplay::Choice getChoice() const;
            void setChoice( const GroupNameDisplay::Choice value );
            /* _________ DisplayText minOccurs = 1, maxOccurs = 1 _________ */
            DisplayTextPtr getDisplayText() const;
            void setDisplayText( const DisplayTextPtr& value );
            /* _________ AccidentalText minOccurs = 1, maxOccurs = 1 _________ */
            AccidentalTextPtr getAccidentalText() const;
            void setAccidentalText( const AccidentalTextPtr& value );
        private:
            GroupNameDisplayAttributesPtr myAttributes;
            Choice myChoice;
            DisplayTextPtr myDisplayText;
            AccidentalTextPtr myAccidentalText;
        };
        
        /* <!--  ID = 5817 [5817] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="group-abbreviation-display" type="name-display" minOccurs="0">
         <xs:annotation>
         <xs:documentation>Formatting specified in the group-abbreviation-display element overrides formatting specified in the group-abbreviation element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="name-display">
         <xs:annotation>
         <xs:documentation>The name-display type is used for exact formatting of multi-font text in part and group names to the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the start of each system. Enclosure for the display-text element is none by default. Language for the display-text element is Italian ("it") by default.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="display-text" type="formatted-text"/>
         <xs:element name="accidental-text" type="accidental-text"/>
         </xs:choice>
         </xs:sequence>
         <xs:attributeGroup ref="print-object"/>
         </xs:complexType> */
        
        struct GroupAbbreviationDisplayAttributes;
        using GroupAbbreviationDisplayAttributesPtr = std::shared_ptr<GroupAbbreviationDisplayAttributes>;
        
        struct GroupAbbreviationDisplayAttributes : public AttributesInterface
        {
        public:
            GroupAbbreviationDisplayAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo printObject;
            bool hasPrintObject;
        };
        
        class GroupAbbreviationDisplay;
        using GroupAbbreviationDisplayPtr = std::shared_ptr<GroupAbbreviationDisplay>;
        using GroupAbbreviationDisplayUPtr = std::unique_ptr<GroupAbbreviationDisplay>;
        using GroupAbbreviationDisplaySet = std::vector<GroupAbbreviationDisplayPtr>;
        using GroupAbbreviationDisplaySetIter = GroupAbbreviationDisplaySet::iterator;
        using GroupAbbreviationDisplaySetIterConst = GroupAbbreviationDisplaySet::const_iterator;
        inline GroupAbbreviationDisplayPtr makeGroupAbbreviationDisplay() { return std::make_shared<GroupAbbreviationDisplay>(); }
        class GroupAbbreviationDisplay : public ElementInterface
        {
        public:
            enum class Choice
            {
                displayText = 1,
                accidentalText = 2
            };
            GroupAbbreviationDisplay();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            GroupAbbreviationDisplayAttributesPtr getAttributes() const;
            void setAttributes( const GroupAbbreviationDisplayAttributesPtr& value );
            /* _________ Choice _________ */
            GroupAbbreviationDisplay::Choice getChoice() const;
            void setChoice( const GroupAbbreviationDisplay::Choice value );
            /* _________ DisplayText minOccurs = 1, maxOccurs = 1 _________ */
            DisplayTextPtr getDisplayText() const;
            void setDisplayText( const DisplayTextPtr& value );
            /* _________ AccidentalText minOccurs = 1, maxOccurs = 1 _________ */
            AccidentalTextPtr getAccidentalText() const;
            void setAccidentalText( const AccidentalTextPtr& value );
        private:
            GroupAbbreviationDisplayAttributesPtr myAttributes;
            Choice myChoice;
            DisplayTextPtr myDisplayText;
            AccidentalTextPtr myAccidentalText;
        };
        /* <!--  ID = 5921 [5921, 6375] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 12 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="identification" type="identification" minOccurs="0"/>
         <xs:complexType name="identification">
         <xs:annotation>
         <xs:documentation>Identification contains basic metadata about the score. It includes the information in MuseData headers that may apply at a score-wide, movement-wide, or part-wide level. The creator, rights, source, and relation elements are based on Dublin Core.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="creator" type="typed-text" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The creator element is borrowed from Dublin Core. It is used for the creators of the score. The type attribute is used to distinguish different creative contributions. Thus, there can be multiple creators within an identification. Standard type values are composer, lyricist, and arranger. Other type values may be used for different types of creative roles. The type attribute should usually be used even if there is just a single creator element. The MusicXML format does not use the creator / contributor distinction from Dublin Core.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="rights" type="typed-text" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The rights element is borrowed from Dublin Core. It contains copyright and other intellectual property notices. Words, music, and derivatives can have different types, so multiple rights tags with different type attributes are supported. Standard type values are music, words, and arrangement, but other types may be used. The type attribute is only needed when there are multiple rights elements.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="encoding" type="encoding" minOccurs="0"/>
         <xs:element name="source" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The source for the music that is encoded. This is similar to the Dublin Core source element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="relation" type="typed-text" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>A related resource for the music that is encoded. This is similar to the Dublin Core relation element. Standard type values are music, words, and arrangement, but other types may be used.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="miscellaneous" type="miscellaneous" minOccurs="0"/>
         </xs:sequence>
         </xs:complexType> */
        
        class Identification;
        using IdentificationPtr = std::shared_ptr<Identification>;
        using IdentificationUPtr = std::unique_ptr<Identification>;
        using IdentificationSet = std::vector<IdentificationPtr>;
        using IdentificationSetIter = IdentificationSet::iterator;
        using IdentificationSetIterConst = IdentificationSet::const_iterator;
        inline IdentificationPtr makeIdentification() { return std::make_shared<Identification>(); }
        class Identification : public ElementInterface
        {
        public:
            Identification();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Creator minOccurs = 0, maxOccurs = unbounded _________ */
            const CreatorSet& getCreatorSet() const;
            void addCreator( const CreatorPtr& value );
            void removeCreator( const CreatorSetIterConst& value );
            void clearCreatorSet();
            CreatorPtr getCreator( const CreatorSetIterConst& setIterator ) const;
            /* _________ Rights minOccurs = 0, maxOccurs = unbounded _________ */
            const RightsSet& getRightsSet() const;
            void addRights( const RightsPtr& value );
            void removeRights( const RightsSetIterConst& value );
            void clearRightsSet();
            RightsPtr getRights( const RightsSetIterConst& setIterator ) const;
            /* _________ Encoding minOccurs = 0, maxOccurs = 1 _________ */
            EncodingPtr getEncoding() const;
            void setEncoding( const EncodingPtr& value );
            bool getHasEncoding() const;
            void setHasEncoding( const bool value );
            /* _________ Source minOccurs = 0, maxOccurs = 1 _________ */
            SourcePtr getSource() const;
            void setSource( const SourcePtr& value );
            bool getHasSource() const;
            void setHasSource( const bool value );
            /* _________ Relation minOccurs = 0, maxOccurs = unbounded _________ */
            const RelationSet& getRelationSet() const;
            void addRelation( const RelationPtr& value );
            void removeRelation( const RelationSetIterConst& value );
            void clearRelationSet();
            RelationPtr getRelation( const RelationSetIterConst& setIterator ) const;
            /* _________ Miscellaneous minOccurs = 0, maxOccurs = 1 _________ */
            MiscellaneousPtr getMiscellaneous() const;
            void setMiscellaneous( const MiscellaneousPtr& value );
            bool getHasMiscellaneous() const;
            void setHasMiscellaneous( const bool value );
        private:
            CreatorSet myCreatorSet;
            RightsSet myRightsSet;
            EncodingPtr myEncoding;
            bool myHasEncoding;
            SourcePtr mySource;
            bool myHasSource;
            RelationSet myRelationSet;
            MiscellaneousPtr myMiscellaneous;
            bool myHasMiscellaneous;
        };
        
        /* 5936 [ equivalents 3861, 5936 ]
         <!--  ID = 5936 [3861, 5936] ------------------------->
         <!-- min=0 max=1 OptionalSingleOccurrence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 2 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="part-abbreviation-display" type="name-display" minOccurs="0"/>
         <xs:complexType name="name-display">
         <xs:annotation>
         <xs:documentation>The name-display type is used for exact formatting of multi-font text in part and group names to the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the start of each system. Enclosure for the display-text element is none by default. Language for the display-text element is Italian ("it") by default.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="display-text" type="formatted-text"/>
         <xs:element name="accidental-text" type="accidental-text"/>
         </xs:choice>
         </xs:sequence>
         <xs:attributeGroup ref="print-object"/>
         </xs:complexType> */
        struct PartAbbreviationDisplayAttributes;
        using PartAbbreviationDisplayAttributesPtr = std::shared_ptr<PartAbbreviationDisplayAttributes>;
        
        struct PartAbbreviationDisplayAttributes : public AttributesInterface
        {
        public:
            PartAbbreviationDisplayAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo printObject;
            bool hasPrintObject;
        };
        
        class PartAbbreviationDisplay;
        using PartAbbreviationDisplayPtr = std::shared_ptr<PartAbbreviationDisplay>;
        using PartAbbreviationDisplayUPtr = std::unique_ptr<PartAbbreviationDisplay>;
        using PartAbbreviationDisplaySet = std::vector<PartAbbreviationDisplayPtr>;
        using PartAbbreviationDisplaySetIter = PartAbbreviationDisplaySet::iterator;
        using PartAbbreviationDisplaySetIterConst = PartAbbreviationDisplaySet::const_iterator;
        inline PartAbbreviationDisplayPtr makePartAbbreviationDisplay() { return std::make_shared<PartAbbreviationDisplay>(); }
        class PartAbbreviationDisplay : public ElementInterface
        {
        public:
            enum class Choice
            {
                displayText = 1,
                accidentalText = 2
            };
            PartAbbreviationDisplay();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PartAbbreviationDisplayAttributesPtr getAttributes() const;
            void setAttributes( const PartAbbreviationDisplayAttributesPtr& value );
            /* _________ Choice _________ */
            PartAbbreviationDisplay::Choice getChoice() const;
            void setChoice( const PartAbbreviationDisplay::Choice value );
            /* _________ DisplayText minOccurs = 1, maxOccurs = 1 _________ */
            DisplayTextPtr getDisplayText() const;
            void setDisplayText( const DisplayTextPtr& value );
            /* _________ AccidentalText minOccurs = 1, maxOccurs = 1 _________ */
            AccidentalTextPtr getAccidentalText() const;
            void setAccidentalText( const AccidentalTextPtr& value );
        private:
            PartAbbreviationDisplayAttributesPtr myAttributes;
            Choice myChoice;
            DisplayTextPtr myDisplayText;
            AccidentalTextPtr myAccidentalText;
        };
        
        /* <!--  ID = 5947 [5947] ------------------------->
         <!-- min=0 max=4294967295 ZeroOrMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 8 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="score-instrument" type="score-instrument" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="score-instrument">
         <xs:annotation>
         <xs:documentation>The score-instrument type represents a single instrument within a score-part. As with the score-part type, each score-instrument has a required ID attribute, a name, and an optional abbreviation.
         
         A score-instrument type is also required if the score specifies MIDI 1.0 channels, banks, or programs. An initial midi-instrument assignment can also be made here. MusicXML software should be able to automatically assign reasonable channels and instruments without these elements in simple cases, such as where part names match General MIDI instrument names.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="instrument-name" type="xs:string">
         <xs:annotation>
         <xs:documentation>The instrument-name element is typically used within a software application, rather than appearing on the printed page of a score.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="instrument-abbreviation" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The optional instrument-abbreviation element is typically used within a software application, rather than appearing on the printed page of a score.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="instrument-sound" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The instrument-sound element describes the default timbre of the score-instrument. This description is independent of a particular virtual or MIDI instrument specification and allows playback to be shared more easily between applications and libraries.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:choice minOccurs="0">
         <xs:element name="solo" type="empty">
         <xs:annotation>
         <xs:documentation>The solo element was added in Version 2.0. It is present if performance is intended by a solo instrument.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="ensemble" type="positive-integer-or-empty">
         <xs:annotation>
         <xs:documentation>The ensemble element was added in Version 2.0. It is present if performance is intended by an ensemble such as an orchestral section. The text of the ensemble element contains the size of the section, or is empty if the ensemble size is not specified.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:choice>
         <xs:element name="virtual-instrument" type="virtual-instrument" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="id" type="xs:ID" use="required"/>
         </xs:complexType> */
        
        class SoloOrEnsemble;
        using SoloOrEnsemblePtr = std::shared_ptr<SoloOrEnsemble>;
        using SoloOrEnsembleUPtr = std::unique_ptr<SoloOrEnsemble>;
        using SoloOrEnsembleSet = std::vector<SoloOrEnsemblePtr>;
        using SoloOrEnsembleSetIter = SoloOrEnsembleSet::iterator;
        using SoloOrEnsembleSetIterConst = SoloOrEnsembleSet::const_iterator;
        inline SoloOrEnsemblePtr makeSoloOrEnsemble() { return std::make_shared<SoloOrEnsemble>(); }
        class SoloOrEnsemble : public ElementInterface
        {
        public:
            enum class Choice
            {
                solo = 1,
                ensemble = 2
            };
            SoloOrEnsemble();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice  _________ */
            SoloOrEnsemble::Choice getChoice() const;
            void setChoice( const SoloOrEnsemble::Choice value );
            /* _________ Solo minOccurs = 1, maxOccurs = 1 _________ */
            SoloPtr getSolo() const;
            void setSolo( const SoloPtr& value );
            /* _________ Ensemble minOccurs = 1, maxOccurs = 1 _________ */
            EnsemblePtr getEnsemble() const;
            void setEnsemble( const EnsemblePtr& value );
        private:
            Choice myChoice;
            SoloPtr mySolo;
            EnsemblePtr myEnsemble;
        };
        
        struct ScoreInstrumentAttributes;
        using ScoreInstrumentAttributesPtr = std::shared_ptr<ScoreInstrumentAttributes>;
        
        struct ScoreInstrumentAttributes : public AttributesInterface
        {
        public:
            ScoreInstrumentAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsID id;
            const 	bool hasId;
        };
        
        class ScoreInstrument;
        using ScoreInstrumentPtr = std::shared_ptr<ScoreInstrument>;
        using ScoreInstrumentUPtr = std::unique_ptr<ScoreInstrument>;
        using ScoreInstrumentSet = std::vector<ScoreInstrumentPtr>;
        using ScoreInstrumentSetIter = ScoreInstrumentSet::iterator;
        using ScoreInstrumentSetIterConst = ScoreInstrumentSet::const_iterator;
        inline ScoreInstrumentPtr makeScoreInstrument() { return std::make_shared<ScoreInstrument>(); }
        class ScoreInstrument : public ElementInterface
        {
        public:
            ScoreInstrument();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            ScoreInstrumentAttributesPtr getAttributes() const;
            void setAttributes( const ScoreInstrumentAttributesPtr& value );
            /* _________ InstrumentName minOccurs = 1, maxOccurs = 1 _________ */
            InstrumentNamePtr getInstrumentName() const;
            void setInstrumentName( const InstrumentNamePtr& value );
            /* _________ InstrumentAbbreviation minOccurs = 0, maxOccurs = 1 _________ */
            InstrumentAbbreviationPtr getInstrumentAbbreviation() const;
            void setInstrumentAbbreviation( const InstrumentAbbreviationPtr& value );
            bool getHasInstrumentAbbreviation() const;
            void setHasInstrumentAbbreviation( const bool value );
            /* _________ SoloOrEnsemble minOccurs = 0, maxOccurs = 1 _________ */
            SoloOrEnsemblePtr getSoloOrEnsemble() const;
            void setSoloOrEnsemble( const SoloOrEnsemblePtr& value );
            bool getHasSoloOrEnsemble() const;
            void setHasSoloOrEnsemble( const bool value );
            /* _________ InstrumentSound minOccurs = 0, maxOccurs = 1 _________ */
            InstrumentSoundPtr getInstrumentSound() const;
            void setInstrumentSound( const InstrumentSoundPtr& value );
            bool getHasInstrumentSound() const;
            void setHasInstrumentSound( const bool value );
            /* _________ VirtualInstrument minOccurs = 0, maxOccurs = 1 _________ */
            VirtualInstrumentPtr getVirtualInstrument() const;
            void setVirtualInstrument( const VirtualInstrumentPtr& value );
            bool getHasVirtualInstrument() const;
            void setHasVirtualInstrument( const bool value );
        private:
            ScoreInstrumentAttributesPtr myAttributes;
            InstrumentNamePtr myInstrumentName;
            InstrumentAbbreviationPtr myInstrumentAbbreviation;
            bool myHasInstrumentAbbreviation;
            InstrumentSoundPtr myInstrumentSound;
            bool myHasInstrumentSound;
            SoloOrEnsemblePtr mySoloOrEnsemble;
            bool myHasSoloOrEnsemble;
            VirtualInstrumentPtr myVirtualInstrument;
            bool myHasVirtualInstrument;
        };
        
        /* <!--  ID = 6322 [6322] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 26 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="harmony" type="harmony"/>
         <xs:complexType name="harmony">
         <xs:annotation>
         <xs:documentation>The harmony type is based on Humdrum's **harm encoding, extended to support chord symbols in popular music as well as functional harmony analysis in classical music.
         
         If there are alternate harmonies possible, this can be specified using multiple harmony elements differentiated by type. Explicit harmonies have all note present in the music; implied have some notes missing but implied; alternate represents alternate analyses.
         
         The harmony object may be used for analysis or for chord symbols. The print-object attribute controls whether or not anything is printed due to the harmony element. The print-frame attribute controls printing of a frame or fretboard diagram. The print-style attribute group sets the default for the harmony, but individual elements can override this with their own print-style values.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="harmony-chord" maxOccurs="unbounded"/>
         <xs:element name="frame" type="frame" minOccurs="0"/>
         <xs:element name="offset" type="offset" minOccurs="0"/>
         <xs:group ref="editorial"/>
         <xs:group ref="staff" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="type" type="harmony-type"/>
         <xs:attributeGroup ref="print-object"/>
         <xs:attribute name="print-frame" type="yes-no"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType>
         
         <xs:group name="harmony-chord">
         <xs:annotation>
         <xs:documentation>A harmony element can contain many stacked chords (e.g. V of II). A sequence of harmony-chord groups is used for this type of secondary function, where V of II would be represented by a harmony-chord with a V function followed by a harmony-chord with a II function.
         
         A root is a pitch name like C, D, E, where a function is an indication like I, II, III. It is an either/or choice to avoid data inconsistency.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice>
         <xs:element name="root" type="root"/>
         <xs:element name="function" type="style-text">
         <xs:annotation>
         <xs:documentation>The function element is used to represent classical functional harmony with an indication like I, II, III rather than C, D, E. It is relative to the key that is specified in the MusicXML encoding.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:choice>
         <xs:element name="kind" type="kind"/>
         <xs:element name="inversion" type="inversion" minOccurs="0"/>
         <xs:element name="bass" type="bass" minOccurs="0"/>
         <xs:element name="degree" type="degree" minOccurs="0" maxOccurs="unbounded"/>
         </xs:sequence>
         </xs:group>
         
         <xs:group name="editorial">
         <xs:annotation>
         <xs:documentation>The editorial group specifies editorial information for a musical element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         </xs:sequence>
         </xs:group>
         
         <xs:group name="staff">
         <xs:annotation>
         <xs:documentation>The staff element is defined within a group due to its use by both notes and direction elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="staff" type="xs:positiveInteger">
         <xs:annotation>
         <xs:documentation>Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group> */
        
        class HarmonyChordGroup;
        using HarmonyChordGroupPtr = std::shared_ptr<HarmonyChordGroup>;
        using HarmonyChordGroupUPtr = std::unique_ptr<HarmonyChordGroup>;
        using HarmonyChordGroupSet = std::vector<HarmonyChordGroupPtr>;
        using HarmonyChordGroupSetIter = HarmonyChordGroupSet::iterator;
        using HarmonyChordGroupSetIterConst = HarmonyChordGroupSet::const_iterator;
        inline HarmonyChordGroupPtr makeHarmonyChordGroup() { return std::make_shared<HarmonyChordGroup>(); }
        class HarmonyChordGroup : public ElementInterface
        {
        public:
            enum class Choice
            {
                root = 1,
                function = 2
            };
            HarmonyChordGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* Choice */
            HarmonyChordGroup::Choice getChoice() const;
            void setChoice( const HarmonyChordGroup::Choice value );
            /* _________ Root minOccurs = 1, maxOccurs = 1 _________ */
            RootPtr getRoot() const;
            void setRoot( const RootPtr& value );
            /* _________ Function minOccurs = 1, maxOccurs = 1 _________ */
            FunctionPtr getFunction() const;
            void setFunction( const FunctionPtr& value );
            /* _________ Kind minOccurs = 1, maxOccurs = 1 _________ */
            KindPtr getKind() const;
            void setKind( const KindPtr& value );
            /* _________ Inversion minOccurs = 0, maxOccurs = 1 _________ */
            InversionPtr getInversion() const;
            void setInversion( const InversionPtr& value );
            bool getHasInversion() const;
            void setHasInversion( const bool value );
            /* _________ Bass minOccurs = 0, maxOccurs = 1 _________ */
            BassPtr getBass() const;
            void setBass( const BassPtr& value );
            bool getHasBass() const;
            void setHasBass( const bool value );
            /* _________ Degree minOccurs = 0, maxOccurs = unbounded _________ */
            const DegreeSet& getDegreeSet() const;
            void addDegree( const DegreePtr& value );
            void removeDegree( const DegreeSetIterConst& value );
            void clearDegreeSet();
            DegreePtr getDegree( const DegreeSetIterConst& setIterator ) const;
        private:
            Choice myChoice;
            RootPtr myRoot;
            FunctionPtr myFunction;
            KindPtr myKind;
            InversionPtr myInversion;
            bool myHasInversion;
            BassPtr myBass;
            bool myHasBass;
            DegreeSet myDegreeSet;
        };
        
        struct HarmonyAttributes;
        using HarmonyAttributesPtr = std::shared_ptr<HarmonyAttributes>;
        
        struct HarmonyAttributes : public AttributesInterface
        {
        public:
            HarmonyAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::HarmonyType type;
            t::YesNo printObject;
            t::YesNo printFrame;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::AboveBelow placement;
            bool hasType;
            bool hasPrintObject;
            bool hasPrintFrame;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasPlacement;
        };
        
        class Harmony;
        using HarmonyPtr = std::shared_ptr<Harmony>;
        using HarmonyUPtr = std::unique_ptr<Harmony>;
        using HarmonySet = std::vector<HarmonyPtr>;
        using HarmonySetIter = HarmonySet::iterator;
        using HarmonySetIterConst = HarmonySet::const_iterator;
        inline HarmonyPtr makeHarmony() { return std::make_shared<Harmony>(); }
        class Harmony : public ElementInterface
        {
        public:
            Harmony();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            HarmonyAttributesPtr getAttributes() const;
            void setAttributes( const HarmonyAttributesPtr& value );
            /* _________ HarmonyChordGroup minOccurs = 1, maxOccurs = unbounded _________ */
            const HarmonyChordGroupSet& getHarmonyChordGroupSet() const;
            void addHarmonyChordGroup( const HarmonyChordGroupPtr& value );
            void removeHarmonyChordGroup( const HarmonyChordGroupSetIterConst& value );
            void clearHarmonyChordGroupSet();
            HarmonyChordGroupPtr getHarmonyChordGroup( const HarmonyChordGroupSetIterConst& setIterator ) const;
            /* _________ Frame minOccurs = 0, maxOccurs = 1 _________ */
            FramePtr getFrame() const;
            void setFrame( const FramePtr& value );
            bool getHasFrame() const;
            void setHasFrame( const bool value );
            /* _________ Offset minOccurs = 0, maxOccurs = 1 _________ */
            OffsetPtr getOffset() const;
            void setOffset( const OffsetPtr& value );
            bool getHasOffset() const;
            void setHasOffset( const bool value );
            /* _________ EditorialGroup minOccurs = 1, maxOccurs = 1 _________ */
            EditorialGroupPtr getEditorialGroup() const;
            void setEditorialGroup( const EditorialGroupPtr& value );
            /* _________ Staff minOccurs = 0, maxOccurs = 1 _________ */
            StaffPtr getStaff() const;
            void setStaff( const StaffPtr& value );
            bool getHasStaff() const;
            void setHasStaff( const bool value );
        private:
            HarmonyAttributesPtr myAttributes;
            HarmonyChordGroupSet myHarmonyChordGroupSet;
            FramePtr myFrame;
            bool myHasFrame;
            OffsetPtr myOffset;
            bool myHasOffset;
            EditorialGroupPtr myEditorialGroup;
            StaffPtr myStaff;
            bool myHasStaff;
        };
        
        class CreditWordsGroup;
        using CreditWordsGroupPtr = std::shared_ptr<CreditWordsGroup>;
        using CreditWordsGroupUPtr = std::unique_ptr<CreditWordsGroup>;
        using CreditWordsGroupSet = std::vector<CreditWordsGroupPtr>;
        using CreditWordsGroupSetIter = CreditWordsGroupSet::iterator;
        using CreditWordsGroupSetIterConst = CreditWordsGroupSet::const_iterator;
        inline CreditWordsGroupPtr makeCreditWordsGroup() { return std::make_shared<CreditWordsGroup>(); }
        class CreditWordsGroup : public ElementInterface
        {
        public:
            CreditWordsGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ LinkSet minOccurs = 0, maxOccurs = unbounded _________ */
            const LinkSet& getLinkSet() const;
            void addLink( const LinkPtr& value );
            void removeLink( const LinkSetIterConst& value );
            void clearLinkSet();
            LinkPtr getLink( const LinkSetIterConst& setIterator ) const;
            /* _________ Bookmark minOccurs = 0, maxOccurs = unbounded _________ */
            const BookmarkSet& getBookmarkSet() const;
            void addBookmark( const BookmarkPtr& value );
            void removeBookmark( const BookmarkSetIterConst& value );
            void clearBookmarkSet();
            BookmarkPtr getBookmark( const BookmarkSetIterConst& setIterator ) const;
            /* _________ CreditWords minOccurs = 1, maxOccurs = 1 _________ */
            CreditWordsPtr getCreditWords() const;
            void setCreditWords( const CreditWordsPtr& value );
        private:
            LinkSet myLinkSet;
            BookmarkSet myBookmarkSet;
            CreditWordsPtr myCreditWords;
        };
        
        class CreditChoice;
        using CreditChoicePtr = std::shared_ptr<CreditChoice>;
        using CreditChoiceUPtr = std::unique_ptr<CreditChoice>;
        using CreditChoiceSet = std::vector<CreditChoicePtr>;
        using CreditChoiceSetIter = CreditChoiceSet::iterator;
        using CreditChoiceSetIterConst = CreditChoiceSet::const_iterator;
        inline CreditChoicePtr makeCreditChoice() { return std::make_shared<CreditChoice>(); }
        class CreditChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                creditImage = 1,
                creditWords = 2
            };
            CreditChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice minOccurs = 1, maxOccurs = 1 _________ */
            CreditChoice::Choice getChoice() const;
            void setChoice( const CreditChoice::Choice value );
            /* _________ CreditImage minOccurs = 1, maxOccurs = 1 _________ */
            CreditImagePtr getCreditImage() const;
            void setCreditImage( const CreditImagePtr& value );
            /* _________ CreditWordsGroup minOccurs = 1, maxOccurs = 1 _________ */
            CreditWordsGroupPtr getCreditWordsGroup() const;
            void setCreditWordsGroup( const CreditWordsGroupPtr& value );
        private:
            Choice myChoice;
            CreditImagePtr myCreditImage;
            CreditWordsGroupPtr myCreditWordsGroup;
        };
        
        /*
         6383
         
         
         <!--  ID = 6383 [6383] ------------------------->
         <!-- min=0 max=4294967295 ZeroOrMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 8 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="credit" type="credit" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="credit">
         <xs:annotation>
         <xs:documentation>The credit type represents the appearance of the title, composer, arranger, lyricist, copyright, dedication, and other text and graphics that commonly appears on the first page of a score. The credit-words and credit-image elements are similar to the words and image elements for directions. However, since the credit is not part of a measure, the default-x and default-y attributes adjust the origin relative to the bottom left-hand corner of the first page. The enclosure for credit-words is none by default.
         
         By default, a series of credit-words elements within a single credit element follow one another in sequence visually. Non-positional formatting attributes are carried over from the previous element by default.
         
         The page attribute for the credit element, new in Version 2.0, specifies the page number where the credit should appear. This is an integer value that starts with 1 for the first page. Its value is 1 by default. Since credits occur before the music, these page numbers do not refer to the page numbering specified by the print element's page-number attribute.
         
         The credit-type element, new in Version 3.0, indicates the purpose behind a credit. Multiple types of data may be combined in a single credit, so multiple elements may be used. Standard values include page number, title, subtitle, composer, arranger, lyricist, and rights.
         </xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="credit-type" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="link" type="link" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="bookmark" type="bookmark" minOccurs="0" maxOccurs="unbounded"/>
         <xs:choice>
         <xs:element name="credit-image" type="image"/>
         <xs:sequence>
         <xs:element name="credit-words" type="formatted-text"/>
         <xs:sequence minOccurs="0" maxOccurs="unbounded">
         <xs:element name="link" type="link" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="bookmark" type="bookmark" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="credit-words" type="formatted-text"/>
         </xs:sequence>
         </xs:sequence>
         </xs:choice>
         </xs:sequence>
         <xs:attribute name="page" type="xs:positiveInteger"/>
         </xs:complexType>
         
         */
        
        struct CreditAttributes;
        using CreditAttributesPtr = std::shared_ptr<CreditAttributes>;
        
        struct CreditAttributes : public AttributesInterface
        {
        public:
            CreditAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::PositiveInteger page;
            bool hasPage;
        };
        
        class Credit;
        using CreditPtr = std::shared_ptr<Credit>;
        using CreditUPtr = std::unique_ptr<Credit>;
        using CreditSet = std::vector<CreditPtr>;
        using CreditSetIter = CreditSet::iterator;
        using CreditSetIterConst = CreditSet::const_iterator;
        inline CreditPtr makeCredit() { return std::make_shared<Credit>(); }
        class Credit : public ElementInterface
        {
        public:
            Credit();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            CreditAttributesPtr getAttributes() const;
            void setAttributes( const CreditAttributesPtr& value );
            /* _________ CreditType minOccurs = 0, maxOccurs = unbounded _________ */
            const CreditTypeSet& getCreditTypeSet() const;
            void addCreditType( const CreditTypePtr& value );
            void removeCreditType( const CreditTypeSetIterConst& value );
            void clearCreditTypeSet();
            CreditTypePtr getCreditType( const CreditTypeSetIterConst& setIterator ) const;
            /* _________ Link minOccurs = 0, maxOccurs = unbounded _________ */
            const LinkSet& getLinkSet() const;
            void addLink( const LinkPtr& value );
            void removeLink( const LinkSetIterConst& value );
            void clearLinkSet();
            LinkPtr getLink( const LinkSetIterConst& setIterator ) const;
            /* _________ Bookmark minOccurs = 0, maxOccurs = unbounded _________ */
            const BookmarkSet& getBookmarkSet() const;
            void addBookmark( const BookmarkPtr& value );
            void removeBookmark( const BookmarkSetIterConst& value );
            void clearBookmarkSet();
            BookmarkPtr getBookmark( const BookmarkSetIterConst& setIterator ) const;
            /* _________ CreditChoice minOccurs = 1, maxOccurs = 1 _________ */
            CreditChoicePtr getCreditChoice() const;
            void setCreditChoice( const CreditChoicePtr& value );
        private:
            CreditAttributesPtr myAttributes;
            CreditTypeSet myCreditTypeSet;
            LinkSet myLinkSet;
            BookmarkSet myBookmarkSet;
            CreditChoicePtr myCreditChoice;
        };
        
        class HarmonicTypeChoice;
        using HarmonicTypeChoicePtr = std::shared_ptr<HarmonicTypeChoice>;
        using HarmonicTypeChoiceUPtr = std::unique_ptr<HarmonicTypeChoice>;
        using HarmonicTypeChoiceSet = std::vector<HarmonicTypeChoicePtr>;
        using HarmonicTypeChoiceSetIter = HarmonicTypeChoiceSet::iterator;
        using HarmonicTypeChoiceSetIterConst = HarmonicTypeChoiceSet::const_iterator;
        inline HarmonicTypeChoicePtr makeHarmonicTypeChoice() { return std::make_shared<HarmonicTypeChoice>(); }
        class HarmonicTypeChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                natural = 1,
                artificial = 2
            };
            HarmonicTypeChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice minOccurs = 1, maxOccurs = 1 _________ */
            HarmonicTypeChoice::Choice getChoice() const;
            void setChoice( const HarmonicTypeChoice::Choice value );
            /* _________ Natural minOccurs = 1, maxOccurs = 1 _________ */
            NaturalPtr getNatural() const;
            void setNatural( const NaturalPtr& value );
            /* _________ Artificial minOccurs = 1, maxOccurs = 1 _________ */
            ArtificialPtr getArtificial() const;
            void setArtificial( const ArtificialPtr& value );
        private:
            Choice myChoice;
            NaturalPtr myNatural;
            ArtificialPtr myArtificial;
        };
        
        class HarmonicInfoChoice;
        using HarmonicInfoChoicePtr = std::shared_ptr<HarmonicInfoChoice>;
        using HarmonicInfoChoiceUPtr = std::unique_ptr<HarmonicInfoChoice>;
        using HarmonicInfoChoiceSet = std::vector<HarmonicInfoChoicePtr>;
        using HarmonicInfoChoiceSetIter = HarmonicInfoChoiceSet::iterator;
        using HarmonicInfoChoiceSetIterConst = HarmonicInfoChoiceSet::const_iterator;
        inline HarmonicInfoChoicePtr makeHarmonicInfoChoice() { return std::make_shared<HarmonicInfoChoice>(); }
        class HarmonicInfoChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                basePitch = 1,
                touchingPitch = 2,
                soundingPitch = 3
            };
            HarmonicInfoChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice minOccurs = 1, maxOccurs = 1 _________ */
            HarmonicInfoChoice::Choice getChoice() const;
            void setChoice( const HarmonicInfoChoice::Choice value );
            /* _________ BasePitch minOccurs = 1, maxOccurs = 1 _________ */
            BasePitchPtr getBasePitch() const;
            void setBasePitch( const BasePitchPtr& value );
            /* _________ TouchingPitch minOccurs = 1, maxOccurs = 1 _________ */
            TouchingPitchPtr getTouchingPitch() const;
            void setTouchingPitch( const TouchingPitchPtr& value );
            /* _________ SoundingPitch minOccurs = 1, maxOccurs = 1 _________ */
            SoundingPitchPtr getSoundingPitch() const;
            void setSoundingPitch( const SoundingPitchPtr& value );
        private:
            Choice myChoice;
            BasePitchPtr myBasePitch;
            TouchingPitchPtr myTouchingPitch;
            SoundingPitchPtr mySoundingPitch;
        };
        
        /* <!--  ID = 5349 [5349] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 5 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="harmonic" type="harmonic"/>
         <xs:complexType name="harmonic">
         <xs:annotation>
         <xs:documentation>The harmonic type indicates natural and artificial harmonics. Allowing the type of pitch to be specified, combined with controls for appearance/playback differences, allows both the notation and the sound to be represented. Artificial harmonics can add a notated touching-pitch; artificial pinch harmonics will usually not notate a touching pitch. The attributes for the harmonic element refer to the use of the circular harmonic symbol, typically but not always used with natural harmonics.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice minOccurs="0">
         <xs:element name="natural" type="empty">
         <xs:annotation>
         <xs:documentation>The natural element indicates that this is a natural harmonic. These are usually notated at base pitch rather than sounding pitch.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="artificial" type="empty">
         <xs:annotation>
         <xs:documentation>The artificial element indicates that this is an artificial harmonic.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:choice>
         <xs:choice minOccurs="0">
         <xs:element name="base-pitch" type="empty">
         <xs:annotation>
         <xs:documentation>The base pitch is the pitch at which the string is played before touching to create the harmonic.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="touching-pitch" type="empty">
         <xs:annotation>
         <xs:documentation>The touching-pitch is the pitch at which the string is touched lightly to produce the harmonic.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="sounding-pitch" type="empty">
         <xs:annotation>
         <xs:documentation>The sounding-pitch is the pitch which is heard when playing the harmonic.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:choice>
         </xs:sequence>
         <xs:attributeGroup ref="print-object"/>
         <xs:attributeGroup ref="print-style"/>
         <xs:attributeGroup ref="placement"/>
         </xs:complexType> */
        
        struct HarmonicAttributes;
        using HarmonicAttributesPtr = std::shared_ptr<HarmonicAttributes>;
        
        struct HarmonicAttributes : public AttributesInterface
        {
        public:
            HarmonicAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo printObject;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::AboveBelow placement;
            bool hasPrintObject;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasPlacement;
        };
        
        class Harmonic;
        using HarmonicPtr = std::shared_ptr<Harmonic>;
        using HarmonicUPtr = std::unique_ptr<Harmonic>;
        using HarmonicSet = std::vector<HarmonicPtr>;
        using HarmonicSetIter = HarmonicSet::iterator;
        using HarmonicSetIterConst = HarmonicSet::const_iterator;
        inline HarmonicPtr makeHarmonic() { return std::make_shared<Harmonic>(); }
        class Harmonic : public ElementInterface
        {
        public:
            Harmonic();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            HarmonicAttributesPtr getAttributes() const;
            void setAttributes( const HarmonicAttributesPtr& value );
            /* _________ HarmonicTypeChoice minOccurs = 0, maxOccurs = 1 _________ */
            HarmonicTypeChoicePtr getHarmonicTypeChoice() const;
            void setHarmonicTypeChoice( const HarmonicTypeChoicePtr& value );
            bool getHasHarmonicTypeChoice() const;
            void setHasHarmonicTypeChoice( const bool value );
            /* _________ HarmonicInfoChoice minOccurs = 0, maxOccurs = 1 _________ */
            HarmonicInfoChoicePtr getHarmonicInfoChoice() const;
            void setHarmonicInfoChoice( const HarmonicInfoChoicePtr& value );
            bool getHasHarmonicInfoChoice() const;
            void setHasHarmonicInfoChoice( const bool value );
        private:
            HarmonicAttributesPtr myAttributes;
            HarmonicTypeChoicePtr myHarmonicTypeChoice;
            bool myHasHarmonicTypeChoice;
            HarmonicInfoChoicePtr myHarmonicInfoChoice;
            bool myHasHarmonicInfoChoice;
        };
        
        /* <!--  ID = 6328 [6328] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 28 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="print" type="print"/>
         <xs:complexType name="print">
         <xs:annotation>
         <xs:documentation>The print type contains general printing parameters, including the layout elements defined in the layout.mod file. The part-name-display and part-abbreviation-display elements used in the score.mod file may also be used here to change how a part name or abbreviation is displayed over the course of a piece. They take effect when the current measure or a succeeding measure starts a new system.
         
         Layout elements in a print statement only apply to the current page, system, staff, or measure. Music that follows continues to take the default values from the layout included in the defaults element.</xs:documentation>
         </xs:annotation>
         
         <xs:sequence>
         <xs:group ref="layout"/>
         <xs:element name="measure-layout" type="measure-layout" minOccurs="0"/>
         <xs:element name="measure-numbering" type="measure-numbering" minOccurs="0"/>
         <xs:element name="part-name-display" type="name-display" minOccurs="0"/>
         <xs:element name="part-abbreviation-display" type="name-display" minOccurs="0"/>
         </xs:sequence>
         <xs:attributeGroup ref="print-attributes"/>
         </xs:complexType>
         
         <xs:group name="layout">
         <xs:annotation>
         <xs:documentation>The layout group specifies the sequence of page, system, and staff layout elements that is common to both the defaults and print elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="page-layout" type="page-layout" minOccurs="0"/>
         <xs:element name="system-layout" type="system-layout" minOccurs="0"/>
         <xs:element name="staff-layout" type="staff-layout" minOccurs="0" maxOccurs="unbounded"/>
         </xs:sequence>
         </xs:group> */
        
        struct PrintAttributes;
        using PrintAttributesPtr = std::shared_ptr<PrintAttributes>;
        
        struct PrintAttributes : public AttributesInterface
        {
        public:
            PrintAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue staffSpacing;
            t::YesNo newSystem;
            t::YesNo newPage;
            t::PositiveInteger blankPage;
            t::XsToken pageNumber;
            bool hasStaffSpacing;
            bool hasNewSystem;
            bool hasNewPage;
            bool hasBlankPage;
            bool hasPageNumber;
        };
        
        class Print;
        using PrintPtr = std::shared_ptr<Print>;
        using PrintUPtr = std::unique_ptr<Print>;
        using PrintSet = std::vector<PrintPtr>;
        using PrintSetIter = PrintSet::iterator;
        using PrintSetIterConst = PrintSet::const_iterator;
        inline PrintPtr makePrint() { return std::make_shared<Print>(); }
        class Print : public ElementInterface
        {
        public:
            Print();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PrintAttributesPtr getAttributes() const;
            void setAttributes( const PrintAttributesPtr& value );
            /* _________ LayoutGroup minOccurs = 1, maxOccurs = 1 _________ */
            LayoutGroupPtr getLayoutGroup() const;
            void setLayoutGroup( const LayoutGroupPtr& value );
            /* _________ MeasureLayout minOccurs = 0, maxOccurs = 1 _________ */
            MeasureLayoutPtr getMeasureLayout() const;
            void setMeasureLayout( const MeasureLayoutPtr& value );
            bool getHasMeasureLayout() const;
            void setHasMeasureLayout( const bool value );
            /* _________ MeasureNumbering minOccurs = 0, maxOccurs = 1 _________ */
            MeasureNumberingPtr getMeasureNumbering() const;
            void setMeasureNumbering( const MeasureNumberingPtr& value );
            bool getHasMeasureNumbering() const;
            void setHasMeasureNumbering( const bool value );
            /* _________ PartNameDisplay minOccurs = 0, maxOccurs = 1 _________ */
            PartNameDisplayPtr getPartNameDisplay() const;
            void setPartNameDisplay( const PartNameDisplayPtr& value );
            bool getHasPartNameDisplay() const;
            void setHasPartNameDisplay( const bool value );
            /* _________ PartAbbreviationDisplay minOccurs = 0, maxOccurs = 1 _________ */
            PartAbbreviationDisplayPtr getPartAbbreviationDisplay() const;
            void setPartAbbreviationDisplay( const PartAbbreviationDisplayPtr& value );
            bool getHasPartAbbreviationDisplay() const;
            void setHasPartAbbreviationDisplay( const bool value );
        private:
            PrintAttributesPtr myAttributes;
            LayoutGroupPtr myLayoutGroup;
            MeasureLayoutPtr myMeasureLayout;
            bool myHasMeasureLayout;
            MeasureNumberingPtr myMeasureNumbering;
            bool myHasMeasureNumbering;
            PartNameDisplayPtr myPartNameDisplay;
            bool myHasPartNameDisplay;
            PartAbbreviationDisplayPtr myPartAbbreviationDisplay;
            bool myHasPartAbbreviationDisplay;
        };
        /* <!--  ID = 6351 [6351] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 13 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="part-group" type="part-group"/>
         
         <xs:complexType name="part-group">
         <xs:annotation>
         <xs:documentation>The part-group element indicates groupings of parts in the score, usually indicated by braces and brackets. Braces that are used for multi-staff parts should be defined in the attributes element for that part. The part-group start element appears before the first score-part in the group. The part-group stop element appears after the last score-part in the group.
         
         The number attribute is used to distinguish overlapping and nested part-groups, not the sequence of groups. As with parts, groups can have a name and abbreviation. Values for the child elements are ignored at the stop of a group.
         
         A part-group element is not needed for a single multi-staff part. By default, multi-staff parts include a brace symbol and (if appropriate given the bar-style) common barlines. The symbol formatting for a multi-staff part can be more fully specified using the part-symbol element.</xs:documentation>
         </xs:annotation>
         
         <xs:sequence>
         
         <xs:element name="group-name" type="group-name" minOccurs="0"/>
         <xs:element name="group-name-display" type="name-display" minOccurs="0">
         <xs:annotation>
         <xs:documentation>Formatting specified in the group-name-display element overrides formatting specified in the group-name element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="group-abbreviation" type="group-name" minOccurs="0"/>
         <xs:element name="group-abbreviation-display" type="name-display" minOccurs="0">
         <xs:annotation>
         <xs:documentation>Formatting specified in the group-abbreviation-display element overrides formatting specified in the group-abbreviation element.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="group-symbol" type="group-symbol" minOccurs="0"/>
         <xs:element name="group-barline" type="group-barline" minOccurs="0"/>
         <xs:element name="group-time" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The group-time element indicates that the displayed time signatures should stretch across all parts and staves in the group.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:group ref="editorial"/>
         
         </xs:sequence>
         
         <xs:attribute name="type" type="start-stop" use="required"/>
         <xs:attribute name="number" type="xs:token" default="1"/>
         </xs:complexType>
         
         <xs:group name="editorial">
         <xs:annotation>
         <xs:documentation>The editorial group specifies editorial information for a musical element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         </xs:sequence>
         </xs:group> */
        
        struct PartGroupAttributes;
        using PartGroupAttributesPtr = std::shared_ptr<PartGroupAttributes>;
        
        struct PartGroupAttributes : public AttributesInterface
        {
        public:
            PartGroupAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::StartStop type;
            t::XsToken number;
            const 	bool hasType;
            bool hasNumber;
        };
        
        class PartGroup;
        using PartGroupPtr = std::shared_ptr<PartGroup>;
        using PartGroupUPtr = std::unique_ptr<PartGroup>;
        using PartGroupSet = std::vector<PartGroupPtr>;
        using PartGroupSetIter = PartGroupSet::iterator;
        using PartGroupSetIterConst = PartGroupSet::const_iterator;
        inline PartGroupPtr makePartGroup() { return std::make_shared<PartGroup>(); }
        class PartGroup : public ElementInterface
        {
        public:
            PartGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PartGroupAttributesPtr getAttributes() const;
            void setAttributes( const PartGroupAttributesPtr& value );
            /* _________ GroupName minOccurs = 0, maxOccurs = 1 _________ */
            GroupNamePtr getGroupName() const;
            void setGroupName( const GroupNamePtr& value );
            bool getHasGroupName() const;
            void setHasGroupName( const bool value );
            /* _________ GroupNameDisplay minOccurs = 0, maxOccurs = 1 _________ */
            GroupNameDisplayPtr getGroupNameDisplay() const;
            void setGroupNameDisplay( const GroupNameDisplayPtr& value );
            bool getHasGroupNameDisplay() const;
            void setHasGroupNameDisplay( const bool value );
            /* _________ GroupAbbreviation minOccurs = 0, maxOccurs = 1 _________ */
            GroupAbbreviationPtr getGroupAbbreviation() const;
            void setGroupAbbreviation( const GroupAbbreviationPtr& value );
            bool getHasGroupAbbreviation() const;
            void setHasGroupAbbreviation( const bool value );
            /* _________ GroupAbbreviationDisplay minOccurs = 0, maxOccurs = 1 _________ */
            GroupAbbreviationDisplayPtr getGroupAbbreviationDisplay() const;
            void setGroupAbbreviationDisplay( const GroupAbbreviationDisplayPtr& value );
            bool getHasGroupAbbreviationDisplay() const;
            void setHasGroupAbbreviationDisplay( const bool value );
            /* _________ GroupSymbol minOccurs = 0, maxOccurs = 1 _________ */
            GroupSymbolPtr getGroupSymbol() const;
            void setGroupSymbol( const GroupSymbolPtr& value );
            bool getHasGroupSymbol() const;
            void setHasGroupSymbol( const bool value );
            /* _________ GroupBarline minOccurs = 0, maxOccurs = 1 _________ */
            GroupBarlinePtr getGroupBarline() const;
            void setGroupBarline( const GroupBarlinePtr& value );
            bool getHasGroupBarline() const;
            void setHasGroupBarline( const bool value );
            /* _________ GroupTime minOccurs = 0, maxOccurs = 1 _________ */
            GroupTimePtr getGroupTime() const;
            void setGroupTime( const GroupTimePtr& value );
            bool getHasGroupTime() const;
            void setHasGroupTime( const bool value );
            /* _________ EditorialGroup minOccurs = 1, maxOccurs = 1 _________ */
            EditorialGroupPtr getEditorialGroup() const;
            void setEditorialGroup( const EditorialGroupPtr& value );
        private:
            PartGroupAttributesPtr myAttributes;
            GroupNamePtr myGroupName;
            bool myHasGroupName;
            GroupNameDisplayPtr myGroupNameDisplay;
            bool myHasGroupNameDisplay;
            GroupAbbreviationPtr myGroupAbbreviation;
            bool myHasGroupAbbreviation;
            GroupAbbreviationDisplayPtr myGroupAbbreviationDisplay;
            bool myHasGroupAbbreviationDisplay;
            GroupSymbolPtr myGroupSymbol;
            bool myHasGroupSymbol;
            GroupBarlinePtr myGroupBarline;
            bool myHasGroupBarline;
            GroupTimePtr myGroupTime;
            bool myHasGroupTime;
            EditorialGroupPtr myEditorialGroup;
        };
        /* <!--  ID = 4932 [4932] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 39 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="technical" type="technical"/>
         <xs:complexType name="technical">
         <xs:annotation>
         <xs:documentation>Technical indications give performance information for individual instruments.</xs:documentation>
         </xs:annotation>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="up-bow" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The up-bow element represents the symbol that is used both for up-bowing on bowed instruments, and up-stroke on plucked instruments.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="down-bow" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The down-bow element represents the symbol that is used both for down-bowing on bowed instruments, and down-stroke on plucked instruments.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="harmonic" type="harmonic"/>
         <xs:element name="open-string" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The open-string element represents the zero-shaped open string symbol.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="thumb-position" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The thumb-position element represents the thumb position symbol. This is a circle with a line, where the line does not come within the circle. It is distinct from the snap pizzicato symbol, where the line comes inside the circle.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="fingering" type="fingering"/>
         <xs:element name="pluck" type="placement-text">
         <xs:annotation>
         <xs:documentation>The pluck element is used to specify the plucking fingering on a fretted instrument, where the fingering element refers to the fretting fingering. Typical values are p, i, m, a for pulgar/thumb, indicio/index, medio/middle, and anular/ring fingers.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="double-tongue" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The double-tongue element represents the double tongue symbol (two dots arranged horizontally).</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="triple-tongue" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The triple-tongue element represents the triple tongue symbol (three dots arranged horizontally).</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="stopped" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The stopped element represents the stopped symbol, which looks like a plus sign.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="snap-pizzicato" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The snap-pizzicato element represents the snap pizzicato symbol. This is a circle with a line, where the line comes inside the circle. It is distinct from the thumb-position symbol, where the line does not come inside the circle.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="fret" type="fret"/>
         <xs:element name="string" type="string"/>
         <xs:element name="hammer-on" type="hammer-on-pull-off"/>
         <xs:element name="pull-off" type="hammer-on-pull-off"/>
         <xs:element name="bend" type="bend"/>
         <xs:element name="tap" type="placement-text">
         <xs:annotation>
         <xs:documentation>The tap element indicates a tap on the fretboard. The element content allows specification of the notation; + and T are common choices. If empty, the display is application-specific.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="heel" type="heel-toe"/>
         <xs:element name="toe" type="heel-toe"/>
         <xs:element name="fingernails" type="empty-placement">
         <xs:annotation>
         <xs:documentation>The fingernails element is used in notation for harp and other plucked string instruments.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="hole" type="hole"/>
         <xs:element name="arrow" type="arrow"/>
         <xs:element name="handbell" type="handbell"/>
         <xs:element name="other-technical" type="placement-text">
         <xs:annotation>
         <xs:documentation>The other-technical element is used to define any technical indications not yet in the MusicXML format. This allows extended representation, though without application interoperability.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:choice>
         </xs:complexType> */
        
        class TechnicalChoice;
        using TechnicalChoicePtr = std::shared_ptr<TechnicalChoice>;
        using TechnicalChoiceUPtr = std::unique_ptr<TechnicalChoice>;
        using TechnicalChoiceSet = std::vector<TechnicalChoicePtr>;
        using TechnicalChoiceSetIter = TechnicalChoiceSet::iterator;
        using TechnicalChoiceSetIterConst = TechnicalChoiceSet::const_iterator;
        inline TechnicalChoicePtr makeTechnicalChoice() { return std::make_shared<TechnicalChoice>(); }
        class TechnicalChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                upBow = 1,
                downBow = 2,
                harmonic = 3,
                openString = 4,
                thumbPosition = 5,
                fingering = 6,
                pluck = 7,
                doubleTongue = 8,
                tripleTounge = 9,
                stopped = 10,
                snapPizzicato = 11,
                fret = 12,
                string_ = 13,
                hammerOn = 14,
                pullOff = 15,
                bend = 16,
                tap = 17,
                heel = 18,
                toe = 19,
                fingernails = 20,
                hole = 21,
                arrow = 22,
                handbell = 23,
                otherTechnical = 24
            };
            TechnicalChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice minOccurs = 1, maxOccurs = 1 _________ */
            TechnicalChoice::Choice getChoice() const;
            void setChoice( const TechnicalChoice::Choice value );
            /* _________ UpBow minOccurs = 1, maxOccurs = 1 _________ */
            UpBowPtr getUpBow() const;
            void setUpBow( const UpBowPtr& value );
            /* _________ DownBow minOccurs = 1, maxOccurs = 1 _________ */
            DownBowPtr getDownBow() const;
            void setDownBow( const DownBowPtr& value );
            /* _________ Harmonic minOccurs = 1, maxOccurs = 1 _________ */
            HarmonicPtr getHarmonic() const;
            void setHarmonic( const HarmonicPtr& value );
            /* _________ OpenString minOccurs = 1, maxOccurs = 1 _________ */
            OpenStringPtr getOpenString() const;
            void setOpenString( const OpenStringPtr& value );
            /* _________ ThumbPosition minOccurs = 1, maxOccurs = 1 _________ */
            ThumbPositionPtr getThumbPosition() const;
            void setThumbPosition( const ThumbPositionPtr& value );
            /* _________ Fingering minOccurs = 1, maxOccurs = 1 _________ */
            FingeringPtr getFingering() const;
            void setFingering( const FingeringPtr& value );
            /* _________ Pluck minOccurs = 1, maxOccurs = 1 _________ */
            PluckPtr getPluck() const;
            void setPluck( const PluckPtr& value );
            /* _________ DoubleTongue minOccurs = 1, maxOccurs = 1 _________ */
            DoubleTonguePtr getDoubleTongue() const;
            void setDoubleTongue( const DoubleTonguePtr& value );
            /* _________ TripleTongue minOccurs = 1, maxOccurs = 1 _________ */
            TripleTonguePtr getTripleTongue() const;
            void setTripleTongue( const TripleTonguePtr& value );
            /* _________ Stopped minOccurs = 1, maxOccurs = 1 _________ */
            StoppedPtr getStopped() const;
            void setStopped( const StoppedPtr& value );
            /* _________ SnapPizzicato minOccurs = 1, maxOccurs = 1 _________ */
            SnapPizzicatoPtr getSnapPizzicato() const;
            void setSnapPizzicato( const SnapPizzicatoPtr& value );
            /* _________ Fret minOccurs = 1, maxOccurs = 1 _________ */
            FretPtr getFret() const;
            void setFret( const FretPtr& value );
            /* _________ String minOccurs = 1, maxOccurs = 1 _________ */
            StringPtr getString() const;
            void setString( const StringPtr& value );
            /* _________ HammerOn minOccurs = 1, maxOccurs = 1 _________ */
            HammerOnPtr getHammerOn() const;
            void setHammerOn( const HammerOnPtr& value );
            /* _________ PullOff minOccurs = 1, maxOccurs = 1 _________ */
            PullOffPtr getPullOff() const;
            void setPullOff( const PullOffPtr& value );
            /* _________ Bend minOccurs = 1, maxOccurs = 1 _________ */
            BendPtr getBend() const;
            void setBend( const BendPtr& value );
            /* _________ Tap minOccurs = 1, maxOccurs = 1 _________ */
            TapPtr getTap() const;
            void setTap( const TapPtr& value );
            /* _________ Heel minOccurs = 1, maxOccurs = 1 _________ */
            HeelPtr getHeel() const;
            void setHeel( const HeelPtr& value );
            /* _________ Toe minOccurs = 1, maxOccurs = 1 _________ */
            ToePtr getToe() const;
            void setToe( const ToePtr& value );
            /* _________ Fingernails minOccurs = 1, maxOccurs = 1 _________ */
            FingernailsPtr getFingernails() const;
            void setFingernails( const FingernailsPtr& value );
            /* _________ Hole minOccurs = 1, maxOccurs = 1 _________ */
            HolePtr getHole() const;
            void setHole( const HolePtr& value );
            /* _________ Arrow minOccurs = 1, maxOccurs = 1 _________ */
            ArrowPtr getArrow() const;
            void setArrow( const ArrowPtr& value );
            /* _________ Handbell minOccurs = 1, maxOccurs = 1 _________ */
            HandbellPtr getHandbell() const;
            void setHandbell( const HandbellPtr& value );
            /* _________ OtherTechnical minOccurs = 1, maxOccurs = 1 _________ */
            OtherTechnicalPtr getOtherTechnical() const;
            void setOtherTechnical( const OtherTechnicalPtr& value );
        private:
            Choice myChoice;
            UpBowPtr myUpBow;
            DownBowPtr myDownBow;
            HarmonicPtr myHarmonic;
            OpenStringPtr myOpenString;
            ThumbPositionPtr myThumbPosition;
            FingeringPtr myFingering;
            PluckPtr myPluck;
            DoubleTonguePtr myDoubleTongue;
            TripleTonguePtr myTripleTongue;
            StoppedPtr myStopped;
            SnapPizzicatoPtr mySnapPizzicato;
            FretPtr myFret;
            StringPtr myString;
            HammerOnPtr myHammerOn;
            PullOffPtr myPullOff;
            BendPtr myBend;
            TapPtr myTap;
            HeelPtr myHeel;
            ToePtr myToe;
            FingernailsPtr myFingernails;
            HolePtr myHole;
            ArrowPtr myArrow;
            HandbellPtr myHandbell;
            OtherTechnicalPtr myOtherTechnical;
        };
        
        class Technical;
        using TechnicalPtr = std::shared_ptr<Technical>;
        using TechnicalUPtr = std::unique_ptr<Technical>;
        using TechnicalSet = std::vector<TechnicalPtr>;
        using TechnicalSetIter = TechnicalSet::iterator;
        using TechnicalSetIterConst = TechnicalSet::const_iterator;
        inline TechnicalPtr makeTechnical() { return std::make_shared<Technical>(); }
        class Technical : public ElementInterface
        {
        public:
            Technical();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ TechnicalChoice minOccurs = 0, maxOccurs = unbounded _________ */
            const TechnicalChoiceSet& getTechnicalChoiceSet() const;
            void addTechnicalChoice( const TechnicalChoicePtr& value );
            void removeTechnicalChoice( const TechnicalChoiceSetIterConst& value );
            void clearTechnicalChoiceSet();
            TechnicalChoicePtr getTechnicalChoice( const TechnicalChoiceSetIterConst& setIterator ) const;
        private:
            TechnicalChoiceSet myTechnicalChoiceSet;
        };
        
        
        
        /* <xs:group name="editorial-voice-direction">
         <xs:annotation>
         <xs:documentation>The editorial-voice-direction group supports the common combination of editorial and voice information for a direction element. It is separate from the editorial-voice element because extensions and restrictions might be different for directions than for the note and forward elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         <xs:group ref="voice" minOccurs="0"/>
         </xs:sequence>
         </xs:group> */
        
        using EditorialVoiceDirectionGroup = EditorialVoiceGroup;
        using EditorialVoiceDirectionGroupPtr = std::shared_ptr<EditorialVoiceDirectionGroup>;
        using EditorialVoiceDirectionGroupUPtr = std::unique_ptr<EditorialVoiceDirectionGroup>;
        using EditorialVoiceDirectionGroupSet = std::vector<EditorialVoiceDirectionGroupPtr>;
        using EditorialVoiceDirectionGroupSetIter = EditorialVoiceDirectionGroupSet::iterator;
        using EditorialVoiceDirectionGroupSetIterConst = EditorialVoiceDirectionGroupSet::const_iterator;
        inline EditorialVoiceDirectionGroupPtr makeEditorialVoiceDirectionGroup() { return std::make_shared<EditorialVoiceDirectionGroup>(); }
        
        /* !--  ID = 6316 [6316] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 116 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="direction" type="direction"/>
         <xs:complexType name="direction">
         <xs:annotation>
         <xs:documentation>A direction is a musical indication that is not attached to a specific note. Two or more may be combined to indicate starts and stops of wedges, dashes, etc.
         
         By default, a series of direction-type elements and a series of child elements of a direction-type within a single direction element follow one another in sequence visually. For a series of direction-type children, non-positional formatting attributes are carried over from the previous element by default.</xs:documentation>
         </xs:annotation>
         
         <xs:sequence>
         <xs:element name="direction-type" type="direction-type" maxOccurs="unbounded"/>
         <xs:element name="offset" type="offset" minOccurs="0"/>
         <xs:group ref="editorial-voice-direction"/>
         <xs:group ref="staff" minOccurs="0"/>
         <xs:element name="sound" type="sound" minOccurs="0"/>
         </xs:sequence>
         
         <xs:attributeGroup ref="placement"/>
         <xs:attributeGroup ref="directive"/>
         
         </xs:complexType>
         
         <xs:group name="editorial-voice-direction">
         <xs:annotation>
         <xs:documentation>The editorial-voice-direction group supports the common combination of editorial and voice information for a direction element. It is separate from the editorial-voice element because extensions and restrictions might be different for directions than for the note and forward elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         <xs:group ref="voice" minOccurs="0"/>
         </xs:sequence>
         </xs:group>
         
         <xs:group name="staff">
         <xs:annotation>
         <xs:documentation>The staff element is defined within a group due to its use by both notes and direction elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="staff" type="xs:positiveInteger">
         <xs:annotation>
         <xs:documentation>Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group> */
        
        struct DirectionAttributes;
        using DirectionAttributesPtr = std::shared_ptr<DirectionAttributes>;
        
        struct DirectionAttributes : public AttributesInterface
        {
        public:
            DirectionAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::AboveBelow placement;
            t::YesNo directive;
            bool hasPlacement;
            bool hasDirective;
        };
        
        class Direction;
        using DirectionPtr = std::shared_ptr<Direction>;
        using DirectionUPtr = std::unique_ptr<Direction>;
        using DirectionSet = std::vector<DirectionPtr>;
        using DirectionSetIter = DirectionSet::iterator;
        using DirectionSetIterConst = DirectionSet::const_iterator;
        inline DirectionPtr makeDirection() { return std::make_shared<Direction>(); }
        class Direction : public ElementInterface
        {
        public:
            Direction();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            DirectionAttributesPtr getAttributes() const;
            void setAttributes( const DirectionAttributesPtr& value );
            /* _________ DirectionType minOccurs = 0, maxOccurs = unbounded _________ */
            const DirectionTypeSet& getDirectionTypeSet() const;
            void addDirectionType( const DirectionTypePtr& value );
            void removeDirectionType( const DirectionTypeSetIterConst& value );
            void clearDirectionTypeSet();
            DirectionTypePtr getDirectionType( const DirectionTypeSetIterConst& setIterator ) const;
            /* _________ Offset minOccurs = 0, maxOccurs = 1 _________ */
            OffsetPtr getOffset() const;
            void setOffset( const OffsetPtr& value );
            bool getHasOffset() const;
            void setHasOffset( const bool value );
            /* _________ EditorialVoiceDirectionGroup minOccurs = 1, maxOccurs = 1 _________ */
            EditorialVoiceDirectionGroupPtr getEditorialVoiceDirectionGroup() const;
            void setEditorialVoiceDirectionGroup( const EditorialVoiceDirectionGroupPtr& value );
            /* _________ Staff minOccurs = 0, maxOccurs = 1 _________ */
            StaffPtr getStaff() const;
            void setStaff( const StaffPtr& value );
            bool getHasStaff() const;
            void setHasStaff( const bool value );
            /* _________ Sound minOccurs = 0, maxOccurs = 1 _________ */
            SoundPtr getSound() const;
            void setSound( const SoundPtr& value );
            bool getHasSound() const;
            void setHasSound( const bool value );
        private:
            DirectionAttributesPtr myAttributes;
            DirectionTypeSet myDirectionTypeSet;
            OffsetPtr myOffset;
            bool myHasOffset;
            EditorialVoiceDirectionGroupPtr myEditorialVoiceDirectionGroup;
            StaffPtr myStaff;
            bool myHasStaff;
            SoundPtr mySound;
            bool myHasSound;
        };
        
        /* <!--  ID = 6319 [6319] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 50 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="attributes" type="attributes"/>
         
         <xs:complexType name="attributes">
         <xs:annotation>
         <xs:documentation>The attributes element contains musical information that typically changes on measure boundaries. This includes key and time signatures, clefs, transpositions, and staving. When attributes are changed mid-measure, it affects the music in score order, not in MusicXML document order.</xs:documentation>
         </xs:annotation>
         
         <xs:sequence>
         
         <xs:group ref="editorial"/>
         <xs:element name="divisions" type="positive-divisions" minOccurs="0">
         <xs:annotation>
         <xs:documentation>Musical notation duration is commonly represented as fractions. The divisions element indicates how many divisions per quarter note are used to indicate a note's duration. For example, if duration = 1 and divisions = 2, this is an eighth note duration. Duration and divisions are used directly for generating sound output, so they must be chosen to take tuplets into account. Using a divisions element lets us use just one number to represent a duration for each note in the score, while retaining the full power of a fractional representation. If maximum compatibility with Standard MIDI 1.0 files is important, do not have the divisions value exceed 16383.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="key" type="key" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The key element represents a key signature. Both traditional and non-traditional key signatures are supported. The optional number attribute refers to staff numbers. If absent, the key signature applies to all staves in the part.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="time" type="time" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="staves" type="xs:nonNegativeInteger" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The staves element is used if there is more than one staff represented in the given part (e.g., 2 staves for typical piano parts). If absent, a value of 1 is assumed. Staves are ordered from top to bottom in a part in numerical order, with staff 1 above staff 2.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="part-symbol" type="part-symbol" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The part-symbol element indicates how a symbol for a multi-staff part is indicated in the score.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="instruments" type="xs:nonNegativeInteger" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The instruments element is only used if more than one instrument is represented in the part (e.g., oboe I and II where they play together most of the time). If absent, a value of 1 is assumed.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="clef" type="clef" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>Clefs are represented by a combination of sign, line, and clef-octave-change elements.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="staff-details" type="staff-details" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The staff-details element is used to indicate different types of staves.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="transpose" type="transpose" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>If the part is being encoded for a transposing instrument in written vs. concert pitch, the transposition must be encoded in the transpose element using the transpose type.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="directive" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>Directives are like directions, but can be grouped together with attributes for convenience. This is typically used for tempo markings at the beginning of a piece of music. This element has been deprecated in Version 2.0 in favor of the directive attribute for direction elements. Language names come from ISO 639, with optional country subcodes from ISO 3166.</xs:documentation>
         </xs:annotation>
         <xs:complexType>
         <xs:simpleContent>
         <xs:extension base="xs:string">
         <xs:attributeGroup ref="print-style"/>
         <xs:attribute ref="xml:lang"/>
         </xs:extension>
         </xs:simpleContent>
         </xs:complexType>
         </xs:element>
         <xs:element name="measure-style" type="measure-style" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>A measure-style indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.</xs:documentation>
         </xs:annotation>
         </xs:element>
         
         </xs:sequence>
         
         </xs:complexType>
         
         <xs:group name="editorial">
         <xs:annotation>
         <xs:documentation>The editorial group specifies editorial information for a musical element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         </xs:sequence>
         </xs:group> */
        
        /* I am renaming this to "properties" because it clashes with a lot of things.
         In particular it clashes with the Attributes which are contained by every
         element.  I discovered this clash late in the game so this is likely to be
         the only Element where the element's name does not match the Class name. */
        
        class Properties;
        using PropertiesPtr = std::shared_ptr<Properties>;
        using PropertiesUPtr = std::unique_ptr<Properties>;
        using PropertiesSet = std::vector<PropertiesPtr>;
        using PropertiesSetIter = PropertiesSet::iterator;
        using PropertiesSetIterConst = PropertiesSet::const_iterator;
        inline PropertiesPtr makeProperties() { return std::make_shared<Properties>(); }
        class Properties : public ElementInterface
        {
        public:
            Properties();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ EditorialGroup minOccurs = 1, maxOccurs = 1 _________ */
            EditorialGroupPtr getEditorialGroup() const;
            void setEditorialGroup( const EditorialGroupPtr& value );
            /* _________ Divisions minOccurs = 0, maxOccurs = 1 _________ */
            DivisionsPtr getDivisions() const;
            void setDivisions( const DivisionsPtr& value );
            bool getHasDivisions() const;
            void setHasDivisions( const bool value );
            /* _________ Key minOccurs = 0, maxOccurs = unbounded _________ */
            const KeySet& getKeySet() const;
            void addKey( const KeyPtr& value );
            void removeKey( const KeySetIterConst& value );
            void clearKeySet();
            KeyPtr getKey( const KeySetIterConst& setIterator ) const;
            /* _________ Time minOccurs = 0, maxOccurs = unbounded _________ */
            const TimeSet& getTimeSet() const;
            void addTime( const TimePtr& value );
            void removeTime( const TimeSetIterConst& value );
            void clearTimeSet();
            TimePtr getTime( const TimeSetIterConst& setIterator ) const;
            /* _________ Staves minOccurs = 0, maxOccurs = 1 _________ */
            StavesPtr getStaves() const;
            void setStaves( const StavesPtr& value );
            bool getHasStaves() const;
            void setHasStaves( const bool value );
            /* _________ PartSymbol minOccurs = 0, maxOccurs = 1 _________ */
            PartSymbolPtr getPartSymbol() const;
            void setPartSymbol( const PartSymbolPtr& value );
            bool getHasPartSymbol() const;
            void setHasPartSymbol( const bool value );
            /* _________ Instruments minOccurs = 0, maxOccurs = 1 _________ */
            InstrumentsPtr getInstruments() const;
            void setInstruments( const InstrumentsPtr& value );
            bool getHasInstruments() const;
            void setHasInstruments( const bool value );
            /* _________ Clef minOccurs = 0, maxOccurs = unbounded _________ */
            const ClefSet& getClefSet() const;
            void addClef( const ClefPtr& value );
            void removeClef( const ClefSetIterConst& value );
            void clearClefSet();
            ClefPtr getClef( const ClefSetIterConst& setIterator ) const;
            /* _________ StaffDetails minOccurs = 0, maxOccurs = unbounded _________ */
            const StaffDetailsSet& getStaffDetailsSet() const;
            void addStaffDetails( const StaffDetailsPtr& value );
            void removeStaffDetails( const StaffDetailsSetIterConst& value );
            void clearStaffDetailsSet();
            StaffDetailsPtr getStaffDetails( const StaffDetailsSetIterConst& setIterator ) const;
            /* _________ Transpose minOccurs = 0, maxOccurs = unbounded _________ */
            const TransposeSet& getTransposeSet() const;
            void addTranspose( const TransposePtr& value );
            void removeTranspose( const TransposeSetIterConst& value );
            void clearTransposeSet();
            TransposePtr getTranspose( const TransposeSetIterConst& setIterator ) const;
            /* _________ Directive minOccurs = 0, maxOccurs = unbounded _________ */
            const DirectiveSet& getDirectiveSet() const;
            void addDirective( const DirectivePtr& value );
            void removeDirective( const DirectiveSetIterConst& value );
            void clearDirectiveSet();
            DirectivePtr getDirective( const DirectiveSetIterConst& setIterator ) const;
            /* _________ MeasureStyle minOccurs = 0, maxOccurs = unbounded _________ */
            const MeasureStyleSet& getMeasureStyleSet() const;
            void addMeasureStyle( const MeasureStylePtr& value );
            void removeMeasureStyle( const MeasureStyleSetIterConst& value );
            void clearMeasureStyleSet();
            MeasureStylePtr getMeasureStyle( const MeasureStyleSetIterConst& setIterator ) const;
        private:
            EditorialGroupPtr myEditorialGroup;
            DivisionsPtr myDivisions;
            bool myHasDivisions;
            KeySet myKeySet;
            TimeSet myTimeSet;
            StavesPtr myStaves;
            bool myHasStaves;
            PartSymbolPtr myPartSymbol;
            bool myHasPartSymbol;
            InstrumentsPtr myInstruments;
            bool myHasInstruments;
            ClefSet myClefSet;
            StaffDetailsSet myStaffDetailsSet;
            TransposeSet myTransposeSet;
            DirectiveSet myDirectiveSet;
            MeasureStyleSet myMeasureStyleSet;
        };
        
        /* <!--  ID = 6396 [6396] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 41 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="score-part" type="score-part">
         <xs:annotation>
         <xs:documentation>Each MusicXML part corresponds to a track in a Standard MIDI Format 1 file. The score-instrument elements are used when there are multiple instruments per track. The midi-device element is used to make a MIDI device or port assignment for the given track. Initial midi-instrument assignments may be made here as well.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:complexType name="score-part">
         <xs:annotation>
         <xs:documentation>Each MusicXML part corresponds to a track in a Standard MIDI Format 1 file. The score-instrument elements are used when there are multiple instruments per track. The midi-device element is used to make a MIDI device or port assignment for the given track or specific MIDI instruments. Initial midi-instrument assignments may be made here as well.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="identification" type="identification" minOccurs="0"/>
         <xs:element name="part-name" type="part-name"/>
         <xs:element name="part-name-display" type="name-display" minOccurs="0"/>
         <xs:element name="part-abbreviation" type="part-name" minOccurs="0"/>
         <xs:element name="part-abbreviation-display" type="name-display" minOccurs="0"/>
         <xs:element name="group" type="xs:string" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>The group element allows the use of different versions of the part for different purposes. Typical values include score, parts, sound, and data. Ordering information that is directly encoded in MuseData can be derived from the ordering within a MusicXML score or opus.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="score-instrument" type="score-instrument" minOccurs="0" maxOccurs="unbounded"/>
         <xs:sequence minOccurs="0" maxOccurs="unbounded">
         <xs:element name="midi-device" type="midi-device" minOccurs="0"/>
         <xs:element name="midi-instrument" type="midi-instrument" minOccurs="0"/>
         </xs:sequence>
         </xs:sequence>
         <xs:attribute name="id" type="xs:ID" use="required"/>
         </xs:complexType> */
        
        
        
        struct ScorePartAttributes;
        using ScorePartAttributesPtr = std::shared_ptr<ScorePartAttributes>;
        
        struct ScorePartAttributes : public AttributesInterface
        {
        public:
            ScorePartAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsID id;
            const 	bool hasId;
        };
        
        class MidiDeviceInstrumentGroup;
        using MidiDeviceInstrumentGroupPtr = std::shared_ptr<MidiDeviceInstrumentGroup>;
        using MidiDeviceInstrumentGroupUPtr = std::unique_ptr<MidiDeviceInstrumentGroup>;
        using MidiDeviceInstrumentGroupSet = std::vector<MidiDeviceInstrumentGroupPtr>;
        using MidiDeviceInstrumentGroupSetIter = MidiDeviceInstrumentGroupSet::iterator;
        using MidiDeviceInstrumentGroupSetIterConst = MidiDeviceInstrumentGroupSet::const_iterator;
        inline MidiDeviceInstrumentGroupPtr makeMidiDeviceInstrumentGroup() { return std::make_shared<MidiDeviceInstrumentGroup>(); }
        class MidiDeviceInstrumentGroup : public ElementInterface
        {
        public:
            MidiDeviceInstrumentGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ MidiDevice minOccurs = 0, maxOccurs = 1 _________ */
            MidiDevicePtr getMidiDevice() const;
            void setMidiDevice( const MidiDevicePtr& value );
            bool getHasMidiDevice() const;
            void setHasMidiDevice( const bool value );
            /* _________ MidiInstrument minOccurs = 0, maxOccurs = 1 _________ */
            MidiInstrumentPtr getMidiInstrument() const;
            void setMidiInstrument( const MidiInstrumentPtr& value );
            bool getHasMidiInstrument() const;
            void setHasMidiInstrument( const bool value );
        private:
            MidiDevicePtr myMidiDevice;
            bool myHasMidiDevice;
            MidiInstrumentPtr myMidiInstrument;
            bool myHasMidiInstrument;
        };
        
        class ScorePart;
        using ScorePartPtr = std::shared_ptr<ScorePart>;
        using ScorePartUPtr = std::unique_ptr<ScorePart>;
        using ScorePartSet = std::vector<ScorePartPtr>;
        using ScorePartSetIter = ScorePartSet::iterator;
        using ScorePartSetIterConst = ScorePartSet::const_iterator;
        inline ScorePartPtr makeScorePart() { return std::make_shared<ScorePart>(); }
        class ScorePart : public ElementInterface
        {
        public:
            ScorePart();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            ScorePartAttributesPtr getAttributes() const;
            void setAttributes( const ScorePartAttributesPtr& value );
            /* _________ Identification minOccurs = 0, maxOccurs = 1 _________ */
            IdentificationPtr getIdentification() const;
            void setIdentification( const IdentificationPtr& value );
            bool getHasIdentification() const;
            void setHasIdentification( const bool value );
            /* _________ PartName minOccurs = 1, maxOccurs = 1 _________ */
            PartNamePtr getPartName() const;
            void setPartName( const PartNamePtr& value );
            /* _________ PartNameDisplay minOccurs = 0, maxOccurs = 1 _________ */
            PartNameDisplayPtr getPartNameDisplay() const;
            void setPartNameDisplay( const PartNameDisplayPtr& value );
            bool getHasPartNameDisplay() const;
            void setHasPartNameDisplay( const bool value );
            /* _________ PartAbbreviation minOccurs = 0, maxOccurs = 1 _________ */
            PartAbbreviationPtr getPartAbbreviation() const;
            void setPartAbbreviation( const PartAbbreviationPtr& value );
            bool getHasPartAbbreviation() const;
            void setHasPartAbbreviation( const bool value );
            /* _________ PartAbbreviationDisplay minOccurs = 0, maxOccurs = 1 _________ */
            PartAbbreviationDisplayPtr getPartAbbreviationDisplay() const;
            void setPartAbbreviationDisplay( const PartAbbreviationDisplayPtr& value );
            bool getHasPartAbbreviationDisplay() const;
            void setHasPartAbbreviationDisplay( const bool value );
            /* _________ Group minOccurs = 0, maxOccurs = unbounded _________ */
            const GroupSet& getGroupSet() const;
            void addGroup( const GroupPtr& value );
            void removeGroup( const GroupSetIterConst& value );
            void clearGroupSet();
            GroupPtr getGroup( const GroupSetIterConst& setIterator ) const;
            /* _________ ScoreInstrument minOccurs = 0, maxOccurs = unbounded _________ */
            const ScoreInstrumentSet& getScoreInstrumentSet() const;
            void addScoreInstrument( const ScoreInstrumentPtr& value );
            void removeScoreInstrument( const ScoreInstrumentSetIterConst& value );
            void clearScoreInstrumentSet();
            ScoreInstrumentPtr getScoreInstrument( const ScoreInstrumentSetIterConst& setIterator ) const;
            /* _________ MidiDeviceInstrumentGroup minOccurs = 0, maxOccurs = unbounded _________ */
            const MidiDeviceInstrumentGroupSet& getMidiDeviceInstrumentGroupSet() const;
            void addMidiDeviceInstrumentGroup( const MidiDeviceInstrumentGroupPtr& value );
            void removeMidiDeviceInstrumentGroup( const MidiDeviceInstrumentGroupSetIterConst& value );
            void clearMidiDeviceInstrumentGroupSet();
            MidiDeviceInstrumentGroupPtr getMidiDeviceInstrumentGroup( const MidiDeviceInstrumentGroupSetIterConst& setIterator ) const;
        private:
            ScorePartAttributesPtr myAttributes;
            IdentificationPtr myIdentification;
            bool myHasIdentification;
            PartNamePtr myPartName;
            PartNameDisplayPtr myPartNameDisplay;
            bool myHasPartNameDisplay;
            PartAbbreviationPtr myPartAbbreviation;
            bool myHasPartAbbreviation;
            PartAbbreviationDisplayPtr myPartAbbreviationDisplay;
            bool myHasPartAbbreviationDisplay;
            GroupSet myGroupSet;
            ScoreInstrumentSet myScoreInstrumentSet;
            MidiDeviceInstrumentGroupSet myMidiDeviceInstrumentGroupSet;
        };
        
        /* <!--  ID = 5040 [5040] ------------------------->
         <!-- min=0 max=4294967295 ZeroOrMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 117 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="notations" type="notations" minOccurs="0" maxOccurs="unbounded"/>
         <xs:complexType name="notations">
         <xs:annotation>
         <xs:documentation>Notations refer to musical notations, not XML notations. Multiple notations are allowed in order to represent multiple editorial levels. The print-object attribute, added in Version 3.0, allows notations to represent details of performance technique, such as fingerings, without having them appear in the score.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="editorial"/>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="tied" type="tied"/>
         <xs:element name="slur" type="slur"/>
         <xs:element name="tuplet" type="tuplet"/>
         <xs:element name="glissando" type="glissando"/>
         <xs:element name="slide" type="slide"/>
         <xs:element name="ornaments" type="ornaments"/>
         <xs:element name="technical" type="technical"/>
         <xs:element name="articulations" type="articulations"/>
         <xs:element name="dynamics" type="dynamics"/>
         <xs:element name="fermata" type="fermata"/>
         <xs:element name="arpeggiate" type="arpeggiate"/>
         <xs:element name="non-arpeggiate" type="non-arpeggiate"/>
         <xs:element name="accidental-mark" type="accidental-mark"/>
         <xs:element name="other-notation" type="other-notation"/>
         </xs:choice>
         </xs:sequence>
         <xs:attributeGroup ref="print-object"/>
         </xs:complexType>
         <xs:group name="editorial">
         <xs:annotation>
         <xs:documentation>The editorial group specifies editorial information for a musical element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         </xs:sequence>
         </xs:group> */
        
        class NotationsChoice;
        using NotationsChoicePtr = std::shared_ptr<NotationsChoice>;
        using NotationsChoiceUPtr = std::unique_ptr<NotationsChoice>;
        using NotationsChoiceSet = std::vector<NotationsChoicePtr>;
        using NotationsChoiceSetIter = NotationsChoiceSet::iterator;
        using NotationsChoiceSetIterConst = NotationsChoiceSet::const_iterator;
        inline NotationsChoicePtr makeNotationsChoice() { return std::make_shared<NotationsChoice>(); }
        class NotationsChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                tied = 1,
                slur = 2,
                tuplet = 3,
                glissando = 4,
                slide = 5,
                ornaments = 6,
                technical = 7,
                articulations = 8,
                dynamics = 9,
                fermata = 10,
                arpeggiate = 11,
                nonArpeggiate = 12,
                accidentalMark = 13,
                otherNotation = 14
            };
            NotationsChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice minOccurs = 1, maxOccurs = 1 _________ */
            NotationsChoice::Choice getChoice() const;
            void setChoice( const NotationsChoice::Choice value );
            /* _________ Tied minOccurs = 1, maxOccurs = 1 _________ */
            TiedPtr getTied() const;
            void setTied( const TiedPtr& value );
            /* _________ Slur minOccurs = 1, maxOccurs = 1 _________ */
            SlurPtr getSlur() const;
            void setSlur( const SlurPtr& value );
            /* _________ Tuplet minOccurs = 1, maxOccurs = 1 _________ */
            TupletPtr getTuplet() const;
            void setTuplet( const TupletPtr& value );
            /* _________ Glissando minOccurs = 1, maxOccurs = 1 _________ */
            GlissandoPtr getGlissando() const;
            void setGlissando( const GlissandoPtr& value );
            /* _________ Slide minOccurs = 1, maxOccurs = 1 _________ */
            SlidePtr getSlide() const;
            void setSlide( const SlidePtr& value );
            /* _________ Ornaments minOccurs = 1, maxOccurs = 1 _________ */
            OrnamentsPtr getOrnaments() const;
            void setOrnaments( const OrnamentsPtr& value );
            /* _________ Technical minOccurs = 1, maxOccurs = 1 _________ */
            TechnicalPtr getTechnical() const;
            void setTechnical( const TechnicalPtr& value );
            /* _________ Articulations minOccurs = 1, maxOccurs = 1 _________ */
            ArticulationsPtr getArticulations() const;
            void setArticulations( const ArticulationsPtr& value );
            /* _________ Dynamics minOccurs = 1, maxOccurs = 1 _________ */
            DynamicsPtr getDynamics() const;
            void setDynamics( const DynamicsPtr& value );
            /* _________ Fermata minOccurs = 1, maxOccurs = 1 _________ */
            FermataPtr getFermata() const;
            void setFermata( const FermataPtr& value );
            /* _________ Arpeggiate minOccurs = 1, maxOccurs = 1 _________ */
            ArpeggiatePtr getArpeggiate() const;
            void setArpeggiate( const ArpeggiatePtr& value );
            /* _________ NonArpeggiate minOccurs = 1, maxOccurs = 1 _________ */
            NonArpeggiatePtr getNonArpeggiate() const;
            void setNonArpeggiate( const NonArpeggiatePtr& value );
            /* _________ AccidentalMark minOccurs = 1, maxOccurs = 1 _________ */
            AccidentalMarkPtr getAccidentalMark() const;
            void setAccidentalMark( const AccidentalMarkPtr& value );
            /* _________ OtherNotation minOccurs = 1, maxOccurs = 1 _________ */
            OtherNotationPtr getOtherNotation() const;
            void setOtherNotation( const OtherNotationPtr& value );
        private:
            Choice myChoice;
            TiedPtr myTied;
            SlurPtr mySlur;
            TupletPtr myTuplet;
            GlissandoPtr myGlissando;
            SlidePtr mySlide;
            OrnamentsPtr myOrnaments;
            TechnicalPtr myTechnical;
            ArticulationsPtr myArticulations;
            DynamicsPtr myDynamics;
            FermataPtr myFermata;
            ArpeggiatePtr myArpeggiate;
            NonArpeggiatePtr myNonArpeggiate;
            AccidentalMarkPtr myAccidentalMark;
            OtherNotationPtr myOtherNotation;
        };
        
        struct NotationsAttributes;
        using NotationsAttributesPtr = std::shared_ptr<NotationsAttributes>;
        
        struct NotationsAttributes : public AttributesInterface
        {
        public:
            NotationsAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::YesNo printObject;
            bool hasPrintObject;
        };
        
        class Notations;
        using NotationsPtr = std::shared_ptr<Notations>;
        using NotationsUPtr = std::unique_ptr<Notations>;
        using NotationsSet = std::vector<NotationsPtr>;
        using NotationsSetIter = NotationsSet::iterator;
        using NotationsSetIterConst = NotationsSet::const_iterator;
        inline NotationsPtr makeNotations() { return std::make_shared<Notations>(); }
        class Notations : public ElementInterface
        {
        public:
            Notations();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            NotationsAttributesPtr getAttributes() const;
            void setAttributes( const NotationsAttributesPtr& value );
            /* _________ EditorialGroup minOccurs = 1, maxOccurs = 1 _________ */
            EditorialGroupPtr getEditorialGroup() const;
            void setEditorialGroup( const EditorialGroupPtr& value );
            /* _________ NotationsChoice minOccurs = 0, maxOccurs = unbounded _________ */
            const NotationsChoiceSet& getNotationsChoiceSet() const;
            void addNotationsChoice( const NotationsChoicePtr& value );
            void removeNotationsChoice( const NotationsChoiceSetIterConst& value );
            void clearNotationsChoiceSet();
            NotationsChoicePtr getNotationsChoice( const NotationsChoiceSetIterConst& setIterator ) const;
        private:
            NotationsAttributesPtr myAttributes;
            EditorialGroupPtr myEditorialGroup;
            NotationsChoiceSet myNotationsChoiceSet;
        };
        
        /* <!--  ID = 6307 [6307] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 195 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="note" type="note"/>
         <xs:complexType name="note">
         <xs:annotation>
         <xs:documentation>
         
         Notes are the most common type of MusicXML data.
         The MusicXML format keeps the MuseData distinction between elements
         used for sound information and elements used for notation information
         (e.g., tie is used for sound, tied for notation). Thus grace notes do
         not have a duration element. Cue notes have a duration element, as do
         forward elements, but no tie elements. Having these two types of
         information available can make interchange considerably easier, as
         some programs handle one type of information much more readily than
         the other.
         
         The dynamics and end-dynamics attributes correspond to MIDI 1.0's Note On
         and Note Off velocities, respectively. They are expressed in terms of percentages
         of the default forte value (90 for MIDI 1.0). The attack and release attributes
         are used to alter the starting and stopping time of the note from when it would
         otherwise occur based on the flow of durations - information that is specific to
         a performance. They are expressed in terms of divisions, either positive or
         negative. A note that starts a tie should not have a release attribute, and a
         note that stops a tie should not have an attack attribute. If a note is played
         only particular times through a repeat, the time-only attribute shows which times
         to play the note. The pizzicato attribute is used when just this note is sounded
         pizzicato, vs. the pizzicato element which changes overall playback between pizzicato
         and arco.
         
         </xs:documentation>
         
         </xs:annotation>
         <xs:sequence>
         <xs:choice>
         <xs:sequence>
         <xs:element name="grace" type="grace"/>
         <xs:group ref="full-note"/>
         <xs:element name="tie" type="tie" minOccurs="0" maxOccurs="2"/>
         </xs:sequence>
         <xs:sequence>
         <xs:element name="cue" type="empty">
         <xs:annotation>
         <xs:documentation>The cue element indicates the presence of a cue note.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:group ref="full-note"/>
         <xs:group ref="duration"/>
         </xs:sequence>
         <xs:sequence>
         <xs:group ref="full-note"/>
         <xs:group ref="duration"/>
         <xs:element name="tie" type="tie" minOccurs="0" maxOccurs="2"/>
         </xs:sequence>
         </xs:choice>
         <xs:element name="instrument" type="instrument" minOccurs="0"/>
         <xs:group ref="editorial-voice"/>
         <xs:element name="type" type="note-type" minOccurs="0"/>
         <xs:element name="dot" type="empty-placement" minOccurs="0" maxOccurs="unbounded">
         <xs:annotation>
         <xs:documentation>One dot element is used for each dot of prolongation. The placement element is used to specify whether the dot should appear above or below the staff line. It is ignored for notes that appear on a staff space.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="accidental" type="accidental" minOccurs="0"/>
         <xs:element name="time-modification" type="time-modification" minOccurs="0"/>
         <xs:element name="stem" type="stem" minOccurs="0"/>
         <xs:element name="notehead" type="notehead" minOccurs="0"/>
         <xs:element name="notehead-text" type="notehead-text" minOccurs="0"/>
         <xs:group ref="staff" minOccurs="0"/>
         <xs:element name="beam" type="beam" minOccurs="0" maxOccurs="8"/>
         <xs:element name="notations" type="notations" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="lyric" type="lyric" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="play" type="play" minOccurs="0"/>
         </xs:sequence>
         <xs:attributeGroup ref="x-position"/>
         <xs:attributeGroup ref="font"/>
         <xs:attributeGroup ref="color"/>
         <xs:attributeGroup ref="printout"/>
         <xs:attribute name="dynamics" type="non-negative-decimal"/>
         <xs:attribute name="end-dynamics" type="non-negative-decimal"/>
         <xs:attribute name="attack" type="divisions"/>
         <xs:attribute name="release" type="divisions"/>
         <xs:attribute name="time-only" type="time-only"/>
         <xs:attribute name="pizzicato" type="yes-no"/>
         </xs:complexType>
         <xs:group name="full-note">
         <xs:annotation>
         <xs:documentation>The full-note group is a sequence of the common note elements between cue/grace notes and regular (full) notes: pitch, chord, and rest information, but not duration (cue and grace notes do not have duration encoded). Unpitched elements are used for unpitched percussion, speaking voice, and other musical elements lacking determinate pitch.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="chord" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The chord element indicates that this note is an additional chord tone with the preceding note. The duration of this note can be no longer than the preceding note. In MuseData, a missing duration indicates the same length as the previous note, but the MusicXML format requires a duration for chord notes too.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:choice>
         <xs:element name="pitch" type="pitch"/>
         <xs:element name="unpitched" type="unpitched"/>
         <xs:element name="rest" type="rest"/>
         </xs:choice>
         </xs:sequence>
         </xs:group>
         <xs:group name="full-note">
         <xs:annotation>
         <xs:documentation>The full-note group is a sequence of the common note elements between cue/grace notes and regular (full) notes: pitch, chord, and rest information, but not duration (cue and grace notes do not have duration encoded). Unpitched elements are used for unpitched percussion, speaking voice, and other musical elements lacking determinate pitch.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="chord" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The chord element indicates that this note is an additional chord tone with the preceding note. The duration of this note can be no longer than the preceding note. In MuseData, a missing duration indicates the same length as the previous note, but the MusicXML format requires a duration for chord notes too.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:choice>
         <xs:element name="pitch" type="pitch"/>
         <xs:element name="unpitched" type="unpitched"/>
         <xs:element name="rest" type="rest"/>
         </xs:choice>
         </xs:sequence>
         </xs:group>
         <xs:group name="duration">
         <xs:annotation>
         <xs:documentation>The duration element is defined within a group due to its uses within the note, figure-bass, backup, and forward elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="duration" type="positive-divisions">
         <xs:annotation>
         <xs:documentation>Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, swing eighths vs. even eighths, or differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should use the note element's attack and release attributes.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         <xs:group name="full-note">
         <xs:annotation>
         <xs:documentation>The full-note group is a sequence of the common note elements between cue/grace notes and regular (full) notes: pitch, chord, and rest information, but not duration (cue and grace notes do not have duration encoded). Unpitched elements are used for unpitched percussion, speaking voice, and other musical elements lacking determinate pitch.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="chord" type="empty" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The chord element indicates that this note is an additional chord tone with the preceding note. The duration of this note can be no longer than the preceding note. In MuseData, a missing duration indicates the same length as the previous note, but the MusicXML format requires a duration for chord notes too.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:choice>
         <xs:element name="pitch" type="pitch"/>
         <xs:element name="unpitched" type="unpitched"/>
         <xs:element name="rest" type="rest"/>
         </xs:choice>
         </xs:sequence>
         </xs:group>
         <xs:group name="duration">
         <xs:annotation>
         <xs:documentation>The duration element is defined within a group due to its uses within the note, figure-bass, backup, and forward elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="duration" type="positive-divisions">
         <xs:annotation>
         <xs:documentation>Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, swing eighths vs. even eighths, or differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should use the note element's attack and release attributes.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         <xs:group name="editorial-voice">
         <xs:annotation>
         <xs:documentation>The editorial-voice group supports the common combination of editorial and voice information for a musical element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="footnote" minOccurs="0"/>
         <xs:group ref="level" minOccurs="0"/>
         <xs:group ref="voice" minOccurs="0"/>
         </xs:sequence>
         </xs:group>
         <xs:group name="staff">
         <xs:annotation>
         <xs:documentation>The staff element is defined within a group due to its use by both notes and direction elements.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="staff" type="xs:positiveInteger">
         <xs:annotation>
         <xs:documentation>Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group>
         
         */
        
        class FullNoteTypeChoice;
        using FullNoteTypeChoicePtr = std::shared_ptr<FullNoteTypeChoice>;
        using FullNoteTypeChoiceUPtr = std::unique_ptr<FullNoteTypeChoice>;
        using FullNoteTypeChoiceSet = std::vector<FullNoteTypeChoicePtr>;
        using FullNoteTypeChoiceSetIter = FullNoteTypeChoiceSet::iterator;
        using FullNoteTypeChoiceSetIterConst = FullNoteTypeChoiceSet::const_iterator;
        inline FullNoteTypeChoicePtr makeFullNoteTypeChoice() { return std::make_shared<FullNoteTypeChoice>(); }
        class FullNoteTypeChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                pitch = 1,
                unpitched = 2,
                rest = 3
            };
            FullNoteTypeChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice minOccurs = 1, maxOccurs = 1 _________ */
            FullNoteTypeChoice::Choice getChoice() const;
            void setChoice( const FullNoteTypeChoice::Choice value );
            /* _________ Pitch minOccurs = 1, maxOccurs = 1 _________ */
            PitchPtr getPitch() const;
            void setPitch( const PitchPtr& value );
            /* _________ Unpitched minOccurs = 1, maxOccurs = 1 _________ */
            UnpitchedPtr getUnpitched() const;
            void setUnpitched( const UnpitchedPtr& value );
            /* _________ Rest minOccurs = 1, maxOccurs = 1 _________ */
            RestPtr getRest() const;
            void setRest( const RestPtr& value );
        private:
            Choice myChoice;
            PitchPtr myPitch;
            UnpitchedPtr myUnpitched;
            RestPtr myRest;
        };
        
        class FullNoteGroup;
        using FullNoteGroupPtr = std::shared_ptr<FullNoteGroup>;
        using FullNoteGroupUPtr = std::unique_ptr<FullNoteGroup>;
        using FullNoteGroupSet = std::vector<FullNoteGroupPtr>;
        using FullNoteGroupSetIter = FullNoteGroupSet::iterator;
        using FullNoteGroupSetIterConst = FullNoteGroupSet::const_iterator;
        inline FullNoteGroupPtr makeFullNoteGroup() { return std::make_shared<FullNoteGroup>(); }
        class FullNoteGroup : public ElementInterface
        {
        public:
            FullNoteGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Chord minOccurs = 0, maxOccurs = 1 _________ */
            ChordPtr getChord() const;
            void setChord( const ChordPtr& value );
            bool getHasChord() const;
            void setHasChord( const bool value );
            /* _________ FullNoteTypeChoice minOccurs = 1, maxOccurs = 1 _________ */
            FullNoteTypeChoicePtr getFullNoteTypeChoice() const;
            void setFullNoteTypeChoice( const FullNoteTypeChoicePtr& value );
        private:
            ChordPtr myChord;
            bool myHasChord;
            FullNoteTypeChoicePtr myFullNoteTypeChoice;
        };
        
        class GraceNoteGroup;
        using GraceNoteGroupPtr = std::shared_ptr<GraceNoteGroup>;
        using GraceNoteGroupUPtr = std::unique_ptr<GraceNoteGroup>;
        using GraceNoteGroupSet = std::vector<GraceNoteGroupPtr>;
        using GraceNoteGroupSetIter = GraceNoteGroupSet::iterator;
        using GraceNoteGroupSetIterConst = GraceNoteGroupSet::const_iterator;
        inline GraceNoteGroupPtr makeGraceNoteGroup() { return std::make_shared<GraceNoteGroup>(); }
        class GraceNoteGroup : public ElementInterface
        {
        public:
            GraceNoteGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Grace minOccurs = 1, maxOccurs = 1 _________ */
            GracePtr getGrace() const;
            void setGrace( const GracePtr& value );
            /* _________ FullNoteGroup minOccurs = 1, maxOccurs = 1 _________ */
            FullNoteGroupPtr getFullNoteGroup() const;
            void setFullNoteGroup( const FullNoteGroupPtr& value );
            /* _________ Tie minOccurs = 0, maxOccurs = 2 _________ */
            const TieSet& getTieSet() const;
            void addTie( const TiePtr& value );
            void removeTie( const TieSetIterConst& value );
            void clearTieSet();
            TiePtr getTie( const TieSetIterConst& setIterator ) const;
        private:
            GracePtr myGrace;
            FullNoteGroupPtr myFullNoteGroup;
            TieSet myTieSet; // min 0 max 2 //
            bool myHasTie;
        };
        
        class CueNoteGroup;
        using CueNoteGroupPtr = std::shared_ptr<CueNoteGroup>;
        using CueNoteGroupUPtr = std::unique_ptr<CueNoteGroup>;
        using CueNoteGroupSet = std::vector<CueNoteGroupPtr>;
        using CueNoteGroupSetIter = CueNoteGroupSet::iterator;
        using CueNoteGroupSetIterConst = CueNoteGroupSet::const_iterator;
        inline CueNoteGroupPtr makeCueNoteGroup() { return std::make_shared<CueNoteGroup>(); }
        class CueNoteGroup : public ElementInterface
        {
        public:
            CueNoteGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Cue minOccurs = 1, maxOccurs = 1 _________ */
            CuePtr getCue() const;
            void setCue( const CuePtr& value );
            /* _________ FullNoteGroup minOccurs = 1, maxOccurs = 1 _________ */
            FullNoteGroupPtr getFullNoteGroup() const;
            void setFullNoteGroup( const FullNoteGroupPtr& value );
            /* _________ Duration minOccurs = 1, maxOccurs = 1 _________ */
            DurationPtr getDuration() const;
            void setDuration( const DurationPtr& value );
        private:
            CuePtr myCue;
            FullNoteGroupPtr myFullNoteGroup;
            DurationPtr myDuration;
        };
        
        class NormalNoteGroup;
        using NormalNoteGroupPtr = std::shared_ptr<NormalNoteGroup>;
        using NormalNoteGroupUPtr = std::unique_ptr<NormalNoteGroup>;
        using NormalNoteGroupSet = std::vector<NormalNoteGroupPtr>;
        using NormalNoteGroupSetIter = NormalNoteGroupSet::iterator;
        using NormalNoteGroupSetIterConst = NormalNoteGroupSet::const_iterator;
        inline NormalNoteGroupPtr makeNormalNoteGroup() { return std::make_shared<NormalNoteGroup>(); }
        class NormalNoteGroup : public ElementInterface
        {
        public:
            NormalNoteGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ FullNoteGroup minOccurs = 1, maxOccurs = 1 _________ */
            FullNoteGroupPtr getFullNoteGroup() const;
            void setFullNoteGroup( const FullNoteGroupPtr& value );
            /* _________ Duration minOccurs = 1, maxOccurs = 1 _________ */
            DurationPtr getDuration() const;
            void setDuration( const DurationPtr& value );
            /* _________ Tie minOccurs = 0, maxOccurs = 2 _________ */
            const TieSet& getTieSet() const;
            void addTie( const TiePtr& value );
            void removeTie( const TieSetIterConst& value );
            void clearTieSet();
            TiePtr getTie( const TieSetIterConst& setIterator ) const;
        private:
            FullNoteGroupPtr myFullNoteGroup;
            DurationPtr myDuration;
            TieSet myTieSet; // min 0 max 2 //
        };
        
        class NoteChoice;
        using NoteChoicePtr = std::shared_ptr<NoteChoice>;
        using NoteChoiceUPtr = std::unique_ptr<NoteChoice>;
        using NoteChoiceSet = std::vector<NoteChoicePtr>;
        using NoteChoiceSetIter = NoteChoiceSet::iterator;
        using NoteChoiceSetIterConst = NoteChoiceSet::const_iterator;
        inline NoteChoicePtr makeNoteChoice() { return std::make_shared<NoteChoice>(); }
        class NoteChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                grace = 1,
                cue = 2,
                normal = 3
            };
            NoteChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice minOccurs = 1, maxOccurs = 1 _________ */
            NoteChoice::Choice getChoice() const;
            void setChoice( const NoteChoice::Choice value );
            /* _________ GraceNoteGroup minOccurs = 1, maxOccurs = 1 _________ */
            GraceNoteGroupPtr getGraceNoteGroup() const;
            void setGraceNoteGroup( const GraceNoteGroupPtr& value );
            /* _________ CueNoteGroup minOccurs = 1, maxOccurs = 1 _________ */
            CueNoteGroupPtr getCueNoteGroup() const;
            void setCueNoteGroup( const CueNoteGroupPtr& value );
            /* _________ NormalNoteGroup minOccurs = 1, maxOccurs = 1 _________ */
            NormalNoteGroupPtr getNormalNoteGroup() const;
            void setNormalNoteGroup( const NormalNoteGroupPtr& value );
        private:
            Choice myChoice;
            GraceNoteGroupPtr myGraceNoteGroup;
            CueNoteGroupPtr myCueNoteGroup;
            NormalNoteGroupPtr myNormalNoteGroup;
        };
        
        struct NoteAttributes;
        using NoteAttributesPtr = std::shared_ptr<NoteAttributes>;
        
        struct NoteAttributes : public AttributesInterface
        {
        public:
            NoteAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::TenthsValue defaultX;
            t::TenthsValue defaultY;
            t::TenthsValue relativeX;
            t::TenthsValue relativeY;
            t::CommaSeparatedText fontFamily;
            t::FontStyle fontStyle;
            t::FontSize fontSize;
            t::FontWeight fontWeight;
            t::Color color;
            t::YesNo printObject;
            t::YesNo printDot;
            t::YesNo printSpacing;
            t::YesNo printLyric;
            t::NonNegativeDecimal dynamics;
            t::NonNegativeDecimal endDynamics;
            t::DivisionsValue attack;
            t::DivisionsValue release;
            t::TimeOnly timeOnly;
            t::YesNo pizzicato;
            bool hasDefaultX;
            bool hasDefaultY;
            bool hasRelativeX;
            bool hasRelativeY;
            bool hasFontFamily;
            bool hasFontStyle;
            bool hasFontSize;
            bool hasFontWeight;
            bool hasColor;
            bool hasPrintObject;
            bool hasPrintDot;
            bool hasPrintSpacing;
            bool hasPrintLyric;
            bool hasDynamics;
            bool hasEndDynamics;
            bool hasAttack;
            bool hasRelease;
            bool hasTimeOnly;
            bool hasPizzicato;
        };
        
        class Note;
        using NotePtr = std::shared_ptr<Note>;
        using NoteUPtr = std::unique_ptr<Note>;
        using NoteSet = std::vector<NotePtr>;
        using NoteSetIter = NoteSet::iterator;
        using NoteSetIterConst = NoteSet::const_iterator;
        inline NotePtr makeNote() { return std::make_shared<Note>(); }
        class Note : public ElementInterface
        {
        public:
            Note();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            NoteAttributesPtr getAttributes() const;
            void setAttributes( const NoteAttributesPtr& value );
            /* _________ NoteChoice minOccurs = 1, maxOccurs = 1 _________ */
            NoteChoicePtr getNoteChoice() const;
            void setNoteChoice( const NoteChoicePtr& value );
            /* _________ Instrument minOccurs = 0, maxOccurs = 1 _________ */
            InstrumentPtr getInstrument() const;
            void setInstrument( const InstrumentPtr& value );
            bool getHasInstrument() const;
            void setHasInstrument( const bool value );
            /* _________ EditorialVoiceGroup minOccurs = 1, maxOccurs = 1 _________ */
            EditorialVoiceGroupPtr getEditorialVoiceGroup() const;
            void setEditorialVoiceGroup( const EditorialVoiceGroupPtr& value );
            /* _________ Type minOccurs = 0, maxOccurs = 1 _________ */
            TypePtr getType() const;
            void setType( const TypePtr& value );
            bool getHasType() const;
            void setHasType( const bool value );
            /* _________ Dot minOccurs = 0, maxOccurs = unbounded _________ */
            const DotSet& getDotSet() const;
            void addDot( const DotPtr& value );
            void removeDot( const DotSetIterConst& value );
            void clearDotSet();
            DotPtr getDot( const DotSetIterConst& setIterator ) const;
            /* _________ Accidental minOccurs = 0, maxOccurs = 1 _________ */
            AccidentalPtr getAccidental() const;
            void setAccidental( const AccidentalPtr& value );
            bool getHasAccidental() const;
            void setHasAccidental( const bool value );
            /* _________ TimeModification minOccurs = 0, maxOccurs = 1 _________ */
            TimeModificationPtr getTimeModification() const;
            void setTimeModification( const TimeModificationPtr& value );
            bool getHasTimeModification() const;
            void setHasTimeModification( const bool value );
            /* _________ Stem minOccurs = 0, maxOccurs = 1 _________ */
            StemPtr getStem() const;
            void setStem( const StemPtr& value );
            bool getHasStem() const;
            void setHasStem( const bool value );
            /* _________ Notehead minOccurs = 0, maxOccurs = 1 _________ */
            NoteheadPtr getNotehead() const;
            void setNotehead( const NoteheadPtr& value );
            bool getHasNotehead() const;
            void setHasNotehead( const bool value );
            /* _________ NoteheadText minOccurs = 0, maxOccurs = 1 _________ */
            NoteheadTextPtr getNoteheadText() const;
            void setNoteheadText( const NoteheadTextPtr& value );
            bool getHasNoteheadText() const;
            void setHasNoteheadText( const bool value );
            /* _________ Staff minOccurs = 0, maxOccurs = 1 _________ */
            StaffPtr getStaff() const;
            void setStaff( const StaffPtr& value );
            bool getHasStaff() const;
            void setHasStaff( const bool value );
            /* _________ Beam minOccurs = 0, maxOccurs = 8 _________ */
            const BeamSet& getBeamSet() const;
            void addBeam( const BeamPtr& value );
            void removeBeam( const BeamSetIterConst& value );
            void clearBeamSet();
            BeamPtr getBeam( const BeamSetIterConst& setIterator ) const;
            /* _________ Notations minOccurs = 0, maxOccurs = unbounded _________ */
            const NotationsSet& getNotationsSet() const;
            void addNotations( const NotationsPtr& value );
            void removeNotations( const NotationsSetIterConst& value );
            void clearNotationsSet();
            NotationsPtr getNotations( const NotationsSetIterConst& setIterator ) const;
            /* _________ Lyric minOccurs = 0, maxOccurs = unbounded _________ */
            const LyricSet& getLyricSet() const;
            void addLyric( const LyricPtr& value );
            void removeLyric( const LyricSetIterConst& value );
            void clearLyricSet();
            LyricPtr getLyric( const LyricSetIterConst& setIterator ) const;
            /* _________ Play minOccurs = 0, maxOccurs = 1 _________ */
            PlayPtr getPlay() const;
            void setPlay( const PlayPtr& value );
            bool getHasPlay() const;
            void setHasPlay( const bool value );
        private:
            NoteAttributesPtr myAttributes;
            NoteChoicePtr myNoteChoice;
            InstrumentPtr myInstrument;
            bool myHasInstrument;
            EditorialVoiceGroupPtr myEditorialVoiceGroup;
            TypePtr myType;
            bool myHasType;
            DotSet myDotSet;
            AccidentalPtr myAccidental;
            bool myHasAccidental;
            TimeModificationPtr myTimeModification;
            bool myHasTimeModification;
            StemPtr myStem;
            bool myHasStem;
            NoteheadPtr myNotehead;
            bool myHasNotehead;
            NoteheadTextPtr myNoteheadText;
            bool myHasNoteheadText;
            StaffPtr myStaff;
            bool myHasStaff;
            BeamSet myBeamSet; // min 0 max 8 //
            NotationsSet myNotationsSet;
            LyricSet myLyricSet;
            PlayPtr myPlay;
            bool myHasPlay;
        };
        
        /* <!--  ID = 6388 [6388] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 112 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="part-list" type="part-list"/>
         
         <xs:complexType name="part-list">
         <xs:annotation>
         <xs:documentation>The part-list identifies the different musical parts in this movement. Each part has an ID that is used later within the musical data. Since parts may be encoded separately and combined later, identification elements are present at both the score and score-part levels. There must be at least one score-part, combined as desired with part-group elements that indicate braces and brackets. Parts are ordered from top to bottom in a score based on the order in which they appear in the part-list.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:group ref="part-group" minOccurs="0" maxOccurs="unbounded"/>
         <xs:group ref="score-part"/>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:group ref="part-group"/>
         <xs:group ref="score-part"/>
         </xs:choice>
         </xs:sequence>
         </xs:complexType>
         
         <xs:group name="part-group">
         <xs:annotation>
         <xs:documentation>The part-group element is defined within a group due to its multiple uses within the part-list element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="part-group" type="part-group"/>
         </xs:sequence>
         </xs:group>
         
         <xs:group name="score-part">
         <xs:annotation>
         <xs:documentation>The score-part element is defined within a group due to its multiple uses within the part-list element.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="score-part" type="score-part">
         <xs:annotation>
         <xs:documentation>Each MusicXML part corresponds to a track in a Standard MIDI Format 1 file. The score-instrument elements are used when there are multiple instruments per track. The midi-device element is used to make a MIDI device or port assignment for the given track. Initial midi-instrument assignments may be made here as well.</xs:documentation>
         </xs:annotation>
         </xs:element>
         </xs:sequence>
         </xs:group> */
        
        class PartGroupOrScorePart;
        using PartGroupOrScorePartPtr = std::shared_ptr<PartGroupOrScorePart>;
        using PartGroupOrScorePartUPtr = std::unique_ptr<PartGroupOrScorePart>;
        using PartGroupOrScorePartSet = std::vector<PartGroupOrScorePartPtr>;
        using PartGroupOrScorePartSetIter = PartGroupOrScorePartSet::iterator;
        using PartGroupOrScorePartSetIterConst = PartGroupOrScorePartSet::const_iterator;
        inline PartGroupOrScorePartPtr makePartGroupOrScorePart() { return std::make_shared<PartGroupOrScorePart>(); }
        class PartGroupOrScorePart : public ElementInterface
        {
        public:
            enum class Choice
            {
                partGroup = 1,
                scorePart = 2
            };
            PartGroupOrScorePart();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice minOccurs = 1, maxOccurs = 1 _________ */
            PartGroupOrScorePart::Choice getChoice() const;
            void setChoice( const PartGroupOrScorePart::Choice value );
            /* _________ PartGroup minOccurs = 1, maxPartGroupOccurs = 1 _________ */
            PartGroupPtr getPartGroup() const;
            void setPartGroup( const PartGroupPtr& value );
            /* _________ ScorePart minOccurs = 1, maxOccurs = 1 _________ */
            ScorePartPtr getScorePart() const;
            void setScorePart( const ScorePartPtr& value );
        private:
            Choice myChoice;
            PartGroupPtr myPartGroup;
            ScorePartPtr myScorePart;
        };
        
        class PartList;
        using PartListPtr = std::shared_ptr<PartList>;
        using PartListUPtr = std::unique_ptr<PartList>;
        using PartListSet = std::vector<PartListPtr>;
        using PartListSetIter = PartListSet::iterator;
        using PartListSetIterConst = PartListSet::const_iterator;
        inline PartListPtr makePartList() { return std::make_shared<PartList>(); }
        class PartList : public ElementInterface
        {
        public:
            PartList();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ PartGroup minOccurs = 0, maxOccurs = unbounded _________ */
            const PartGroupSet& getPartGroupSet() const;
            void addPartGroup( const PartGroupPtr& value );
            void removePartGroup( const PartGroupSetIterConst& value );
            void clearPartGroupSet();
            PartGroupPtr getPartGroup( const PartGroupSetIterConst& setIterator ) const;
            /* _________ ScorePart minOccurs = 1, maxOccurs = 1 _________ */
            ScorePartPtr getScorePart() const;
            void setScorePart( const ScorePartPtr& value );
            /* _________ PartGroupOrScorePart minOccurs = 0, maxOccurs = unbounded _________ */
            const PartGroupOrScorePartSet& getPartGroupOrScorePartSet() const;
            void addPartGroupOrScorePart( const PartGroupOrScorePartPtr& value );
            void removePartGroupOrScorePart( const PartGroupOrScorePartSetIterConst& value );
            void clearPartGroupOrScorePartSet();
            PartGroupOrScorePartPtr getPartGroupOrScorePart( const PartGroupOrScorePartSetIterConst& setIterator ) const;
        private:
            PartGroupSet myPartGroupSet; /* minOccurs="0" maxOccurs="unbounded" */
            ScorePartPtr myScorePart; /* minOccurs="1" maxOccurs="1" */
            PartGroupOrScorePartSet myPartGroupOrScorePartSet; /* minOccurs="0" maxOccurs="unbounded" */
        };
        
        /* <!--  ID = 6418 [6418, 6440] ------------------------->
         <!-- min=1 max=4294967295 OneOrMMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 470 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="measure" maxOccurs="unbounded">
         <xs:complexType>
         <xs:group ref="music-data"/>
         <xs:attributeGroup ref="measure-attributes"/>
         </xs:complexType>
         </xs:element>
         <xs:group name="music-data">
         <xs:annotation>
         <xs:documentation>The music-data group contains the basic musical data that is either associated with a part or a measure, depending on whether the partwise or timewise hierarchy is used.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="note" type="note"/>
         <xs:element name="backup" type="backup"/>
         <xs:element name="forward" type="forward"/>
         <xs:element name="direction" type="direction"/>
         <xs:element name="attributes" type="attributes"/>
         <xs:element name="harmony" type="harmony"/>
         <xs:element name="figured-bass" type="figured-bass"/>
         <xs:element name="print" type="print"/>
         <xs:element name="sound" type="sound"/>
         <xs:element name="barline" type="barline"/>
         <xs:element name="grouping" type="grouping"/>
         <xs:element name="link" type="link"/>
         <xs:element name="bookmark" type="bookmark"/>
         </xs:choice>
         </xs:sequence>
         </xs:group> */
        
        class MusicDataChoice;
        using MusicDataChoicePtr = std::shared_ptr<MusicDataChoice>;
        using MusicDataChoiceUPtr = std::unique_ptr<MusicDataChoice>;
        using MusicDataChoiceSet = std::vector<MusicDataChoicePtr>;
        using MusicDataChoiceSetIter = MusicDataChoiceSet::iterator;
        using MusicDataChoiceSetIterConst = MusicDataChoiceSet::const_iterator;
        inline MusicDataChoicePtr makeMusicDataChoice() { return std::make_shared<MusicDataChoice>(); }
        class MusicDataChoice : public ElementInterface
        {
        public:
            enum class Choice
            {
                note = 1,
                backup = 2,
                forward = 3,
                direction = 4,
                properties = 5,
                harmony = 6,
                figuredBass = 7,
                print = 8,
                sound = 9,
                barline = 10,
                grouping = 11,
                link = 12,
                bookmark = 13
            };
            MusicDataChoice();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Choice minOccurs = 1, maxOccurs = 1 _________ */
            MusicDataChoice::Choice getChoice() const;
            void setChoice( const MusicDataChoice::Choice value );
            /* _________ Note minOccurs = 1, maxOccurs = 1 _________ */
            NotePtr getNote() const;
            void setNote( const NotePtr& value );
            /* _________ Backup minOccurs = 1, maxOccurs = 1 _________ */
            BackupPtr getBackup() const;
            void setBackup( const BackupPtr& value );
            /* _________ Forward minOccurs = 1, maxOccurs = 1 _________ */
            ForwardPtr getForward() const;
            void setForward( const ForwardPtr& value );
            /* _________ Direction minOccurs = 1, maxOccurs = 1 _________ */
            DirectionPtr getDirection() const;
            void setDirection( const DirectionPtr& value );
            /* _________ Properties minOccurs = 1, maxOccurs = 1 _________ */
            PropertiesPtr getProperties() const;
            void setProperties( const PropertiesPtr& value );
            /* _________ Harmony minOccurs = 1, maxOccurs = 1 _________ */
            HarmonyPtr getHarmony() const;
            void setHarmony( const HarmonyPtr& value );
            /* _________ FiguredBass minOccurs = 1, maxOccurs = 1 _________ */
            FiguredBassPtr getFiguredBass() const;
            void setFiguredBass( const FiguredBassPtr& value );
            /* _________ Print minOccurs = 1, maxOccurs = 1 _________ */
            PrintPtr getPrint() const;
            void setPrint( const PrintPtr& value );
            /* _________ Sound minOccurs = 1, maxOccurs = 1 _________ */
            SoundPtr getSound() const;
            void setSound( const SoundPtr& value );
            /* _________ Barline minOccurs = 1, maxOccurs = 1 _________ */
            BarlinePtr getBarline() const;
            void setBarline( const BarlinePtr& value );
            /* _________ Grouping minOccurs = 1, maxOccurs = 1 _________ */
            GroupingPtr getGrouping() const;
            void setGrouping( const GroupingPtr& value );
            /* _________ Link minOccurs = 1, maxOccurs = 1 _________ */
            LinkPtr getLink() const;
            void setLink( const LinkPtr& value );
            /* _________ Bookmark minOccurs = 1, maxOccurs = 1 _________ */
            BookmarkPtr getBookmark() const;
            void setBookmark( const BookmarkPtr& value );
        private:
            Choice myChoice;
            NotePtr myNote;
            BackupPtr myBackup;
            ForwardPtr myForward;
            DirectionPtr myDirection;
            PropertiesPtr myProperties;
            HarmonyPtr myHarmony;
            FiguredBassPtr myFiguredBass;
            PrintPtr myPrint;
            SoundPtr mySound;
            BarlinePtr myBarline;
            GroupingPtr myGrouping;
            LinkPtr myLink;
            BookmarkPtr myBookmark;
        };
        
        class MusicDataGroup;
        using MusicDataGroupPtr = std::shared_ptr<MusicDataGroup>;
        using MusicDataGroupUPtr = std::unique_ptr<MusicDataGroup>;
        using MusicDataGroupSet = std::vector<MusicDataGroupPtr>;
        using MusicDataGroupSetIter = MusicDataGroupSet::iterator;
        using MusicDataGroupSetIterConst = MusicDataGroupSet::const_iterator;
        inline MusicDataGroupPtr makeMusicDataGroup() { return std::make_shared<MusicDataGroup>(); }
        class MusicDataGroup : public ElementInterface
        {
        public:
            MusicDataGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ MusicDataChoice minOccurs = 0, maxOccurs = unbounded _________ */
            const MusicDataChoiceSet& getMusicDataChoiceSet() const;
            void addMusicDataChoice( const MusicDataChoicePtr& value );
            void removeMusicDataChoice( const MusicDataChoiceSetIterConst& value );
            void clearMusicDataChoiceSet();
            MusicDataChoicePtr getMusicDataChoice( const MusicDataChoiceSetIterConst& setIterator ) const;
        private:
            MusicDataChoiceSet myMusicDataChoiceSet;
        };
        
        struct MeasureAttributes;
        using MeasureAttributesPtr = std::shared_ptr<MeasureAttributes>;
        
        struct MeasureAttributes : public AttributesInterface
        {
        public:
            MeasureAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken number;
            t::YesNo implicit;
            t::YesNo nonControlling;
            t::TenthsValue width;
            const 	bool hasNumber;
            bool hasImplicit;
            bool hasNonControlling;
            bool hasWidth;
        };
        
        class PartwiseMeasure;
        using PartwiseMeasurePtr = std::shared_ptr<PartwiseMeasure>;
        using PartwiseMeasureUPtr = std::unique_ptr<PartwiseMeasure>;
        using PartwiseMeasureSet = std::vector<PartwiseMeasurePtr>;
        using PartwiseMeasureSetIter = PartwiseMeasureSet::iterator;
        using PartwiseMeasureSetIterConst = PartwiseMeasureSet::const_iterator;
        inline PartwiseMeasurePtr makePartwiseMeasure() { return std::make_shared<PartwiseMeasure>(); }
        class PartwiseMeasure : public ElementInterface
        {
        public:
            PartwiseMeasure();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MeasureAttributesPtr getAttributes() const;
            void setAttributes( const MeasureAttributesPtr& value );
            /* _________ MusicDataGroup minOccurs = 1, maxOccurs = 1 _________ */
            MusicDataGroupPtr getMusicDataGroup() const;
            void setMusicDataGroup( const MusicDataGroupPtr& value );
        private:
            MeasureAttributesPtr myAttributes;
            MusicDataGroupPtr myMusicDataGroup;
        };
        /* <!--  ID = 6413 [6413, 6445] ------------------------->
         <!-- min=1 max=4294967295 OneOrMMany  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 471 -->
         <!-- All Sub Elements Are Implemented: false -->
         <xs:element name="part" maxOccurs="unbounded">
         <xs:complexType>
         <xs:sequence>
         <xs:element name="measure" maxOccurs="unbounded">
         <xs:complexType>
         <xs:group ref="music-data"/>
         <xs:attributeGroup ref="measure-attributes"/>
         </xs:complexType>
         </xs:element>
         </xs:sequence>
         <xs:attributeGroup ref="part-attributes"/>
         </xs:complexType>
         </xs:element>
         <xs:group name="music-data">
         <xs:annotation>
         <xs:documentation>The music-data group contains the basic musical data that is either associated with a part or a measure, depending on whether the partwise or timewise hierarchy is used.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="note" type="note"/>
         <xs:element name="backup" type="backup"/>
         <xs:element name="forward" type="forward"/>
         <xs:element name="direction" type="direction"/>
         <xs:element name="attributes" type="attributes"/>
         <xs:element name="harmony" type="harmony"/>
         <xs:element name="figured-bass" type="figured-bass"/>
         <xs:element name="print" type="print"/>
         <xs:element name="sound" type="sound"/>
         <xs:element name="barline" type="barline"/>
         <xs:element name="grouping" type="grouping"/>
         <xs:element name="link" type="link"/>
         <xs:element name="bookmark" type="bookmark"/>
         </xs:choice>
         </xs:sequence>
         </xs:group> */
        
        struct PartAttributes;
        using PartAttributesPtr = std::shared_ptr<PartAttributes>;
        
        struct PartAttributes : public AttributesInterface
        {
        public:
            PartAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsIDREF id;
            const bool hasId;
        };
        
        class PartwisePart;
        using PartwisePartPtr = std::shared_ptr<PartwisePart>;
        using PartwisePartUPtr = std::unique_ptr<PartwisePart>;
        using PartwisePartSet = std::vector<PartwisePartPtr>;
        using PartwisePartSetIter = PartwisePartSet::iterator;
        using PartwisePartSetIterConst = PartwisePartSet::const_iterator;
        inline PartwisePartPtr makePartwisePart() { return std::make_shared<PartwisePart>(); }
        class PartwisePart : public ElementInterface
        {
        public:
            PartwisePart();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PartAttributesPtr getAttributes() const;
            void setAttributes( const PartAttributesPtr& value );
            /* _________ PartwiseMeasure minOccurs = 0, maxOccurs = unbounded _________ */
            const PartwiseMeasureSet& getPartwiseMeasureSet() const;
            void addPartwiseMeasure( const PartwiseMeasurePtr& value );
            void removePartwiseMeasure( const PartwiseMeasureSetIterConst& value );
            void clearPartwiseMeasureSet();
            PartwiseMeasurePtr getPartwiseMeasure( const PartwiseMeasureSetIterConst& setIterator ) const;
        private:
            PartAttributesPtr myAttributes;
            PartwiseMeasureSet myPartwiseMeasureSet;
        };
        
        /*
         <xs:group name="score-header">
         <xs:annotation>
         <xs:documentation>The score-header group contains basic score metadata about the work and movement, score-wide defaults for layout and fonts, credits that appear on the first or following pages, and the part list.</xs:documentation>
         </xs:annotation>
         <xs:sequence>
         <xs:element name="work" type="work" minOccurs="0"/>
         <xs:element name="movement-number" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The movement-number element specifies the number of a movement.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="movement-title" type="xs:string" minOccurs="0">
         <xs:annotation>
         <xs:documentation>The movement-title element specifies the title of a movement, not including its number.</xs:documentation>
         </xs:annotation>
         </xs:element>
         <xs:element name="identification" type="identification" minOccurs="0"/>
         <xs:element name="defaults" type="defaults" minOccurs="0"/>
         <xs:element name="credit" type="credit" minOccurs="0" maxOccurs="unbounded"/>
         <xs:element name="part-list" type="part-list"/>
         </xs:sequence>
         </xs:group>
         */
        class ScoreHeaderGroup;
        using ScoreHeaderGroupPtr = std::shared_ptr<ScoreHeaderGroup>;
        using ScoreHeaderGroupUPtr = std::unique_ptr<ScoreHeaderGroup>;
        using ScoreHeaderGroupSet = std::vector<ScoreHeaderGroupPtr>;
        using ScoreHeaderGroupSetIter = ScoreHeaderGroupSet::iterator;
        using ScoreHeaderGroupSetIterConst = ScoreHeaderGroupSet::const_iterator;
        inline ScoreHeaderGroupPtr makeScoreHeaderGroup() { return std::make_shared<ScoreHeaderGroup>(); }
        class ScoreHeaderGroup : public ElementInterface
        {
        public:
            ScoreHeaderGroup();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            /* _________ Work minOccurs = 0, maxOccurs = 1 _________ */
            WorkPtr getWork() const;
            void setWork( const WorkPtr& value );
            bool getHasWork() const;
            void setHasWork( const bool value );
            /* _________ MovementNumber minOccurs = 0, maxOccurs = 1 _________ */
            MovementNumberPtr getMovementNumber() const;
            void setMovementNumber( const MovementNumberPtr& value );
            bool getHasMovementNumber() const;
            void setHasMovementNumber( const bool value );
            /* _________ MovementTitle minOccurs = 0, maxOccurs = 1 _________ */
            MovementTitlePtr getMovementTitle() const;
            void setMovementTitle( const MovementTitlePtr& value );
            bool getHasMovementTitle() const;
            void setHasMovementTitle( const bool value );
            /* _________ Identification minOccurs = 0, maxOccurs = 1 _________ */
            IdentificationPtr getIdentification() const;
            void setIdentification( const IdentificationPtr& value );
            bool getHasIdentification() const;
            void setHasIdentification( const bool value );
            /* _________ Defaults minOccurs = 0, maxOccurs = 1 _________ */
            DefaultsPtr getDefaults() const;
            void setDefaults( const DefaultsPtr& value );
            bool getHasDefaults() const;
            void setHasDefaults( const bool value );
            /* _________ Credit minOccurs = 0, maxOccurs = unbounded _________ */
            const CreditSet& getCreditSet() const;
            void addCredit( const CreditPtr& value );
            void removeCredit( const CreditSetIterConst& value );
            void clearCreditSet();
            CreditPtr getCredit( const CreditSetIterConst& setIterator ) const;
            /* _________ PartList minOccurs = 1, maxOccurs = 1 _________ */
            PartListPtr getPartList() const;
            void setPartList( const PartListPtr& value );
        private:
            WorkPtr myWork;
            bool myHasWork;
            MovementNumberPtr myMovementNumber;
            bool myHasMovementNumber;
            MovementTitlePtr myMovementTitle;
            bool myHasMovementTitle;
            IdentificationPtr myIdentification;
            bool myHasIdentification;
            DefaultsPtr myDefaults;
            bool myHasDefaults;
            CreditSet myCreditSet;
            PartListPtr myPartList;
        };
        
        /* <!--  ID = 6403 [6403] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 645 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="score-partwise" block="extension substitution" final="#all">
         <xs:annotation>
         <xs:documentation>The score-partwise element is the root element for a partwise MusicXML score. It includes a score-header group followed by a series of parts with measures inside. The document-attributes attribute group includes the version attribute.</xs:documentation>
         </xs:annotation>
         <xs:complexType>
         <xs:sequence>
         <xs:group ref="score-header"/>
         <xs:element name="part" maxOccurs="unbounded">
         <xs:complexType>
         <xs:sequence>
         <xs:element name="measure" maxOccurs="unbounded">
         <xs:complexType>
         <xs:group ref="music-data"/>
         <xs:attributeGroup ref="measure-attributes"/>
         </xs:complexType>
         </xs:element>
         </xs:sequence>
         <xs:attributeGroup ref="part-attributes"/>
         </xs:complexType>
         </xs:element>
         </xs:sequence>
         <xs:attributeGroup ref="document-attributes"/>
         </xs:complexType>
         </xs:element> */
        
        struct ScorePartwiseAttributes;
        using ScorePartwiseAttributesPtr = std::shared_ptr<ScorePartwiseAttributes>;
        
        struct ScorePartwiseAttributes : public AttributesInterface
        {
        public:
            ScorePartwiseAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken version;
            bool hasVersion;
        };
        
        class ScorePartwise;
        using ScorePartwisePtr = std::shared_ptr<ScorePartwise>;
        using ScorePartwiseUPtr = std::unique_ptr<ScorePartwise>;
        using ScorePartwiseSet = std::vector<ScorePartwisePtr>;
        using ScorePartwiseSetIter = ScorePartwiseSet::iterator;
        using ScorePartwiseSetIterConst = ScorePartwiseSet::const_iterator;
        inline ScorePartwisePtr makeScorePartwise() { return std::make_shared<ScorePartwise>(); }
        class ScorePartwise : public ElementInterface
        {
        public:
            ScorePartwise();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            ScorePartwiseAttributesPtr getAttributes() const;
            void setAttributes( const ScorePartwiseAttributesPtr& value );
            /* _________ ScoreHeaderGroup minOccurs = 1, maxOccurs = 1 _________ */
            ScoreHeaderGroupPtr getScoreHeaderGroup() const;
            void setScoreHeaderGroup( const ScoreHeaderGroupPtr& value );
            /* _________ PartwisePart minOccurs = 1, maxOccurs = unbounded _________ */
            const PartwisePartSet& getPartwisePartSet() const;
            void addPartwisePart( const PartwisePartPtr& value );
            void removePartwisePart( const PartwisePartSetIterConst& value );
            void clearPartwisePartSet();
            PartwisePartPtr getPartwisePart( const PartwisePartSetIterConst& setIterator ) const;
        private:
            ScorePartwiseAttributesPtr myAttributes;
            ScoreHeaderGroupPtr myScoreHeaderGroup;
            PartwisePartSet myPartwisePartSet;
        };
        
        
        
        
        /*
         <xs:element name="part" maxOccurs="unbounded">
         <xs:complexType>
         <xs:group ref="music-data"/>
         <xs:attributeGroup ref="part-attributes"/>
         </xs:complexType>
         </xs:element>
         */
        class TimewisePart;
        using TimewisePartPtr = std::shared_ptr<TimewisePart>;
        using TimewisePartUPtr = std::unique_ptr<TimewisePart>;
        using TimewisePartSet = std::vector<TimewisePartPtr>;
        using TimewisePartSetIter = TimewisePartSet::iterator;
        using TimewisePartSetIterConst = TimewisePartSet::const_iterator;
        inline TimewisePartPtr makeTimewisePart() { return std::make_shared<TimewisePart>(); }
        class TimewisePart : public ElementInterface
        {
        public:
            TimewisePart();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            PartAttributesPtr getAttributes() const;
            void setAttributes( const PartAttributesPtr& value );
            /* _________ MusicDataGroup minOccurs = 1, maxOccurs = 1 _________ */
            MusicDataGroupPtr getMusicDataGroup() const;
            void setMusicDataGroup( const MusicDataGroupPtr& value );
        private:
            PartAttributesPtr myAttributes;
            MusicDataGroupPtr myMusicDataGroup;
        };
        
        struct MeasureAttributes;
        using MeasureAttributesPtr = std::shared_ptr<MeasureAttributes>;
        
        //        struct MeasureAttributes : public AttributesInterface
        //        {
        //        public:
        //            MeasureAttributes();
        //            virtual bool hasValues() const;
        //            virtual std::ostream& toStream( std::ostream& os ) const;
        //            t::XsToken number;
        //            t::YesNo implicit;
        //            t::YesNo nonControlling;
        //            t::TenthsValue width;
        //            const 	bool hasNumber;
        //            bool hasImplicit;
        //            bool hasNonControlling;
        //            bool hasWidth;
        //        };
        //
        class TimewiseMeasure;
        using TimewiseMeasurePtr = std::shared_ptr<TimewiseMeasure>;
        using TimewiseMeasureUPtr = std::unique_ptr<TimewiseMeasure>;
        using TimewiseMeasureSet = std::vector<TimewiseMeasurePtr>;
        using TimewiseMeasureSetIter = TimewiseMeasureSet::iterator;
        using TimewiseMeasureSetIterConst = TimewiseMeasureSet::const_iterator;
        inline TimewiseMeasurePtr makeTimewiseMeasure() { return std::make_shared<TimewiseMeasure>(); }
        class TimewiseMeasure : public ElementInterface
        {
        public:
            TimewiseMeasure();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            MeasureAttributesPtr getAttributes() const;
            void setAttributes( const MeasureAttributesPtr& value );
            /* _________ TimewisePart minOccurs = 1, maxOccurs = unbounded _________ */
            const TimewisePartSet& getTimewisePartSet() const;
            void addTimewisePart( const TimewisePartPtr& value );
            void removeTimewisePart( const TimewisePartSetIterConst& value );
            void clearTimewisePartSet();
            TimewisePartPtr getTimewisePart( const TimewisePartSetIterConst& setIterator ) const;
        private:
            MeasureAttributesPtr myAttributes;
            TimewisePartSet myTimewisePartSet;
        };
        
        /* <!--  ID = 6430 [6430] ------------------------->
         <!-- min=1 max=1 RequiredSingleOccurence  -->
         <!-- MsItemElementKind::composite -->
         <!-- RecursiveSubElementCount = 645 -->
         <!-- All Sub Elements Are Implemented: true -->
         <xs:element name="score-timewise" block="extension substitution" final="#all">
         <xs:annotation>
         <xs:documentation>The score-timewise element is the root element for a timewise MusicXML score. It includes a score-header group followed by a series of measures with parts inside. The document-attributes attribute group includes the version attribute.</xs:documentation>
         </xs:annotation>
         <xs:complexType>
         <xs:sequence>
         <xs:group ref="score-header"/>
         <xs:element name="measure" maxOccurs="unbounded">
         <xs:complexType>
         <xs:sequence>
         <xs:element name="part" maxOccurs="unbounded">
         <xs:complexType>
         <xs:group ref="music-data"/>
         <xs:attributeGroup ref="part-attributes"/>
         </xs:complexType>
         </xs:element>
         </xs:sequence>
         <xs:attributeGroup ref="measure-attributes"/>
         </xs:complexType>
         </xs:element>
         </xs:sequence>
         <xs:attributeGroup ref="document-attributes"/>
         </xs:complexType>
         </xs:element> */
        
        struct ScoreTimewiseAttributes;
        using ScoreTimewiseAttributesPtr = std::shared_ptr<ScoreTimewiseAttributes>;
        
        struct ScoreTimewiseAttributes : public AttributesInterface
        {
        public:
            ScoreTimewiseAttributes();
            virtual bool hasValues() const;
            virtual std::ostream& toStream( std::ostream& os ) const;
            t::XsToken version;
            bool hasVersion;
        };
        
        class ScoreTimewise;
        using ScoreTimewisePtr = std::shared_ptr<ScoreTimewise>;
        using ScoreTimewiseUPtr = std::unique_ptr<ScoreTimewise>;
        using ScoreTimewiseSet = std::vector<ScoreTimewisePtr>;
        using ScoreTimewiseSetIter = ScoreTimewiseSet::iterator;
        using ScoreTimewiseSetIterConst = ScoreTimewiseSet::const_iterator;
        inline ScoreTimewisePtr makeScoreTimewise() { return std::make_shared<ScoreTimewise>(); }
        class ScoreTimewise : public ElementInterface
        {
        public:
            ScoreTimewise();
            virtual bool hasAttributes() const;
            virtual std::ostream& streamAttributes( std::ostream& os ) const;
            virtual std::ostream& streamName( std::ostream& os ) const;
            virtual bool hasContents() const;
            virtual std::ostream& streamContents( std::ostream& os, const int indentLevel, bool& isOneLineOnly ) const;
            ScoreTimewiseAttributesPtr getAttributes() const;
            void setAttributes( const ScoreTimewiseAttributesPtr& value );
            /* _________ ScoreHeaderGroup minOccurs = 1, maxOccurs = 1 _________ */
            ScoreHeaderGroupPtr getScoreHeaderGroup() const;
            void setScoreHeaderGroup( const ScoreHeaderGroupPtr& value );
            /* _________ TimewiseMeasure minOccurs = 1, maxOccurs = unbounded _________ */
            const TimewiseMeasureSet& getTimewiseMeasureSet() const;
            void addTimewiseMeasure( const TimewiseMeasurePtr& value );
            void removeTimewiseMeasure( const TimewiseMeasureSetIterConst& value );
            void clearTimewiseMeasureSet();
            TimewiseMeasurePtr getTimewiseMeasure( const TimewiseMeasureSetIterConst& setIterator ) const;
        private:
            ScoreTimewiseAttributesPtr myAttributes;
            ScoreHeaderGroupPtr myScoreHeaderGroup;
            TimewiseMeasureSet myTimewiseMeasureSet;
        };
    }
}

// Program ended with exit code: 0